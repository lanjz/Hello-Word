# 动态规划

动态规划（Dynamic Programming，DP）一般用于可以通过子问题来寻找最终答案的题目，当然所有子问题及子问题的解法是一样。这类题目的关键词：重叠子问题，最优子结构

### 复杂度

动态规则的时间复杂度 = 递归函数的复杂度 * 递归函数的调用次数

## 粟子

动态规则相关的题目

### [斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)

写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：

```
F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
```

斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1

**暴力递归**

```js
var fib = function(n) {
    if(n<2) return n
    return fib(n-1)+fib(n-2)
};
```

时间复杂度：O(2^n) * O(1) = O(2^n)

问题：在递归调用的时候会造成重复的计算，比如：`fib(7) = fib(6) + fib(5)`、`fib(6) = fib(5)+fib(4)`,这里 `fib(5)` 就重复计算了

**优化一：缓存**

添加一个对象将已经计算过的值缓存起来

```js
/**
 * @param {number} n
 * @return {number}
 */
let map = []
var fib = function(n) {
    if(n<2) return n
    if(map[n]) return map[n]
    map[n] = fib(n-1)+fib(n-2)
    return map[n]%1000000007
};
```

优化后所有的值只需调用一次就可以了，所以递归的调用次数为 n 次。那么得到时间复杂度：O(n) * O(1) = O(n)

但是额外创建了 `map` 存储所有值，所以额外添加了空间复杂度：O(n)，典型的空间换时间

**至底向上解决**

上面的例子都是至顶向下的解法，现在使用迭代的方式完成致底向上的解法

```js
/**
 * @param {number} n
 * @return {number}
 */

var fib = function(n) {
    let map = []
    map[0] = 0
    map[1] = 1
    for(let i = 2; i<=n; i++){
        map[i] = (map[i-1]+map[i-2])%1000000007
    }
    return map[n]
};
```

时间复杂度：O(n)

空间复杂度：O(n)

**优化二：优化空间复杂度**

根据斐波那契的规律，`F(N) = F(N - 1) + F(N - 2)`，实际上并不需要保存所有的值，只需要保存 `F(N - 1)` 和 ` F(N - 2)` 这两个值即可，所以在至底向上的解法上可以做进一步优化

```js
/**
 * @param {number} n
 * @return {number}
 */

var fib = function(n) {
    if(n<2) return n
    let a = 0
    let b = 1
    let result = 0
    for(let i = 2; i<=n; i++){
        result = (a+b) %1000000007
        a = b
        b = result
    }
    return result 
};
```

只需要额外三个变量就可以完成优化，空间复杂直接降到 O(1)

### [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

- 示例一. 爬2个台阶，有两种解法：

  1. 1阶 + 1阶
  
  2. 2阶
  
- 示例二. 爬3个台阶，有三种解法：

  1. 1阶 + 1 阶 + 1 阶
  
  2. 1阶 + 2 阶
  
  3. 2阶 + 1 阶

假设楼梯有5阶，那么分析思路为：

当第一步走一阶时：剩下的楼梯还有四阶，那么剩下的四阶有几种走法？

当一步走两阶时，剩下的楼梯有三阶，那么剩下的三阶有几种走法？

**问题的规模随着拆分，会变得越来越小，这种将问题拆解，并通过计算小问题的解，最终计算出最优解的思想就是动态规划**

假设走完x阶楼梯有f(x)种走法，那么根据上面的分析一共有这么多的方法可以走完整个楼梯: `f(x) = f(x-1) + f(x-2)`

```js
let allMethods = function(n){
   let dp = []
   dp[0] =1;
   dp[1] = 1;
   for( let i = 2 ; i <= n; i ++ ){
    dp[i]  = dp[i-1] + dp[i-2]
   }
   return dp[n]
}
```

此算法的时间复杂度为O(n)，空间复杂度为：O(n)

此题跟斐波那契数列的解法几乎一致

### [零钱兑换](https://leetcode-cn.com/problems/coin-change/)

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回-1。

你可以认为每种硬币的数量是无限的。

示例：

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
示例 2：
```

```
输入：coins = [2], amount = 3
输出：-1
示例 3：
```

```
输入：coins = [1], amount = 0
输出：0
示例 4：
```

```
输入：coins = [1], amount = 1
输出：1
示例 5：
```

```
输入：coins = [1], amount = 2
输出：2
```

这个题目符合寻找最优子结构的特点。如例一 `coins = [1, 2, 5], amount = 11`，假设先取出一个面值为 `1` 的硬币，此时就需求从 `[1,2,5]` 中找出能凑成 `11-1=10` 的最少的硬币数量，也就是题目变成了 `coins = [1, 2, 5], amount = 10`

**暴力递归**

```js
/**
 * @param {number[]} coins
 * @param {number} amount
 * @return {number}
 */
var coinChange = function(coins, amount) {
    let result = Infinity
    if(amount === 0){
        return 0
    }
    if(amount < 0){
        return -1
    }
    for(let i of coins){
        let subResult = coinChange(coins, amount - i)
        if(subResult === -1) continue
        result = Math.min(result, subResult+1)
    }
    return result === Infinity ? -1 : result
};
```

时间复杂度分析：递归总数 x 每个递归函数的时间

- 递归总数：递归树节点个数，是 O(n^k)

- 每个递归函数的时间：每个递归函数中含有一个 `for` 循环,O(k)

所以总时间复杂度为 O(k * n^k)，指数级别

执行上述的代码将会提示运行超时，可以参考之前斐波那契数的题目做优化

**优化一：缓存**

```js
/**
 * @param {number[]} coins
 * @param {number} amount
 * @return {number}
 */
let map = []
var coinChange = function(coins, amount) {
    let result = Infinity
    if(amount === 0){
        return 0
    }
    if(amount < 0){
        return -1
    }
    if(map[amount] !== undefined){
        return map[amount]
    }
    for(let i of coins){
        let subResult = coinChange(coins, amount - i)
        if(subResult === -1) continue
        result = Math.min(result, subResult+1)
    }
    map[amount] = (result === Infinity ? -1 : result)
    return map[amount]
};
```

时间复杂度：递归数量（n），每个递归需要的时间仍是（k），所以最终的复杂度为 O(kn)

**使用迭代至底向上解法**

```js
/**
 * @param {number[]} coins
 * @param {number} amount
 * @return {number}
 */

var coinChange = function(coins, amount) {
    let dp = (new Array(amount+1)).fill(Infinity)
    dp[0] = 0
    for(let i = 0;i<dp.length;i++){
        for(let j of coins){
            if(i - j < 0) continue
            dp[i] = Math.min(dp[i], 1 + dp[i-j])
        }
    }
    return dp[amount] === Infinity ? -1 : dp[amount]
};
```

注意点：

- `new Array(amount+1)`，因为最终是取 `amount` 数量的值，数组下标是从 `0` 开始，所以要取下 `amount` 的值，那么数组的数量需为 `amount+1`

- `dp[i] = x`表示，当目标金额为 `i` 时，至少需要 x枚 硬币

### [最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。

例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

```
示例 1：
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
示例 2：
```

```
示例 2：
输入：nums = [0,1,0,3,2,3]
输出：4

```

```
示例 3：
输入：nums = [7,7,7,7,7,7,7]
输出：1
```

**思路：**

- 定义 `dp[i]`，表示以 `nums[i]` 这个数结尾的最长递增子序列的长度

- 那么`num[i+1]` 等于啥？ 找出 `dp` 中小于 `i+1` 的下标再`加 1`

**人类看得懂版：**

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function(nums) {
    let result = 0
    let list = {}// 对应 dp[i]
    for(let i of nums){
        list[i] = 1
        for(let j of Object.keys(list)){
            if(j < i){
                list[i] = Math.max(list[i],list[j]+1 )
            }  
        }
        result = Math.max(result, list[i])
    }
    return result
};
```

**代码优化版**

```js
var lengthOfLIS = function(nums, dp = [1]) {
    for (let i = 1; i < nums.length; i++){
        dp[i] = 1
        for (let j = 0; j < i; j++) {
            nums[i] > nums[j] && (dp[i] = Math.max(dp[i], dp[j] + 1))
        }
    }
    return Math.max(...dp)
}
```

思路是一样的，但是 LeeCode 跑分会多很多，就是不好理解

### [最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。

```
示例 1:
输入:"bbbab"
输出:4
一个可能的最长回文子序列为 "bbbb"。
```

```
示例 2:
输入:"cbbd"
输出:2
一个可能的最长回文子序列为 "bb"。
```

**解题思路**

以 `let s = bbbab` 例子为例

使用 `s[i][j]` 表示第 i 个与第 j 个字符组成的字符串，比如 `s[00] => b`、 `s[12] => bb`、 `s[03] => ba`

现在假设 `s[i][j]` 已经确定了最大回文数是 N，那么当判断 `s[i-1][j+1]`的最大回数的时候就只有两种情况了：

1 `i-1` 和 `j+1` 两个字符相等，那么就在之前的回文数的基本上加 2，即 `s[i-1][j+1] = s[i][j]+2`

2. `i-1` 和 `j+1` 两个字符不相等，不相等的情况下就取已知的回文数的最大值，已经的有两个`s[i][j-1]`和s`[i-1][j]`

```
// 以上面的例子为例
s[0][0]=b
s[1][1]=b
s[2][2]=a
s[3][3]=b
上面的字符都是只有一个数，一个数也是回文数 s[0][0]=s[1][1]=s[2][2]=s[3[3]=1
s[0][1]=bb 最左的b等于最右的b，按上面的公式 s[0][1]=s[0][1]之间的回文数+2，但是s[0][1]之间没有字符，所以s[0][1]=0+2
s[1][2]=bb 同上 ，所以s[1][2]=0+2
s[0][2]=bbb 最左的b等于最右的b，按上面的公式 s[0][1]的最大回文数等于s[0][2]之间的回文数+2，中间的数字符为s[1][1]=1,所以s[0][2]=1+2=3
s[2][3]=ba b和a不相等，且包含的大长子串为 s[2][2] = b和 s[3][3] = a,取大回文数所以s[2][3]=1
s[1][3]=bba b和a不相等，不相等取内侧的两个最长子串的回文数大的那个，即 Math.max(s[1][2], s[2][3])，所以s[1][3]=Math.max(2, 1)=2
```

根据上面的思路，编写代码的时候要从子串开始往外遍历

如要判断 `s[0][4]` 即最大回文数就得知道 `s[1][4]`和 `s[0][3]`的回文数

要判断 `s[1][4]` 即最大回文数就得知道 `s[2][4]`和 `s[1][3]`的回文数

要判断 `s[2][4]` 即最大回文数就得知道 `s[3][4]`和 `s[2][3]`的回文数

代码：

```js
/**
 * @param {string} s
 * @return {number}
 */
var longestPalindromeSubseq = function(s) {
    let map= []
    // 创建一个 s*s 的二维数组，存放各子串的最大回文数
    for(let i=0;i<s.length;i++){
        map.push(new Array(s.length))
    }

    for(let i=0;i<=s.length-1;i++){ // 从头开始遍历
        for(let j=i;j>=0;j--){ // 内层从上层的位置开始往前遍历
            if(i===j) {  // 指向单个字符
                map[j][i] = 1
            } else if(i-j === 1){ // 两个相邻的字符，不同取1，相同取2
                map[j][i] = s[i]===s[j] ? 2: 1
            } else if(s[i] === s[j]){ // 如果不同，则取里面的子串数+2
                map[j][i] =  map[j+1][i-1]+2
            } else { // 如果相同，取两个最长子串的最大回文数
                 map[j][i] =  Math.max(map[j+1][i], map[j][i-1])
            }
            
        }
    }
    return map[0][s.length-1]
};
```

上面的代码主要是于两个 for 循环的遍历方向问题，通过上面的粟子 `bbbab` 来理解一下

```
for: i=0 ,再经过内层for 循环后，可以得到 s[0][0]
for: i=1 ,再经过内层for 循环后，可以得到 s[1][1] s[0][1]
for: i=2 ,再经过内层for 循环后，可以得到 s[2][2] s[1][2] s[2][2]
for: i=3 ,再经过内层for 循环后，可以得到 s[3][3] s[2][3] s[1][3],注意这里判断 `s[1][3]` 的时候，就是需要利用子串的最大回文数，子串为 s[1][2],s[2][2],s[2][3],无论哪个都是之前已经得到结果的
```

优化：上面 i=j 的情况可以直接在初始 map 的时候直接赋值，这个下面的循环可以省去 i=j 的操作

```js
/**
 * @param {string} s
 * @return {number}
 */
var longestPalindromeSubseq = function(s) {
    let map= []
    for(let i=0;i<s.length;i++){
        map.push((new Array(s.length)).fill(1))
    }

    for(let i=0;i<=s.length-1;i++){
        for(let j=i-1;j>=0;j--){
            if(i-j === 1){
                map[j][i] = s[i]===s[j] ? 2: 1
            } else if(s[i] === s[j]){
                map[j][i] =  map[j+1][i-1]+2
            } else {
                 map[j][i] =  Math.max(map[j+1][i], map[j][i-1])
            }
            
        }
    }
    return map[0][s.length-1]
};
```

### [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

```
给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。

示例 1：

输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
示例 2：

输入：coins = [2], amount = 3
输出：-1
示例 3：

输入：coins = [1], amount = 0
输出：0
示例 4：

输入：coins = [1], amount = 1
输出：1
示例 5：

输入：coins = [1], amount = 2
输出：2
```

**公式**

```js
dp[i]=Math.min(dp[i], dp[i-j]+1)
```

```js
/**
 * @param {number[]} coins
 * @param {number} amount
 * @return {number}
 */

var coinChange = function(coins, amount) {
    let dp=new Array(amount+1).fill(Infinity)
    dp[0] = 0
    // 计算从1到amound的每个数所需要的硬币数量
    for(let i =0;i<=amount;i++){
    // 对于每一个数都从coins中获取所需的数量
       for(let j of coins){  
            if(j>i) continue // 如果当前数小于当前面额，直接跳过
            dp[i]=Math.min(dp[i], dp[i-j]+1) // 取当前小数量值
        }
    }
    return dp[amount] === Infinity ? -1: dp[amount]
};
```

### [343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)

```
给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

示例 1:

输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
示例 2:

输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```


**思路**

1. 最于任意数 `i`，假设拆成两个数，需要进行 `i-1`次拆分，如 `1*(i-1)、2*(i-2)、3*(i-3)、4*(i-4)、...、(i-1)*(i-(i-1))`，从中等到最大值

   ```js
    let max = 0
    for(let j = 1; j<i; j++){
       max = Math.max(max, j*(i-j))
    }
   ```
   
2. 上一步知道了如何得到拆分两个数的情况得到最大乘积，那么对于拆分数量是 `>=2` 的情况，就可能需要对子数做进一步的拆分，比如对于已经拆分的 `2*(n-2)`，对于 `n-2` 可能需要继续拆分。以此类推可以发现对越小数进行拆分时可拆分的数量越小，如

   ```
     对于1：不可拆分
     对于2：1*1
     对于3：1*2
   ```
   
   所以可以定义 `dp` 保存 `1到i` 之间每一个数的最大乘积值
   
3. 所以对于任意数 `i`，做一次拆分时最大乘积结果为 `j*(i-j)` 或者 `j*dp[i-j])`，`dp[i-j])` 表示继续进行拆分后的最大乘积

```js
/**
 * @param {number} n
 * @return {number}
 */
var integerBreak = function(n) {
    let dp = []
    for(let i = 1; i<=n; i++){
        let max = 0
        for(let j = 1; j<i; j++){
           max = Math.max(max, j*(i-j), j*dp[i-j])
        }
        dp[i] = max
    }
    return dp[n]
};
```

[动态规划详解](https://mp.weixin.qq.com/s/1V3aHVonWBEXlNUvK3S28w)

[动态规划详解（修订版）](https://mp.weixin.qq.com/s/Cw39C9MY9Wr2JlcvBQZMcA)

[手把手刷动态规划](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAxODQxMDM0Mw==&action=getalbum&album_id=1318881141113536512&scene=173&from_msgid=2247484731&from_itemidx=1&count=3&nolastread=1#wechat_redirect)

