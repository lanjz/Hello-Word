# 动态规划

动态规划（Dynamic Programming，DP）一般用于可以通过子问题来寻找最终答案的题目，当然所有子问题及子问题的解法是一样。这类题目的关键词：重叠子问题，最优子结构

### 复杂度

动态规则的时间复杂度 = 递归函数的复杂度 * 递归函数的调用次数

## 粟子

动态规则相关的题目

### [斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)

写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：

```
F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
```

斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1

**暴力递归**

```js
var fib = function(n) {
    if(n<2) return n
    return fib(n-1)+fib(n-2)
};
```

时间复杂度：O(2^n) * O(1) = O(2^n)

问题：在递归调用的时候会造成重复的计算，比如：`fib(7) = fib(6) + fib(5)`、`fib(6) = fib(5)+fib(4)`,这里 `fib(5)` 就重复计算了

**优化一：缓存**

添加一个对象将已经计算过的值缓存起来

```js
/**
 * @param {number} n
 * @return {number}
 */
let map = []
var fib = function(n) {
    if(n<2) return n
    if(map[n]) return map[n]
    map[n] = fib(n-1)+fib(n-2)
    return map[n]%1000000007
};
```

优化后所有的值只需调用一次就可以了，所以递归的调用次数为 n 次。那么得到时间复杂度：O(n) * O(1) = O(n)

但是额外创建了 `map` 存储所有值，所以额外添加了空间复杂度：O(n)，典型的空间换时间

**至底向上解决**

上面的例子都是至顶向下的解法，现在使用迭代的方式完成致底向上的解法

```js
/**
 * @param {number} n
 * @return {number}
 */

var fib = function(n) {
    let map = []
    map[0] = 0
    map[1] = 1
    for(let i = 2; i<=n; i++){
        map[i] = (map[i-1]+map[i-2])%1000000007
    }
    return map[n]
};
```

时间复杂度：O(n)

空间复杂度：O(n)

**优化二：优化空间复杂度**

根据斐波那契的规律，`F(N) = F(N - 1) + F(N - 2)`，实际上并不需要保存所有的值，只需要保存 `F(N - 1)` 和 ` F(N - 2)` 这两个值即可，所以在至底向上的解法上可以做进一步优化

```js
/**
 * @param {number} n
 * @return {number}
 */

var fib = function(n) {
    if(n<2) return n
    let a = 0
    let b = 1
    let result = 0
    for(let i = 2; i<=n; i++){
        result = (a+b) %1000000007
        a = b
        b = result
    }
    return result 
};
```

只需要额外三个变量就可以完成优化，空间复杂直接降到 O(1)

### [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

- 示例一. 爬2个台阶，有两种解法：

  1. 1阶 + 1阶
  
  2. 2阶
  
- 示例二. 爬3个台阶，有三种解法：

  1. 1阶 + 1 阶 + 1 阶
  
  2. 1阶 + 2 阶
  
  3. 2阶 + 1 阶

假设楼梯有5阶，那么分析思路为：

当第一步走一阶时：剩下的楼梯还有四阶，那么剩下的四阶有几种走法？

当一步走两阶时，剩下的楼梯有三阶，那么剩下的三阶有几种走法？

**问题的规模随着拆分，会变得越来越小，这种将问题拆解，并通过计算小问题的解，最终计算出最优解的思想就是动态规划**

假设走完x阶楼梯有f(x)种走法，那么根据上面的分析一共有这么多的方法可以走完整个楼梯: `f(x) = f(x-1) + f(x-2)`

```js
let allMethods = function(n){
   let dp = []
   dp[0] =1;
   dp[1] = 1;
   for( let i = 2 ; i <= n; i ++ ){
    dp[i]  = dp[i-1] + dp[i-2]
   }
   return dp[n]
}
```

此算法的时间复杂度为O(n)，空间复杂度为：O(n)

此题跟斐波那契数列的解法几乎一致

### [零钱兑换](https://leetcode-cn.com/problems/coin-change/)

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

你可以认为每种硬币的数量是无限的。

示例：

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
示例 2：
```

```
输入：coins = [2], amount = 3
输出：-1
示例 3：
```

```
输入：coins = [1], amount = 0
输出：0
示例 4：
```

```
输入：coins = [1], amount = 1
输出：1
示例 5：
```

```
输入：coins = [1], amount = 2
输出：2
```

这个题目符合寻找最优子结构的特点。如例一 `coins = [1, 2, 5], amount = 11`，假设先取出一个面值为 `1` 的硬币，此时就需求从 `[1,2,5]` 中找出能凑成 `11-1=10` 的最少的硬币数量，也就是题目变成了 `coins = [1, 2, 5], amount = 10`

**暴力递归**

```js
/**
 * @param {number[]} coins
 * @param {number} amount
 * @return {number}
 */
var coinChange = function(coins, amount) {
    let result = Infinity
    if(amount === 0){
        return 0
    }
    if(amount < 0){
        return -1
    }
    for(let i of coins){
        let subResult = coinChange(coins, amount - i)
        if(subResult === -1) continue
        result = Math.min(result, subResult+1)
    }
    return result === Infinity ? -1 : result
};
```

时间复杂度分析：递归总数 x 每个递归函数的时间

- 递归总数：递归树节点个数，是 O(n^k)

- 每个递归函数的时间：每个递归函数中含有一个 `for` 循环,O(k)

所以总时间复杂度为 O(k * n^k)，指数级别

执行上述的代码将会提示运行超时，可以参考之前斐波那契数的题目做优化

**优化一：缓存**

```js
/**
 * @param {number[]} coins
 * @param {number} amount
 * @return {number}
 */
let map = []
var coinChange = function(coins, amount) {
    let result = Infinity
    if(amount === 0){
        return 0
    }
    if(amount < 0){
        return -1
    }
    if(map[amount] !== undefined){
        return map[amount]
    }
    for(let i of coins){
        let subResult = coinChange(coins, amount - i)
        if(subResult === -1) continue
        result = Math.min(result, subResult+1)
    }
    map[amount] = (result === Infinity ? -1 : result)
    return map[amount]
};
```

时间复杂度：递归数量（n），每个递归需要的时间仍是（k），所以最终的复杂度为 O(kn)

**使用迭代至底向上解法**

```js
/**
 * @param {number[]} coins
 * @param {number} amount
 * @return {number}
 */

var coinChange = function(coins, amount) {
    let dp = (new Array(amount+1)).fill(Infinity)
    dp[0] = 0
    for(let i = 0;i<dp.length;i++){
        for(let j of coins){
            if(i - j < 0) continue
            dp[i] = Math.min(dp[i], 1 + dp[i-j])
        }
    }
    return dp[amount] === Infinity ? -1 : dp[amount]
};
```

注意点：

- `new Array(amount+1)`，因为最终是取 `amount` 数量的值，数组下标是从 `0` 开始，所以要取下 `amount` 的值，那么数组的数量需为 `amount+1`

- `dp[i] = x`表示，当目标金额为 `i` 时，至少需要 x枚 硬币

[动态规划详解](https://mp.weixin.qq.com/s/1V3aHVonWBEXlNUvK3S28w)

[动态规划详解（修订版）](https://mp.weixin.qq.com/s/Cw39C9MY9Wr2JlcvBQZMcA)

