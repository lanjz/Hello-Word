# 回文串

跟回文串相关的题目基本都离开不动态规划

### [647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)

```
给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。  
具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

示例 1：

输入："abc"
输出：3
解释：三个回文子串: "a", "b", "c"
示例 2：

输入："aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
```

**解**

```js
/**
 * @param {string} s
 * @return {number}
 */
var countSubstrings = function(s) {
    let count = 0
    let dp = new Array(s.length).fill('').map(() => new Array(s.length))
    for(let i =0;i<s.length;i++){
        for(let j = i;j>=0;j--){
            if(j === i) {
                dp[j][i] = true
            } else if((s[j] === s[i])&&((i-j===1)||dp[j+1][i-1])){
                dp[j][i] = true
            } else {
                dp[j][i] = false
            }
            if(dp[j][i]){
                count++
            }
        }
    }
    return count
};
```

### [131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)

**动态规则+回塑**

```
给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。

回文串 是正着读和反着读都一样的字符串。

示例 1：

输入：s = "aab"
输出：[["a","a","b"],["aa","b"]]
示例 2：

输入：s = "a"
输出：[["a"]]
```

**解**

```js
/**
 * @param {string} s
 * @return {string[][]}
 */
var partition = function(s) {
    let bp = new Array(s.length).fill('').map(() => new Array(s.length))
    for(let i = s.length-1;i>=0;i--){
        for(let j = i;j<s.length;j++){
            if(j-i<2 && s[i]===s[j]){
                bp[i][j] = true
            } else if(bp[i+1][j-1] && s[i]===s[j]){
                bp[i][j] = true
            } else{
                bp[i][j] = false
            }
        }
    }
    let res = []
    let tem = []
    let walk = (start) => {
        if(start === s.length){
            res.push([...tem])
            return
        }
        for(let i=start; i<s.length;i++){
            if(!bp[start][i]){
                continue
            }
            tem.push(s.substring(start,i+1))
            walk(i+1)
            tem.pop()
      }
    }
    walk(0)
    return res
}
```

### [9. 回文数](https://leetcode-cn.com/problems/palindrome-number/)

```
给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。

回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。

 

示例 1：

输入：x = 121
输出：true
示例 2：

输入：x = -121
输出：false
解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
示例 3：

输入：x = 10
输出：false
解释：从右向左读, 为 01 。因此它不是一个回文数。
示例 4：

输入：x = -101
输出：false
```

**解一：**

```js
/**
 * @param {number} x
 * @return {boolean}
 */
var isPalindrome = function(x) {
    x+=''
    let start=0, end=x.length-1
    while(start<end){
        if(x[start] === x[end]){
            start++
            end--
        } else {
            return false
        }
    }
    return true
};
```

**解二：**

```js
/**
 * @param {number} x
 * @return {boolean}
 */
var isPalindrome = function(x) {
    if(x < 0) return false
    let _x = x
    let result = 0
    while(_x){
        result = result*10+_x%10
        _x = (_x/10)|0
    }
    return result === x? true: false
};
```

### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

```
给你一个字符串 s，找到 s 中最长的回文子串。

 

示例 1：

输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
示例 2：

输入：s = "cbbd"
输出："bb"
示例 3：

输入：s = "a"
输出："a"
示例 4：

输入：s = "ac"
输出："a"
```

**解**

```js
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
    let res = ''
    let db = new Array(s.length).fill('').map(() => new Array(s.length))
    for(let i=0; i<s.length;i++){
        for(let j=i;j>=0;j--){
            if(i===j){
                db[j][i] = true
            } else if(i-j === 1){
                db[j][i] = (s[i] === s[j] ? true: false)
            }else if(s[i] === s[j]&&db[j+1][i-1]){
                db[j][i] = true
            }
            if(db[j][i] && (i-j+1)>res.length){
                res = s.substring(j,i+1)
            }
        }    
    }
    return res
};
```