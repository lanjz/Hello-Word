# 配置小记

## 多页面配置

> [webpack多页面配置6--热加载刷新](https://godbasin.github.io/2017/08/19/webpack-multi-project-6-hot-reload/)

> [多端多页面项目webpack打包实践与优化](https://imweb.io/topic/5d1091abf7b5692b080f25a4)

实现多页面配置需要修改的地方：

- 入口配置

- 模板插件 `HtmlWebpackPlugin`

- 自定义服务启动

- 实现页面自动更新

**入口配置**

假设当前的页面目录

```js
- src
  - views
     - page1
       - index.js
     - page1
       - index.js
```

规定 `/src/views` 下的目录代表一个页面，需要在 Webpack `entry` 属配置多入口：

```js
entry: {
    page1: './src/views/page1/index.js',
    page2: './src/views/page2/index.js'
}
```

下面是自动根据目录添加 `entry` 配置的辅助方法：

```js
const glob = require("glob");

function multyEntry() {
    const entry = {};
    //读取src目录所有page入口
    glob.sync('./src/views/*/index.js')
        .forEach(function (filePath) {
            console.log('filePath', filePath)
            var name = filePath.match(/\/src\/views\/(.+)\/index.js/);
            name = name[1];
            entry[name] = [filePath, 'webpack-hot-middleware/client?reload=true'];
        });
    console.log('entry', entry)
    return entry;
};

{
    entry: multyEntry()
}
```

**模板插件 `HtmlWebpackPlugin`**

跟入口文件一样，一个页面需要添加一个 `HtmlWebpackPlugin`, 那么怎么跟入口文件对应呢？ 通过 `chunt`。`chunt` 就是上面例子的 `entry` 的 `key` : `page1`和 `page2`

```js
function multyHtmlWebpackPlugin(){
    const htmlPlugin = [];
    glob.sync('./src/views/*/index.js')
        .forEach(function (filePath) {
            var name = filePath.match(/\/src\/views\/(.+)\/index.js/);
            name = name[1];
            htmlPlugin.push(
                new HtmlWebpackPlugin({
                    title: 'Output Management',
                    filename: './' + name + '/index.html',
                    template: './index.html',
                    inject: true,
                    chunks: [name]
                    
                })
            )
        });
    return htmlPlugin;
}
```

**自定义服务启动**

Webpack 本质是通过 `Webpack-dev-server` 来启动服务的，配置多页面多后如果直接使用 `Webpack-dev-server` ，在访问页面的时候需要输入完整的页面地址才能访问，比如要访问上例中的 `page1`， 我们需要输入 `localhost:8080/page1.html`。通过自己搭个服务可以通过创建路由的方式方便我们访问页面

先了解下 `Webpack-dev-server` 中主要用到了两个核心模块：

- `webpack-dev-middleware`: 是一个处理静态资源的 `middleware`

- `webpack-hot-middleware`: 结合 `webpack-dev-middleware` 使用的 `middleware` ，它可以实现浏览器的无刷新更新（hot reload）。这也是 Webpack 文档里常说的 HMR（Hot Module Replacement）

所以自定义搭建的服务如下：

```js
// dev-server.js
var express = require('express')
var webpack = require('webpack')
var path = require('path')
var webpackHotMiddleware = require('webpack-hot-middleware')
var WebpackDevMiddleware = require('webpack-dev-middleware')
var multyWebpack = require('./webpack.multy')
var webpackConfig = multyWebpack(require('./webpack_config')({}))
var app = express();
// webpack编译器
var compiler = webpack(webpackConfig);
// webpack-dev-server中间件
var devMiddleware = WebpackDevMiddleware(compiler, {
    publicPath: '/',
    // publicPath: webpackConfig.output.publicPath,
    stats: {
        colors: true,
        chunks: false
    },
    progress: true,
    inline: true,
    hot: true
});

app.use(devMiddleware)
app.use(webpackHotMiddleware(compiler))

// 路由
app.get('*', function(req, res, next) {
    const pageKeys = Object.keys(webpackConfig.entry)
    const pageList = pageKeys.map(item => {
        return `<h2><a href="/${item}">${item}.html</a></h2>`
    })
    res.set('content-type', 'text/html');
    res.send(pageList.join(''));
    res.end();
});
module.exports = app.listen(8080, function(err) {
    if (err) {
        // do something
        return;
    }
    console.log('Listening at http://localhost:' + '8000' + '\n')
})
```

当前输入的地址没有匹配到我们多页面的文件时，将会进入上面的路由配置，上面的将根据入口文件返回页面列页列表

**实现页面自动更新**

用自己的服务服务启动项目后，发现当修改代码时，控制台重新编译了，但是页面并没有自动更新。所以我需要额外实现模块热更新功能 

给每个页面注入热更新插件 `webpack-hot-middleware/client?reload=true`，所以优化上文的获取入口的函数

```js
const glob = require("glob");

function multyEntry() {
    const entry = {};
    //读取src目录所有page入口
    glob.sync('./src/views/*/index.js')
        .forEach(function (filePath) {
            console.log('filePath', filePath)
            var name = filePath.match(/\/src\/views\/(.+)\/index.js/);
            name = name[1];
            entry[name] = [filePath, 'webpack-hot-middleware/client?reload=true'];
        });
    return entry;
};

{
    entry: multyEntry()
}
```

完整的热更新还需要实现两点：

- 在 Webpack 配置中添加 `plugin` 插件 `new webpack.HotModuleReplacementPlugin()`

- 在 Express 服务中添加中间件 `webpack-hot-middleware`


## 支持React

需要添加的依赖：`react`, `react-dom`, `@babel/preset-react`, 

**.babelrc配置**

```js
{
  "presets": [
    [
      "@babel/preset-env",
      {
        "useBuiltIns": "usage",
        "corejs":2
      }
    ],
    "@babel/preset-react"
  ]
}

```

## 支持Vue

需要添加的依赖：`vue`, `vue-loader`, `vue-template-compiler`

**webpack 添加Loader规则**

```js
 rules: [
    {
        test: /\.vue$/,
        exclude: /node_modules/,
        use:[
            "vue-loader"
        ]
    },
 ]
```

**webpack 添加Vue插件**

`Vue-loader` 在 `15.*` 之后的版本 `vue-loader` 的使用都是需要添加插件 `VueLoaderPlugin`

```js
const VueLoaderPlugin = require('vue-loader/lib/plugin')
plugins: [  new VueLoaderPlugin() ]
```