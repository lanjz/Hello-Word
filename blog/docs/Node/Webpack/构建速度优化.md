# 构建速度优化

# 缩小文件搜索范围

## 优化Loader配置

Loader对文件的转换非常的耗时，我们可以利用`exclude`、`test`、`include`属性，优化要使用Loader的文件，尽可能少的让文件被Loader处理

```js
module.exports = {
  module: {
    rules:[
      {
        test: /\.js$/, //如果项目源码中只有JS文件，就不要写成/\.jsx?$/，以提升正则表达式的性能
        use: ['babel-loader?cacheDirectory'], // label-loader支持缓存转换出的结果，通过cacheDirectory来启动
        include: path.resolve(__dirname, 'src') // 只对项目根目录下的src目录中的文件采用babel-loader
      }
    ]
  }
}

```

## 优化resolve.modules配置

`resolve.modules`作用：

配置webpack去哪个目录寻找第三方模块，webpack默认会在当前项目根目录的`node_modules`下寻找第三方模块，如果当前`node_modules`没有找到对应的模块则去上一级目录下的`node_modules`中找，以此类推。

结果实际的开发使用场景，我们并不需要一层层地寻找，因此我们可以指定第三方模块的目录，减少webpack的寻找，配置如下：

```
module.exports = {
  resolve: {
   //  dirname表示当前工作目录，也就是项目根目录
    modules: [path.resovle(__dirname, 'node_modules')]
  }
}
```

## 优化resolve.extensions配置

默认情况下，webpack寻找没有带后缀的文件时，会自动带上后缀去寻找，默认是通过`resolve.extension`配置的后缀列表按顺序去寻找，默认是：

`extensions:['.js', '.json']`

因为我们可以根据以下情况去优化`resolve.extensions`

- 没使用到的后缀名不列表入`resolve.extensions`中

- 高频后缀名放在前面

- 在引入文件时，不要忽略后缀名，将后缀名书完整

```
module.exports = {
  resolve: {
    extensions: ['js']
  }
}
```

## 优化resolve.noParse配置

`resolve.noParse`作用：

对于没有模块化的文件，能过这个配置让webpack忽略对这些文件的递归解析，以此提高构建性能。比如`JQuery`、'ChartJs'等没用采用模块化的方式，让webpack解析这些文件即耗时又没有意义

```
module.exports = {
  resolve: {
    noParse: [/react\.min\.js$/]
  }
}

```

## 优化resolve.mainFields配置

`resolve.mainFileds`作用：

配置第三方模块使用哪个入口文件

在安装第三模块时都有一个`package.json`文件来描述这个模块的入口文件，可是有的模块根据环境配置多个入口文件

`resolve.mainFileds`的默认值和当前的`target`配置有关系，对应的关系如下

- 当`tartget`为web或者webworker时，值是["brower", "module", "main"]

- 当`target`为其它情况时，值是[ "module", "main"]

以`target`等于web为例，webpack会先采用第三方模块中的`brower`字段去寻找模块，如果不存在，则从`module`中寻找，其次再从`main`中寻找。

为了减少搜索步骤，我们明确第三方模块的入口字段

```
module.exports = {
  resolve: {
    mainFields: ['main']
  }
}
```

## 优化resolve.alias配置

resolve.alias作用：

通过别名将原来导入第三方模块的路径修改为新的路径

有些第三方模块安装时，会有多套代码，比如React

有个`dist`目录，是将所有代码打包好的放在一个单独的文件中，这个文件没有被模块化，可以直接引入执行

另一个是`lib`目录，是一套采用CommonJs规范的模块化代码，以package.json中指定的入口文件react.js为模块的入口

默认情况下，webpack引入`lib`目录下的文件时，会递归解析和处理这些文件，这会是一个耗时的操作。这时可以通过`resolve.alias`来配置使用单独的完整的`dist`下的文件，减少搜索时间

```
module.exports = {
  resolve: {
    alias: {
      'react': path.resolve(__dirname, './node_modules/react/dist/react.min.js')
    }
  }
}
```

但是，使用这种优化虽然可以减少搜索，但是会引入模块中没用到的代码，这不利于`Tree-Sharking`使用，比如在使得lodash时，我们可能只用到部分功能，如果使用这个配置优化，将会把所有包括没用到的也引用项目当中

# 认识DllPlugin

对于比较常用又不常更新的模块可以使用 DllPlugin 插件将其进行打包，项目中直接引这些不库，不需要进行对这些模块做编译打包处理，
如`react`、`react-dom`，所以只要不升级这些模块的版本，动态链接库就不用重新编译。

要web中引用动态链接库的思想，需要完成以下事情

- 将网页依赖的基础模块抽离出来，打到一个个单独的动态链接库中。在一个动态链接库可以包含多个模块

- 将需要导入的模块存在于动态链接库时，不需要重新打包，而是从动态链接库直接导入

- 页面依赖的所有动态链接库都需要被加载

## webpack中使用dll

- DllPlugin插件：用于打包一个个单独的动态链接库文件。

- DllReferencePlugin插件：用于在主要的配置文件中引入DllPlugin插件打包好的动态链接库文件

以React项目为例，为其接入DllPlugin。最终构建出的目录结构：

|-- main.js
|-- polyfill.dll.js
|-- polyfill.mainfest.json
|-- react.dll.js
|-- react.mainifest.json

其中包含两个动态链接库文件

- polyfill.dll.js ：里面包含项目所有依赖的polyfill,例如Promise、fetch等Api

- react.dll.js：里面包含React的基础运行环境，即react和react-dom模块

以react.dll.js文件为例，其文件内容大致如下：

```
var _dll_react = (function (modules){
  // ......
})(
  function(module, exports, __webpack_require__){
    // ID为0的模块对应的代码
  }，
  function(module, exports, __webpack_require__){
    // ID为1的模块对应的代码
  }
  // .....
])
```

可见，一个动态链接库包含了大量模块的代码，这些模块被存放在一个数组里，用数组的索引号作为ID，并且通过__dll_react_ 变量将自己暴露在全局中，即可以通过window.__dll_react访问到其中包含的模块。

其中`polyfill.mainifest.json`和`react.mainfest.json`文件也是由DllPlugin生成的，用于描述在动态链接库文件中包含哪些模块

`main.js`文件是被编译出来的执行入口文件，在遇到其依赖的模块在`dll.js`文件中时，会直接通过`dll.js`文件暴露的全局变量获取打包在`dll.js`文件中的模块，所以在`index.html`文件中需要将依赖的两个dll.js文件加载进去。
此时`index.html`内容如下：

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<div id="app"></div>

</body>
<!--导入依赖的动态链接库-->
<sciprt src="./dist/polyfill.dll.js"></sciprt>
<sciprt src="./dist/react.dll.js"></sciprt>
<!--导入执行的入口文件-->
<sciprt src="./dist/main.js"></sciprt>
</html>

```

### webapck配置dll

上文构建输出的的文件

|-- polyfill.dll.js
|-- polyfill.mainfest.json
|-- react.dll.js
|-- react.mainifest.json

和|-- main.js

是由两不同的构建输出的

动态链接库文件相关的文件需要由一份独立的构建输出，用于主构建使用。新建一个Webpack配置文件`webpack_dll.config.js`专门构建他们。

```
  const path = require('path')
  const DllPlugin = require('webpack/lib/DllPlugin')
  modules.exports = {
    // JavaScript执行文件
    entry: {
      // 将React相关的模块放到一个单独的动态链接库中
      react:['react', 'react-dom'],
      // 将项目需要所有的polyfill放到一个单独的动态链接库中
      polyfill:['core-js/fn/object/assign', 'core-js/fn/promise', 'whatwg-fetch'],
    },
    output: {
      // 输出的动态链接库的文件名称，[name]代表当前动态链接库的名称
      filename: '[name].dll.js',
      // 将输出的文件都放到dist目录下
      path: path.resolve(__dirname, 'dist'),
      // 设置动态链接库全局变量名，对于react就是_dll_react
      // 加上前缀_dll是为了防止与其它全局变量冲突
      library: '_dill_[name]'
    },
    plugins:[
      // 接入DllPlugin
      new DllPlugin({
        // 动态链接库的全局变量名称，需要和output.library中的保持一致
        // 该字段的值也就是输出mainfest.json文件中name字段的值
        // 例如在react_mainfest.jon中就有"name"："_dii_react"
        name: '_dll_[name]',
        // 描述动态链接库的mainfest.json文件输出时的文件名称
        path: path.join(__dirname,'dist', '[name].mainfest.json')
      })
    ]
  }

```

## 使用动态链接库文件

构建出的动态链接库文件用于其他地方使用，在这里用在执行入口使用。

用于输出main.js的主Webpack配置文件的内容如下：

```
  const path = rquire('path')
  const DllReferencePlugin = require('webpack/lib/DllReferencePlugin.js')
  module.exports = {
    entry: {
      // 定义入口Chunk
      main: './main.js'
    },
    output:{
      // 输出文件的名称
      filename: '[name].js',
      path: path.resolve(__dirname, 'dist'),
    },
    module: {
      rules: [
        {
          // 项目源码使用了ES6和JSX语法，需要使用babel-loader转换
          test: /\.js$/,
          use: ['babel-loader'],
          exclude: path.resolve(__dirname, 'node_modules')
        }
      ]
    },
    plugins: [
      // 告诉 Webpack使用了哪些链接库
      new DllReferencePlugin({
        // 描述react动态链接库的文件内容
        mainfest: require('./dist/react.mainfest.json')
      }),
      // 告诉 Webpack使用了哪些链接库
      new DllReferencePlugin({
        // 描述polyfill动态链接库的文件内容
        mainfest: require('./dist/polyfill.mainfest.json')
      })
    ],
    devtool: 'source-map'
  }
```

注意：

在`webapck_dll.config.js`文件中，DllPlugin中的`name`参数必须和`output.library`中的保持一致。原因在于DllPlugin中的name参数会影响输出`mainfest.json`文件中的name字段的值。而在`webapck.config.js`文件中，DllReferencePlugin会去`mainfest.json`文件中读取name字段的值，将值的内容作为在全局变量中获取动态链接库的内容时的全局变量名

## 执行构建

执行构建需要注意的是，需要先将动态链接库相关的文件编译出来，因为主Webpack配置文件定义的DllReferencePlugin依赖这些文件。

执行构建的流程如下

- 如果动态链接还没编译出来，需要选将它们编译出来。执行命令行

`webapck --config webpack_dll.config.js`

- 在确保动态链接库存在时，才能正常编译入口的文件

# 使用HappyPack

Webpack构建过程就是对文件进行解析和转换，所以构建是谁的读写和计算密集型的。运行在Node.js之后的Webpack是单线程模型的，也就是说Webpack需要一个一个地处理任务，不能同时处理多个任务。

HappyPack的作用就是能让Webpack在同一时刻处理多个任务，发挥多核CPU电脑的功能，他将任务分到给多个子进程去并发执行，子进程处理完后再将结果发送给主进程。

由于JavaScript是单线程模型，所以要想发挥多核CPU的功能，就只能通过多进程实现，而无法通过多线程实现。

```
  const path = require('path')
  const ExtractTextPlugin = require('extract-text-webpack-plugin')
  const HappyPack = require('happypack')
  
  module.exports = {
    module: {
      rules: [
        {
          test: /\.js$/,
          // 将js文件的处理交给id为babel的happypack实例
          use: ['happypack/loader?id=babel'],
          // 排除node_modules下的目录，因为node_modeles目录下的文件采用了ES5语法，没必要再通过Babel去转换
          exclude: path.resolve(__dirname, 'node_modules'),
        },
        {
          test: /\.css/,
          // 将css文件的处理交给id为babel的happypack实例
          use: ExtranctTextPlugin.extract({
            use: ['happypack/loader?id=css']
          }),
        }
      ]
    },
    plugins: [
      new HappyPack({
        // 定义唯一标识符id
        id: 'babel',
        // 定义这个HappyPack使用哪个loader，用法和Loader配置一样
        loaders: ['babel-loader?cacheDirectory']
      }),
      new HappyPack({
        id: 'css',
        loaders: ['css-loader']
      }),
      new ExtractTextPlugin({
        filename: '[name].css'
      })
    ]
  }
```

以上配置做了以下几件事情：

-  在Loader配置，将文件的处理将给`happypack/loader`，使用时后面紧跟的`querystring?id=bable`表示使用哪个HappyPack实例

- 在Plugin配置中，添加了两个HappyPack实例，分别配置了不同的`loaders`，用于告诉`happypack/loader`如何处理`.js`和`.css`文件。id属性的值和上面querystring的`?id=bable`对应

在实例HappyPack时，除了可以传入id和loaders外还支持以下属性

- threads：代表开启几个子进程去处理这一类的文件，默认是3个，必须是整数

- verbose：是否允许HappyPack输出日志，默认开户

- threadPool：代表共享进程池，即多个HappyPay实例都使用同一个共享进程池的子进程去处理任务，以防止资源占用太多，相关代码如下

```
  const path = require('path')
  const ExtractTextPlugin = require('extract-text-webpack-plugin')
  const HappyPack = require('happypack')
  const happyThreadPool = HappyPack.ThreadPool({size: 5})

  module.exports = {
    module: {
      rules: [
        {
          test: /\.js$/,
          // 将js文件的处理交给id为babel的happypack实例
          use: ['happypack/loader?id=babel'],
          // 排除node_modules下的目录，因为node_modeles目录下的文件采用了ES5语法，没必要再通过Babel去转换
          exclude: path.resolve(__dirname, 'node_modules'),
        },
        {
          test: /\.css/,
          // 将css文件的处理交给id为babel的happypack实例
          use: ExtranctTextPlugin.extract({
            use: ['happypack/loader?id=css']
          }),
        }
      ]
    },
    plugins: [
      new HappyPack({
        // 定义唯一标识符id
        id: 'babel',
        // 定义这个HappyPack使用哪个loader，用法和Loader配置一样
        loaders: ['babel-loader?cacheDirectory'],
        // 使用共享进程池中的子进程去处理任务
        threadPool: happyThreadPool
      }),
      new HappyPack({
        id: 'css',
        loaders: ['css-loader'],
        // 使用共享进程池中的子进程去处理任务
        threadPool: happyThreadPool
      }),
      new ExtractTextPlugin({
        filename: '[name].css'
      })
    ]
  }
```

接入HappyPack后，需要为项目安装新的依赖：

`npm i -D HappyPack`

安装成功后重新执行构建，如果有看到由HappyPack输出的日志说明HappyPack配置生效了

## HappyPack原理

每通过`new HappyPack`实例化一个HappyPack，并定义该实例使用哪些Loader去转换一类文件，并且可以指定如何为这类转换操作分配进程。

核心调度器的逻辑代码在主进程中，也就是运行Webpack的进程中，核心调度器会将一个个任务分配给当前空闲的子进程中，子进程处理完后将结果发送给核心调度器，它们之间的数据交换是通过进程间的通信API完成的。

核心调度器收到来自子进程处理完毕的结果后，会通知Webpack该文件已处理完毕。

# thread-loader

作用同HappyPack，也是将您的 loader 放置在一个 worker 池里面运行，以达到多线程构建。
把这个 loader 放置在其他 loader 之前， 放置在这个 loader 之后的 loader 就会在一个单独的 worker 池(worker pool)中运行

```
// webpack.config.js
module.exports = {
  module: {
    rules: [
      {
        test: /\.js$/,
        include: path.resolve("src"),
        use: [
          "thread-loader",
          // 你的高开销的loader放置在此 (e.g babel-loader)
        ]
      }
    ]
  }

```

# terser-webpack-plugin开启多进程压缩

```
new UglifyJSPlugin({
    cache: true, // 开启缓存
    parallel: true, // 开启进程并行压缩
    include: /\/includes/, // 缩小压缩文件范围
    exclude: /\/excludes/, // 缩小压缩文件范围
}),
```

也可以使用`webpack-paralle-uglify-plugin`插件

# 充分利用缓存提升二次构建速度

- babel-loader 开启缓存

  ```
    {
        test: /\.js$/,
        use: [
            {
                loader: 'babel-loader',
                options: {
                    cacheDirectory: true
                }
            }
        ]
    }
  ```

- terser-webpack-plugin 开启缓存

- 使用 cache-loader 或者 hard-source-webpack-plugin
