# 事件循环

事件循环就是一个程序启动期间运行的死循环

事件循环对于开发者来说是不可见的。当用户单击页面上的按钮或者进行其他操作时，就会产生相应的事件，这些事件地被加入到一个队列中，然后主循环会逐个处理它们

而 JavaScript 是单线程的，为了避免一个过于耗时的操作阻塞了其他操作的执行，就要通过异步加回调的的方式解决问题

以 Ajax 请求为例，当 JavaScript 执行到对应的代码时，无需等请求的完成可以继续执行后面的语句，当发出请求执行完毕了，后续的操作会交给回调函数来处理

此时，浏览器背后的循环正在不断遍历事件队列，在 Ajax 操作完成之前，事件队列里还是空的（并不是发出请求这一动作被加入事件队列，而是请求完成这一事件才会加入队列）

如果Ajax操作完成了，这个队列中就会增加一个事件，随后被循环遍历到，如果这个事件绑定了一个回调方法，那么循环就会去调用这个方法

## Node中的事件循环

Node中的事件循环比起浏览器中的 JavaScript 不同的地方

- JS 的事件循环是依靠浏览器实现的

- 而 Node 作为另一种运行时，事件循环由底层的 libuv 实现

Node 中事件循环的具体流程：

```
   ┌───────────────────────────┐
┌─>│           timers          │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │<─────┤  connections, │
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │
   └───────────────────────────┘
```

上面的图例中，将事件循环分为了 6 个不同的阶段

- `Timers`: 用来处理 `setTimeout()` 和 `setInterval()` 的回调

- `pending I/O callbacks`: 虽然大部分 I/O 回调都是在 `poll` 阶段执行，但是会存在一些被延迟调用的 I/O 回调函数。执行推迟到下一个循环迭代的 I/O 回调

- `idel, prepare`: 仅仅在内部使用，不管它

- `Poll`:  取出新完成的 I/O 事件，事件循环可能会在这里阻塞

- `Check`：处理 `setImmediate()` 事件的回调

- `Close callbacks`: 执行所有注册 `close` 事件回调函数，例如 `cocket.on('close')`

## 各阶段详细解释

### Timer Phase

任何过期的计时器回调都会在事件循环的这个阶段中运行

定时器的回调会在触发后尽可能早地被调用，这表示实际的延时可能会比定时器规定的时间要长

如果事件循环，此时正在执行一个比较耗时的 `callback`，例如处理一个比较耗时的循环，那么定时器的回调只能等待当前回调执行结束了才能被执行，即被阻塞。事实上，`timer` 阶段的执行受到 `poll` 阶段控制

例如，假设您调度了一个在 `100 毫秒` 后超时的定时器，然后您的脚本开始异步读取会耗费 `95 毫秒`的文件:

```js
const fs = require('fs');

function someAsyncOperation(callback) {
  // Assume this takes 95ms to complete
  fs.readFile('/path/to/file', callback);
}

const timeoutScheduled = Date.now();

setTimeout(() => {
  const delay = Date.now() - timeoutScheduled;

  console.log(`${delay}ms have passed since I was scheduled`);
}, 100);

// do someAsyncOperation which takes 95 ms to complete
someAsyncOperation(() => {
  const startCallback = Date.now();

  // do something that will take 10ms...
  while (Date.now() - startCallback < 10) {
    // do nothing
  }
});

```

执行过程：

- 当事件循环进入 `poll` 阶段时，它有一个空队列（此时 `fs.readFile()` 尚未完成），因此它将等待直到达到最快的计时器 `timer` 阈值为止

- 当它等待 `95 毫秒` 过后时，`fs.readFile()` 完成读取文件，它的那个需要 `10 毫秒` 才能完成的回调将被添加到 `poll` 队列中并执行

- 当循环结束时，`poll` 队列中不再有回调，因此事件循环机制将查看最快到达阈值的计时器，然后将回到 `Timer` 阶段，执行定时器的回调

但是需要注意的是调度计时器到它的回调被执行之间的总延迟将为 `105` 毫秒

### pending callbacks阶段

根据网上资料 `pending callbacks` 阶段执行回调大致有两种情形：

1. 执行先前事件循环 `tick` 中延迟执行的 I/O 回调函数

2. 此阶段执行某些系统操作的回调，例如 TCP 错误。 举个例子，如果 TCP 套接字在尝试连接时收到 `ECONNREFUSED`，则某些 `* nix` 系统希望等待报告错误。 这将会在 `pending callbacks` 阶段排队执行

### poll阶段

执行新完成的 I/O 事件回调，事件循环可能会在这里阻塞

当事件循环进入 `poll` 阶段可能发生的情况有以下几种：

- 如果轮询队列 (poll queue) 不为空，则事件循环将遍历其回调队列，使其同步执行，直到队列用尽或达到与系统相关的硬限制为止 

- 若不存在任何计时器，那么当前事件循环 `tick` 中的 `poll` 阶段将无限制阻塞。以实现一旦存在 I/O 回调函数加入到 `poll queue` 中即可立即得到执行

- 若存在已经完成的计时器，则结束当前事件循环 `tick`。这样就可以马上进入下一次事件循环然后在 `timer` 阶段执行完成的计时器回调

- 如果发现有通过 `setImmediate` 设置的回调，则会结束当前 `poll` 阶段，并继续执行 `check` 阶段以执行 `setImmediate` 设置的回调


一旦轮询队列 (poll queue) 为空，事件循环将检查哪些计时器 timer 已经到时间。 如果一个或多个计时器 timer 准备就绪，则事件循环将返回到计时器阶段，以执行这些计时器的回调

### check 阶段

> 此阶段允许在轮询 poll 阶段完成后立即执行回调。 如果轮询 poll 阶段处于空闲，并且脚本已使用 setImmediate 进入 check 队列，则事件循环可能会进入 check 阶段，而不是在 poll 阶段等待

`setImmediate` 实际上是一个特殊的计时器，它在事件循环的单独阶段运行。 它使用 libuv API，该 API 计划在轮询阶段完成后执行回调

通常，在执行代码时，事件循环最终将到达轮询 poll 阶段，在该阶段它将等待传入的连接，请求等。但是，如果已使用 setImmediate 设置回调并且轮询阶段变为空闲，则它将将结束并进入 check 阶段，而不是等待轮询事件

### close 阶段

如果一个`socket`或者一个句柄突然被关闭，则在此阶段将发出 `close` 事件, 该事件会被加入到对应的队列中。close 阶段执行完毕后，本轮事件循环结束，循环进入到下一轮。

**Nodejs 为了防止某个 Phase 任务太多, 导致后续的 Phase 发生饥饿的现象, 所以消息循环的每一个迭代(iterate) 中, 每个 Phase 执行回调都有个最大数量. 如果超过数量的话也会强行结束当前 Phase 而进入下一个 Phase. 这一条规则适用于消息循环中的每一个 Phase**

## Q&A

- 如果你的计算机只有一单核的CPU（暂先不考虑超线程程技术，即在一个CPU上同时执行两个线程），还能做到并行吗？

  就算把代码写出花来，也不能获得真正的并行

- 是事件特环提供了并行的能力吗？

  事件特环也是运行在单线程环境中，这表示一个时刻只能处理一个事件，没法提供并行支持

- 如果存在并行，那么应该位于Node的哪个层面？

  并行存在于 libuv 的线程池中，实现的并行为线程级别的并行（需要多核CPU）
  
## process.next

`process.next` 的意思就是定义出一个异步动作，并且这个动作在事件循环当前阶段结束后执行

例如下面代码，将打印 `first`的操作放在`nextTick`的回调中执行

```
process.nextTick(function(){
    console.log('first')
})
console.log('next')
// next
// first
```

`process.nextTick`其实不是事件循环的一部分，但是它的回调也是由事件循环调用的，该方法的回调会放在`nextTictQueue`中，在事件循环的
除非，如果`nextTict`不为空，都会在当前阶段操作结束后优化执行`nextTickQueue`中的回调函数，当`nextTickQueue`中的回调方法被执行完毕后，事件
循环才会继续向下执行

Node限制了 `nextTickQueue`的大小，如果递归调用了`process.nextTick`，那么当`nextTickQueue`达到最大限制后会抛出一个错误

```
// todo
function recerse(i){
    while(i <9999)
    {
      process.nextTick(recerse(i++)) // 后置运算符，参数永远传的 0
    }
}
recerse(0)
```

运行代码，马上就会出现

```
RangeError:Maxium call stack size exceeded
```

`nextTickQueue`也是一个队列，那么先被加入队列的回调会被先执行，我们可以定义多个`process.nextTick`

```
process.nextTick(function(){
    console.log('first')
})
process.nextTick(function(){
    console.log('second')
})
console.log('next')
```

**因为`process.nextTick`的回调也是由事件循环执行的，所以如果回调函数出现了阻塞操作，事件循环后面的阶段也会被阻塞**


## setImmediate

`setImmediate`的事件会在当前事件循环中的 check phase 被执行

**setImmediate和nextTick**

`nextTick`的回调是在事件循环任何阶段结束后就会被执行，而`setImmediate`是在事件循环的末尾 check phase 阶段执行，所以总是先执行
`nextTick`后执行`setImediate

当有递归的异步操作时只能使用`setImmediate`，不能使用`process.Tick`，

前面展示过了调用`nextTick`会出现错误，下是使用`setImmediate`来试试看：

```
function recurse(i, end) {
    if(i >end) {
      console.log('Done')
    } else {
      console.log(i)
      setImmediate(recurse, i+1, end)
    }
}
recurse(0, 99999999)
```

## 为什么还用 process.nextTick

这里举出两个原因：

- 在事件循环继续之前下个阶段允许开发者处理错误，清理所有不必要的资源，或者重新尝试请求。

= 有时需要让回调在事件循环继续下个阶段之前运行

简单的例子：

```
const server = net.createServer();
server.on('connection', (conn) => { });

server.listen(8080);
server.on('listening', () => { }); // 设置监听回调
```

假设 `listen` 在事件循环的开始处运行，但是侦听回调被放置在 `setImmediate` 中 (实际上 `listen` 使用 `process.nextTick`,`.on` 在本阶段完成)。
 除非传递主机名，否则将立即绑定到端口。 为了使事件循环继续进行，它必须进入轮询 `poll` 阶段，这意味着存在已经接收到连接可能性，
 从而导致在侦听事件之前触发连接事件 (漏掉一些 poll 事件)

另一个示例正在运行一个要从 `EventEmitter` 继承的函数构造函数，它想在构造函数中调用一个事件：

```
const EventEmitter = require('events');
const util = require('util');

function MyEmitter() {
  EventEmitter.call(this);
  this.emit('event');
}
util.inherits(MyEmitter, EventEmitter);

const myEmitter = new MyEmitter();
myEmitter.on('event', () => {
  console.log('an event occurred!');
});
```
你无法立即从构造函数中发出事件，因为脚本还没运行到开发者为该事件分配回调的那里 (指 `myEmitter.on`)。 
因此，在构造函数本身内，你可以使用 `process.nextTick` 设置构造函数完成后发出事件的回调，从而提供预期的结果：

```
const EventEmitter = require('events');
const util = require('util');

function MyEmitter() {
  EventEmitter.call(this);

  // use nextTick to emit the event once a handler is assigned
  process.nextTick(() => {
    this.emit('event');
  });
}
util.inherits(MyEmitter, EventEmitter);

const myEmitter = new MyEmitter();
myEmitter.on('event', () => {
  console.log('an event occurred!');
});
```

process.nextTick 在事件循环的位置:

```
     ┌───────────────────────────┐
        ┌─>│           timers          │
        │  └─────────────┬─────────────┘
        │           nextTickQueue
        │  ┌─────────────┴─────────────┐
        │  │     pending callbacks     │
        │  └─────────────┬─────────────┘
        │           nextTickQueue
        │  ┌─────────────┴─────────────┐
        |  |     idle, prepare         │
        |  └─────────────┬─────────────┘
  nextTickQueue     nextTickQueue
        |  ┌─────────────┴─────────────┐
        |  │           poll            │
        │  └─────────────┬─────────────┘
        │           nextTickQueue
        │  ┌─────────────┴─────────────┐
        │  │           check           │
        │  └─────────────┬─────────────┘
        │           nextTickQueue
        │  ┌─────────────┴─────────────┐
        └──┤       close callbacks     │
           └───────────────────────────┘
```

## setTimeout和setImmediate

- setTimeout: 在 Timers 阶段如果时间**已超过**设置的定时时间则执行

- setImmediate： 在当前事件循环的 check 阶段被执行

那么如果两个都存在的情况下，哪个更快呢？

```
setImmediate(() => console.log(2))
setTimeout(() => console.log(1))
```

答案是顺序不固定，可能是 `1 2`, 也可能是 `2 1`

当执行到 Timer Phase 时, 会发生两种可能. 因为每一轮迭代刚刚进入 Timer Phase 时会取系统时间保存起来, 以 ms(毫秒) 为最小单位

- 如果 Timer Phase 中回调预设的时间 > 消息循环所保存的时间, 则执行 Timer Phase 中的该回调. 这种情况下先输出 `1`, 
  直到 Check Phase 执行后, 输出 `2`. 总的来说, 结果是 `1 2`
  
- 如果运行比较快, Timer Phase 中回调预设的时间可能刚好等于消息循环所保存的时间, 这种情况下, Timer Phase 中的回调得不到执行, 
  则继续下一个 Phase. 直到 Check Phase, 输出 `2`. 然后等下一轮迭代的 Timer Phase, 
  这时的时间一定是满足 "Timer Phase 中回调预设的时间 > 消息循环所保存的时间" 的, 所以 `console.log(1)` 得到执行, 输出 `1`. 
  结果就是 `2 1`.
  
所以, 输出不稳定的原因就取决于进入 Timer Phase 的时间是否和执行 setTimeout 的时间在 1ms 内. 如果把代码改成如下, 则一定会得到稳定的输出:

```
require('fs').readFile('my-file-path.txt', () => {
 setImmediate(() => console.log(2))
 setTimeout(() => console.log(1))
});
输出: 2 1
```

这是因为消息循环在 Pneding I/O Phase 才向 Timer 和 Check 队列插入回调. 这时按照消息循环的执行顺序, Check 一定在 Timer 之前执行

## Microtasks 微任务

> 微任务会在主线之后和事件循环的每个阶段之后立即执行

在 Node 领域，微任务是来自以下对象的回调：

- `process.nextTick()`

- `then()` handlers for resolved or rejected Promises

`resolved` 的 `promise.then` 回调像微处理一样执行，就像 `process.nextTick` 一样。 虽然，如果两者都在同一个微任务队列中，则将首先执行 `process.nextTick` 的回调

优先级 `process.nextTick` > `promise.then` = `queueMicrotask`

> [Node.js 事件循环-比官方更全面](https://learnku.com/articles/38802)

> [](https://set.sh/post/200317-how-nodejs-event-loop-works)

> [](https://learnku.com/articles/38802)