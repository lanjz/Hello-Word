# 构建优化分享

## 开场

各位同事们 好，我是来成本结算组的前端--兰江州，这次给大家分享的内容是 《 Webpack 构建速度优化 》  
之所以分享这个主题是因为这段时间计划对项目做些优化工作，优化过程首先是从构建这块开始。因此总结了一些 Webpack 构建方面的一些优化手段，同时也希望在分享结束之后，看下各位是否还有其它没讲到的优化方式可以一起探讨下

那我们就开始吧！

## 目录

首先整体的分享内容，分为四个版本  

第一个版本会先介绍一下 "模块化的发展历程"， 因为 Webpack 工具的出现离不模块化的发展这个话题，主要是让大家了解 webpack 到底解决前端什么问题

第二个版本会概括一下 Webpack 工作过程，了解一下工作过程可以让我们知道构建速度的性能瓶颈在哪里，更好的理解我们优化手段是针对哪个构建环节

第三个版本就是这次分享核心内容，优化手段

第四个版本会简单介绍一下现在除了 Webpack 以外的 另一打包工具 vite，主要是简单介绍一下两才的区别

## 模块化的发展历程

模块化的目的是为了更方便更高效得管理我们的代码资源

前端的模块化发展大致可以分为这6阶段，最后一段也就是现在的 ES6 Module

### 文件划分的形式

首先最开始前端模块的管理仅仅是以文件划分的形式，（呈现粟子） 如例子所示 将每个功能及其相关的状态数据各自单独放在不同的 JS 文件中，约定每个文件是一个独立的模块  
然后通过 script 标签将这个模块引入到页面中，直接调用模块中的变量或方法  

之所以引入文件后能直接使用模块内的内容，这是因为模块内的变量或方法都是定义在全局环境中

#### 缺点

这种方面存在很多问题：

- 模块直接定义在全局环境中，污染全局作用域

- 没有私有空间，所有模块的成员都可以在外部被访问或者修改

- 一旦模块增加多，容易产生命名冲突

// - 无法管理模块与模块之间的依赖关系

- 如果成员的命名不严谨的话 也很分辨正在使用的变量或方法属于哪个模块

### 命名空间方式

之后就是命名空间的方式  在文件划分的基础上，（呈现粟子） 约定每个模块文件只暴露一个全局对象，所有相关的变量和方法都挂载在这个对象中  

例子中的 show 方法是定义在 moduleA 这个对象上，外部只能通过这个 moduleA 对象来访问模块的成员

相比于文件划分的形式，这种方式让不同模块的成员划分稍微变得清晰了一点，可以快速得知晓当前所用到成员是属性于个模块  

但是本质上之前所存在的问题存然没有解决，像 污染环境/ 没有私有空间/ 命名冲突/ 依赖关系等

### IIFE

之后就有了使用立即执行函数表达式来管理模块，（呈现粟子） 这种方式其实是利用闭包将模块的成员的作用范围控制在函数作用域中，只暴露部分的对象到全局环境中，这样就提供了私有空间的能力   例子中的 name 属性是不能直接在外部被访问的，只能通过暴露出去的 showName 方法进行访问，所以相比之前方式就达到了私有空间一个目的

可以看到刚说的这三个方式的模块管理仍是只能通过前端的一些使用特性来尽量达到模块管理目的

### CommonJS 

直到后来伴随着 NodeJS 的诞生开始出现模块化规范 commonJS，（呈现粟子） 该规范约定，一个文件就是一个模块，每个模块都有单独的作用域，通过 module.exports 导出成员，再通过 require 函数引入模块 
 
但是commonJS 只适用于 NodeJS

其次 CommonJS 约定加载模块是以同步的方式来引入，因为在 Node 端的引入的都是本地的模块。而在浏览器模块的引入必然存在需要通过网络请求来异步获取服务器的模块资源，如果以同步方式会产生阻塞  影响运行效率 

### AMD

CommonJS 只适用于 NODE，根据浏览器端使用特性，出现了异步模块定义规范（AMD），同期出现了一个非常出名的库 -- Request.js

（呈现粟子）

ADM 的基本思想是，通过define方法，将代码定义为模块；通过require方法，实现模块加载

其实大家如果有去看过 node_module 的里面的第三方库，可以发现大部分的库都实现这个规范

RequireJS 的优点是适合在浏览器环境中异步加载模块。可以并行加载多个模块。
缺点是不能按需加载，而是必须提前加载所有的依赖，仍不够完美，而且 AMD 是社区规范，并还是 ES 标准规范

### ES6 Module

最后就是我们现在使用的 ES6 Module，ES6 Module 在ECMAScript 2015 标准规范中添加的模块系统，真正在语言标准的层面上，实现了模块化功能
如粟子所示，ES6 Module 使用也比较简单，通过 export 导出模块，在需要使用的地方通过 import 语法进行引入

至此虽然正统的规范出现了，但是对于开发者而言在使用这个新的规范的时候仍然面临着一些问题

1. ES6 M 是近几年才制定的标准，也就意味着只有新版本的浏览器才能不断得进行支持，也就是前端总是要面对的兼容问题

2. 随着应用日益复杂，在前端应用开发过程不仅仅只有 JS 代码需要模块化，HTML/css等这些资源文件也面临需要模块化的问题

为了让开发者在开发阶段能享受模块化带来的优势，又不必担心使用新的模块化标准对生产环境会产生兼容问题。于是就开始出现 Webpack 等打包工具

所以 Webpack 最初的目标就是实现前端项目的模块化，它是一个用于现代JavaScript应用程序的静态模块打包工具

它让我们在开发的时候可以放心得使用新的标准语法如模块化语法，至于浏览器的兼容由 Webpack 为我们解决

那么 Webpack 是如果做到让浏览器兼容的呢？ 语法降级与替换 （翻到下一页）55

### Webpack 解决了什么问题

原理这部分不是这次分享的重点，所以这里就直接拿了之前研究 Webpack 动态加载模块的Demo 例子来给大家简单过一下  
如例子所示，左侧的 import 语法经 Webpack 打包后变成右侧的样子  

Webpack 模块化原理其实就是

自己实现了一个 webpack_require 方法来模拟 import 语法的实现

模块的加载和引入，会通过动态创建 script 标签的方式来引入，当然这些都依赖于 webpack 对模块内容的打包处理，这里暂时不进行深入解读了

（下一页）

讲到这里希望能帮忙到大家去理解 Webpack 这个工具

但实际使用中通过 Webpack 还可以做到 代码向下兼容， 代码分割，压缩，语法检查，热更新等等

所以如今的 Webpack 虽说最初是以实现模块化为目的， 但更像一套前端工程化的解决方案

## Webpack 工作原理

上面这个是官网的图片，从图片上看左侧是各种各样的文件，经 Webpack 打包后输出成另外一些文件，但是对于 Webpack 而言一切皆是模块，也就是下面这张图，所以从另个角度来说，左侧的一切都称为模块再经 Webpack 打包后输出 bundle  bundle 可以理解为左边模块打包后组成结果

Webpack 工作过程大致如下：

【初始化参数】：从配置文件和 Shell 语句中读取与合并参数，得出最终的执行参数

【开始编译】：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，开始执行编译

【确定入口】：根据配置中的 entry 找出所有的入口文件

【编译模块】：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理

编译模块就是核心的工作部分

【完成模块编译】：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系

【输出资源】：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会

一会又是Chunk 一会儿是 bundle的，大家可以直接这么理解，首现 Webpack 打后的模块并不是一比一的输出关系，他在模块编译的时候会分析模块的依赖关系，然后把多个模块打包在一起，这个时候打包在一起的就是 chunk ，最后还有多个chunk 捆绑在一起形成最终的文件也就是 bundle

说白了就是个命名，本质就是由多个模块组成的模块集合


【输出完成】：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。

从上面过程来盾，Webpack 最核心的工作无疑就是 "编译模块" 这一环节，这也是 Webpack 最耗时的部分。所以无论是这次分享所总结的优化手段还是网上搜集的优化方案基本都是针对这一环节的

接下来就是讲一下具体的构建速度方面的优化措施 

## 检测

做优化的话，难免需要配合一些检测工具来使用，这次我主要是使用这两个插件

第一个是 speed-measure-webpack-plugin 我们简称为 smp，它可以输出每个 loader和plugin 的执行时间

第二个工具是 webpack-bundle-analyzer 可以输出最终文件的打包体积，因为前面说到我们依赖的模块会被打包在一起，通过这个插件就可以知道最终的输出文件里面包含了哪些模块，如果要做体积优化就可以针对性去做优化和拆解

## 减少编译范围

webpack 工作的本质就是一个不断检索文件 转换文件的过程，所以首先我们优化手段从减少编译范围开始，也就是 越少就越快 原则

相关的优化措施 具体有：缩小的 loader 的应用范围

配置 loader 时合理得使用  test exclude include 属性，尽可能少的文件被 loader 处理，  尤其是第三方模块的
我突然觉得这里用 尽可能少的文件 这个词用可能不够恰当， 应该是 loader 只用在需要用到的地方

如例子中的  babel-loader， 大家都知道 babel-loader 是用于翻译 es6 等js语法，但是现在第三方模块基本都是翻译后的js 语法，所以我们就不需要重复再对他们进行处理

所以就可以使用 include 属性，把 loader 的工作范围只控制在 我们业务代码 src 目录下

下面这第三图是 vue-cli 的一些配置属性说明，从说明中可以看到 vue-cli 默认情况也是忽略 node_module中的文件

### resolve.module

resolve.module 这个属性是告诉webpack 如果寻找第三个模块

webpack 默认会从根目录的 node_modules 下寻找三方模块，如果当前 node_modules 没有找到对应的模块，就会再从上一级目录的 node_modules 中找,以此类推

但在实际的开发使用场景中，我们的第三方模块基本都是 根目录的 node_modules ，继续向上查找是没有意义的，因此我们可以指定第三方模块的眼泪，减少 webpack 的查找

### extensions

如图所示，代码引入了 getters 这个模块，但这个模块并没有带上文件的后缀，即使这样 webpack 仍能找到对应的文件，这是因为默认情况下 webpack 会自动带上后缀去寻找这个文件，自动带个什么后缀去查找呢？就是通过 extensions 来控制的

因此我们可以对这个做的优化有：

### noParse

noParse 是告诉 webpack 不需要去解析依赖的模块

前面在讲webpack 工作过程的时候，有提到在编译模块这个步骤中，webpack 一方面是使用 loader 对模块进行翻译另一方面还要分析这个模块的依赖关系，而这个noparse 就是让 webpack 忽略这个模块的依赖解析，从而达到减少工作的目的 比如果 jquery 之类的

说到 jquery 我发现部门的项目都有把 jquery 打包进去，个人的建议是不需要去用这个了，因为现在现在大家都在使用 vue 开发了，如果确实要操作 dom 应该通过 ref 来操作，而且操作的 dom 的使用场景应该是非常小的，同时也可以减少 jquery 这部分代码体积

## 缓存

刚讲的这些都是从减少编译范围的角度去优化构建速度，接下就是通过缓存的手段来提高构建速度，大家有没有发现无论在做哪个方面的优化，缓存都会是主角之一

在 webpack 中跟缓存相关的常用的优化方式有 

### dll

dllPlugin 就是事先把常用又基本不会更改的模块先打包好，然后 webpack直接使用这些打包好的内容，以此达到缩短构建时间的目的

dllPlugin 配置需要先生成 dll 文件，然后在打包配置中再使用这个刚打包的 dll 文件，也就是生成和使用是分开的两套 webpack 配置，

dll 的使用 我觉得是 webpack 配置使用最麻烦的配置之一，因为平时我们大多是使用 脚手架来开始项目，本身就是省去这块的维护成本。再加上 webpack 4之后，简单有效的优化手段也变多了，所以这里就只是简单介绍一下这个 dllPlugin 

### cache-loader

下一个缓存手段是 cache-loader ，cache-loader 的使用比较简单，就是把 cache-loader 放在你需要缓存的 loader 配置之前就可以

它的原理分为两个阶段

### hard-source

这个插件使用的时候有利也有弊，首先在配置这个插件之前，使用 smp 对项目的打包速度进行输出 结果是 1分8秒，这个70秒是 loader和plugin的执行时间

添加了这个插件之后，速度缩短到了 12秒，可以发现执行时间缩短了 80%，效果非常明显

下面这个是整个 webpack 的打包时间，可以看到二次打包时间之后，这个插件可以整体的打包时间可以缩短一半的构建时间

但是官网对这个插件也有说明这个插件存在一些坑，所以为了保险起见，建议在开发环境进行使用，如上图的配置，另外这个插件还有一个问题就是会导致热更新变慢，所以大家可以根据自己的情况来使用这个插件

## 多进程

接下来要讲的优化手段是开启多进程进行 webpack 打包工作  
webpack 打包时对文件进行解析和转换的工作过程属性密集型计算操作，单线程的 node 处理这类任务是不具备优势，但可以通过启用多进程的方式来达到同理处理多个任务的目的，从而提升构建速度  
开启多进程的方式常用的方式有 happyPack 插件和 thread-loader

### happyPack

首先要讲的是 happyPack, happyPack 是一个插件，使用时需要先在 plugin 配置中添加一个 happyPack 实例，生成实例时通过 loader 属性来告诉这个实例使用什么 loader 进行工作，通过 id 属性给这个实例添加一个唯一标识  
之后在rule 配置时，以图片中的 js文件为例，使用happyPack 来代替原本的 label-loader，这个happyPack 后面的id 与前面插件中定义的 id 相对应

这样在编译js文件就可以 以多进程的方式进行工作

### thread-loader

另一种开启多进程的方式就是 thread-loader ,这个 loader 的使用也很简单，跟 cache-loader 一样，只需要把 thread-loader 放置在其它loader 之前即可，如图例所示

右侧这个图片是 vue 脚手架的属性配置说明，也表明 脚手架也有使用这个 thread-loader 为 js 文件开启多进程的方式进行转换工作

### terser 压缩

代码的压缩也是可以开启多进程工作的，如图片所示，vue 的脚手架也开启了

### 更高效的工具替换

接下来要讲的优化方式就是使用其它更高效的工具进行转换工作，这张图是网上截取的，这张图中所示的打包工具我也没有一个一个玩过，主要是想展示他们的对比数据，其中最突出的就是 esbuild ，esbuild 之所以这么快是因为他是个 go 编写的，利用越底层的语言运行越快且能并行执行任务的优势

esbuild 是支持 js 打包和代码压缩的，所以可以用于代替 babel-loader 进行js 打包和代码压缩工作

### esbuild-loader

左侧这个图片是在 vue-config 使用 esbuild-loader 的配置例子

中间这个是在使用esbuild-loader 之前 smp 输出的 babel-loader 的执行时间，大约在70s左右

在使用esbuild 替换之后，执行时间为7s 左右

下面这个表格是分别多次打包后的平均执行时间，可以看到首次执行时间缩短了接近 90%，即使二次打包后即使有了缓存， 使用 esbuild 也能缩短70% 的时间

所以使用 esbuild-loader 的效果还是挺显著，但要注意的 esbuild-loader 对 js 编译只能到 es6

(esbuild 没有提供 AST 的操作能力。所以一些通过 AST 处理代码的 babel-plugin 没有很好的方法过渡到 esbuild 中)

接下是使用 esbuild 代替 terser 做代码压缩工作，表格里的时间是记录 webpack整体的打包时间， 对比可以发现 esbuild 首次打包时速度少了一半左右，二次打包之后因为存在缓存的关系，所以打包时间才显得差不多

但是要注意的使用 esbuild 压缩后的代码比 terser 大

整体来说 esbuild 虽然功能不如 babel-loader 那么全面，但是在执行速度上确实会提升很多，所以总结下 esbuild 合适的使用场景

- 没有使用一些自定义的 babel-plugin (如 babel-plugin-import)  (加载babel, antd, lodash等模块, 自动导入对应样式和JS文件)
  
- 不需要兼容一些低版本浏览器（esbuild 只能将代码转成 es6）

## 减少工作

前面讲的都如果提高webpack 工作效率，现在要讲的时候如果减少 webpack 的工作，毕竟做的越少执行越快

### CDN

说实话 cdn 引入这种有点违背使用模块化这个理念，因为这就回到最开始直接使用 `<script>` 标签引入模块的那种方式，所以平时不建议使用。但是这里有一个项目情况比较特殊，所以这里当作例子来讲一下

这个项目打包后文件体积的概览，可以看到没压缩前，总体积有19M，其中打包出来的两个 chunk 文件大约占了 15M，然后从右侧的区域可以发现这两个chunk是同一个模块  spreadjs 组成的，总的19M 这个库占了15M 说实话很夸张。。并且这个模块还有一个使用特点就是使用频率非常高，几乎在每个页面都有用到。这种情况我就觉得可以直接使用 cdn 引入的方式，省去这部分的打包工作。  省掉之后 的打包大约可以减少 30s - 40s 这样的一个时间

### 升级

现在部门的项目基本是 webpack4 ，现在最近的版本是 webpack5，通常大版本的更新都会包含性能方面的优化

比如这次 webpack5 跟性能方面相关的更新主要有：

1。 ，，，，

所以有兴趣的同学可以试着升级玩一下

## vite

到这里跟 webpack 相关的都讲完了，最后一块想跟他们稍微提下 vite，因为使用 vue 的同学们应该对 vite 不陌生，前面有对 webpack 的工作过程有了大概的解读，现在其实想趁热打铁稍微讲一下 vite 和 webpack 的区别，让同学们更好和理解为什么 vite 的启动速度会比 webpack 快那么多

可以先看这张图，这个 vite 的工作流程，他跟 webpack 的区别在于：

webpack 先打包，打包完才启动开发服务器，之后前端访问静态资源时都是直接给出打包后的结果

而vite 是直接启动开发服务器，需要哪个模块再请求哪个模块

并且JS 直接利用原生浏览器支持 es module 的特性进行模块加载，省去编译过程

这也是vite 比 webpack 快的主要原因

但 vite 确实是快，但是使用 vite 的同时，我们也有几点地方需要注意一下：

- vite 开发环境和生产环境的执行是两套规则， vite 所表现的 快 仅是针对开发环境下，  实际在生产环境下仍然需要打包，这就意味着我们要开发和生产构建结果可能会有不一致的风险

- 开发阶段中，Vite 的开发服务器将所有代码视为原生 ES 模块。因此，Vite 必须先将作为 CommonJS 或 AMD 发布的依赖项转换为 ESM，这个过程也存在适配风险

## 总结

最后来一个实用一点的小总结，结合部门前端项目的构建情况，基本都是基于 vue-cli 的脚手架开发的，vue-cli内部其实已经做了很多的优化措施了

而且使用 vue-cli 另一方面也是图个方便，省去打包配置这方面的打包成本。所以我这里抽出一些基于 vue-cli 平时简单又有效的优化手段：

1. 如果存在自己定义的 loader 配置，且耗时较长，那么在该 loader 前配置 cache-loader

2. 如果启动项目项目的时候太长，不法容忍。可以添加 hard-source-webpack-plugin

3. 如果第三方的体积很大，且该模块的使用频率非常高，可以考虑直接使用 cdn 引入

4. 如果代码只考虑编译es5，想让编译速度进一步提升，可使用 esbuild-loader 代码 label-loader

