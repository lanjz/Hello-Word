# 响应式原理分享

各位同事们 好，我是来成本结算组的前端--兰江州，这次给大家分享的内容是 《Vue 响应式系统原理 》  
因为部门基本都是使用 Vue，响应式系统 作用Vue 最具特色的特性之一，不懂大家平时会不会觉得很神秘，这次分享就是带大家深入到源码来看下 Vue 的响应式系统是如果实现的，主要是学习它的实现思想。

整个分分享分为三个部分

第一个是了解简单了解一下响应式系统

第二部份就是深入到源到看下响应式系统实现

第三部分会简单讲下 Vue3 在响应式系统实现上的改进

那我们就开始步入正题！

## 介绍

响应式系统-- Vue 最具特色的功能之一

MVVM 架构下，开发只需要关注于 Model（模型层） 和 View（视图层）。ViewModel 不需要关心，因为 Vue 的响应式系统起到了 ViewModel（视图模型层） 的作用，它自动将View层和Model层自动连接起来.  

响应式系统的表现在于：数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新

因此开发者只需关注业务逻辑，无需手动操作DOM

先看下 Vue 官网对响应式原理的说明：

当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法原生实现的一个功能，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因

每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染

官方这个说明比较简洁，我刚时看了完之后存留了几个疑惑点：

1. 使用 defineProperty 转为  getter/setter ，这个转换过程是怎么的？ 及  getter/setter具体做了什么事？

2. 将 “接触” 过的 property 记录为依赖，这个过程是什么？

3. 通知 watcher 使其关联的组件重新渲染，又是如果关联的？

所以对于响应式系统还是感觉很模糊，所以还得需要翻下源码，才能把他们搞清楚


以及给出一个图解（下一页)

我们来解读一下官网给的这个工作图

这里先根据这图先大致讲一下响应式系统的工作过程，先让大家对响应式系统有个初步的雏形

先看一下这张图片上面有些元素：

-  黄色这块，直译过来就是组件渲染函数

- 右边蓝色这块，它标注了一个 Watcher， 这个 Watcher 它其实是一个类的实例对象，我们这里先不深究是什么东西，根据它旁边的箭头含义，大家可以理解为这是一个可以触发组件重新渲染的一个对象

- 然后就是紫色区域，这个 data 就是我们组件中定义的 data 对象，根据之前的描述，vue 组件中的 data 都会使用 `defineProperty` 包装 data 中的属性添加 getter/setter 

- 最后一个元素就是 组件渲染函数 的产物，虚拟 Dom 树，虚拟 Dom 最后再生成最终的 我们看到的 直实 Dom

我们先根据这个图简单得把整个流程先过一下，然后再具体从源码角度去分析他们的具体实现。从黄色这个区域开始看，也就是 组件渲染函数 ，这个函数的作用就是渲染组件生成虚拟 Dom 树，在 render 过程中，也就是渲染过程中会访问我们 data 上面的属性，此时就会触发 `getter` 方法，在这个 `getter` 方法做一些依赖收集工作，  也将当前属性作为 watcher 工作的依赖

当走到 Watcher 这块的时候，左侧这里还有箭头，但是并不能在这个时候就直接往下走，继续住下走的话，就直接绕回到起点

现在我们其实要从  setter 方法为新起点来走这个流程，什么时候会触发这个 setter ？ 就是当我们改变 data 属性的时候。 setter 方法就通知 watcher ，通知 watcher 做什么呢？  这个时候就是可以按箭头往下走了， 这个英文直译过来就是 触发重新渲染方法，重新渲染 Dom，这样就能把整个流程图走通了

所以其实整个流程图应该分为两个部分来看   一个关联依赖关系阶段，另一个派发 watcher 阶段

从官网和描述及这图工作流程图，这里从中抽取三个比较重要的部分

第一个是对属性做 getter/setter 转换，这个过程的目的是监听属性的访问和更改，这里叫他为侦听器

第二个是可以触发组件渲染的 Watcher

第三个就是确定 Watcher 和属性的依赖关系，也就是 watcher 依赖收集，这里就叫依赖收集器

接下来就是从源码解来深入了解一下这三个部分是如何实现？


## 源码剖析

这一部分我们就直接深入到源码看下 响应式系统的实现

前面把整个响应式系统分成为三个组成部分，所以先分别看这三个部分是如何实现的

### 侦听器

首先是侦听器的实现

### 属性描述符

在讲侦听器的实现前，先回顾一下前端的一个基础知识点，因为侦听器的实现跟这个有关系

这里定义了一下很简单的对象：可以看出来这个对象有一个 name 的属性，  这个属性的 value 为 A。

可能有的同学会认为这个  ’value‘  只是一种别称，但实际上它是实实在在一个属性名。
这个 value 是存在于属性描述符中
对象中的每一个属性都拥有属性描述符，它表达了一个属性的相关信息。这个属性的值、是否可枚举、可修改都是属性描述符来控制的.   这里的 value 就是其中一个属性描述符的属性。 通过 Object.getOwnPropertyDescriptors 可访问某个属性的属性描述符信息，如这个例子

这个属性描述表达出来的属性意思为：

configurable： 控制该属性的属性描述符是否能够被改变

enumerable（英牛了ble），：控制该属性是否被枚举

value：该属性对应的值

writable：控制该属性是否能够被修改


接下再具体讲下属性描述符，目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。使用 defineProperty 来控制这些属性描述

数据描述符是一个具有值的属性，它特有属性是 value 和 writable

存取描述符是由 getter 函数和 setter 函数所描述的属性，它特有属性是  getter 函数和 setter 函数

一个描述符只能是这两者其中之一；不能同时是两者. 也就是 value + writable 和 getter + setter 这两对是不能同时存在的


OK 接下来回到正题


我们通过源码对 data 的处理的过程来看下 Vue 是如何给 data 添加 侦听功能的

以下是源码对 data 的处理路径，也就是调用栈

```
initMixin() => initState(vm: Component) => initData(vm: Component) => observe(data) => new Observer(value) => this.walk(obj: Object) => defineReactive(obj, key) => 使用 Object.defineProperty
```

接下具体看下代码，所有截图中的代码我都可能做了删减，只保留关键的部分为了更方便阅读

首先Vue 定义了一个 initState 方法来处理组件中的 Prop、method、data 之类的属性，每种属性分别调用不同的处理函数

我们跟着 data 的处理过程走，可以找到之后在 `initData` 方法中对 data 做了些判断后，会调用 observe 方法来处理，从这个函数的命名其实就是可以推测出，这个方法就是开始监听 data 的地方

无论是 initState 对 Prop、method、data 属性的处理分别做了拆解方式，还是这里的命名，其实这些代码组织方式都是我们平时可以学习的地方，因为函数功能的拆解和良好的命名确实方便了第三方阅读者理解代码

随后在 observe 方法中使用 data 值 通过 Observer new 一个实例对象，看下 Observer 是什么

### Observer

从之前调用 Observer 的地方来看，这里只有一个 value 参数，其它参数不用关心

从这段代码中主要是根据 data 的格式做不同的处理，从代码中可以发现 data 的返回值是可以是数组的格式，不过平时习惯得都是返回 对象格式

所以我们就以对象的格式继续看下 Vue 是如何处理的，从代码中可以看到 对于对象其实就是调用 `walk` 方法，遍历对象所有属性，分别调用  `defineReactive`，从命名直译过来就是  声明响应 的意思，这里就添加监听器核心方法，所以继续看下 这个方法是如果定义的  

### defineReactive

截图中的代码删除了一些细节处理，只保留了关键的代码。

看到这里在基本就是已经阶开了 Vue 给 data 添加监听功能的神秘面纱了

看下代码 

- 声明了一个 dep 实例， 这个 Dep 其实就是前面所说的 响应式三个元素之一的 依赖收集器，收集器我们等会儿再看是如果实现的，这里我们能关注到的一个信息就是，所有的 data 属性都有一个属于自己的一个收集器

- 对于冻结的属性不进行处理

- childOb 这行是递归 observer 来处理属性值，也就是我们 data 中定义的值即使是多层级的对象也是具体响应式功能的原因

- 然后通过 defineProperty 方法来定义每个属性存取描述符， 前面回顾属性描述符就是为了让大家能更容易理解这里的使用。核心就是为了添加 get 和 set 两个属性。

- 直接看下 get和 set 的定义，当访问了这个属性时将执行 get 方法，如果存在 Dep.target 收执行 dep.depend() 方法，下面几行表示子属性也收集这个 Watcher

- set 方法，核心就是做两件事件，修改值和执行 dep.notify()方法

对于这里出现的 Dep 及相关的方法先不用关心，因为到这里其实就已经达到我们这一部分的目的了，就是知道 Vue 如果如何给 data 数据添加侦听功能的。核心就是借助  defineProperty 来实现的

### 侦听器小结

通过源码可以知道侦听的实现思路就是

- 遍历所有的属性（包括对对象类型的子属性），对每个属性都创建一个收集器 Dep

- 同时使用 Object.defineProperty 方法进行包装（定义读取描述符 getter 和 setter）

- 有了getter/ setter，就可以知道数据被访问和读取的时机，就可以添加自定义的功能

同时还有几处还没弄明白的地方

1. Dep.target 是什么?

2. getter 中的 dep.depend() 是什么作用？

3. setter 中的 dep.notify() 是什么作用？

我们将带着这几问题继续往下解读

同时在了解其中的原理之后，我们平时在开发的时候要注意的一点就是：如果组件中 data 中的属性是一个非常大的对象，将影响性能

这也是之前的分享有强调过的，对于组件中不需要实时响应的数据，应该使用 Object.freeze 方法进行冻结处理，或者不要放入data中，这样就可以让 Vue 省去这些数据的处理，提高运行效率

## Dep

上一部分在讲侦听器时，涉及到了 Dep 这么一个概念

接下来就来看下收集器 Dep 这块的实现

图片所示就是 Dep 的实现了，从Dep的声明代码可以看得出来，这个 Dep 本质上就是一个发布-订阅者模式

并且从这些方法的声明中可以发现，这个发布-订阅者模式，收集的就是 Watcher 对象

每个 Dep 实例定义了一个 subs 数组收集 Watcher

同时定义  addSub、removeSub、depend 和notify来处理依赖 收集，移除 ，派发的操作

整个代码的逻辑还是比较容易懂的，除了 depend 方法，这里面Dep.target.addDep(this) 第一时间不懂跟当前 Dep 怎么产生的联系。这个后面再去研究

无论怎样看到这里其实也可以解答之前在侦听那部分留下了三个问题

然后我们可以结合 Dep 的功能重新整理个一下侦听器的实现，主要是可以补充 getter 和 setter 方法的功能逻辑

现在也搞懂了收集器原来就是一个实现发布-订阅者模式的一个实现类。而且也能和之前侦听器那块的逻辑联系在一起，  但是目前还存几个问题没搞明白：

- Dep.target.addDep(this) 是如果工作？这里还是看不出来是如果收集 Watcher的


- subs[i].update() 做了什么？即 Watcher.update 做了什么


- pushTarget 什么时候被调用 ？也就是 Dep.target 什么时候才被赋值 Watcher。没有搞懂这个 整个响应式系统就连不起来


但是这些方法都跟 Watcher 有关系，所以要理解这些得搞懂 Watcher 到底是什么东西


### Watcher

源码中 watcher 也是一个类而且代码太长了，即使把代码从头到尾读一遍，也很难明白 watcher 作用。所这里我们换种方式去理解 Watcher

这里找到目前涉及到的与 Watcher 相关的方法或属性，直接通过查看这些方法和属性的作用再结合之前分析过的侦听器和依赖收集的逻辑，来帮助我们理解 Watcher

首先可以确定是的前面出现的 Dep.target 等于 watcher .    还没搞清楚的地方有：

Dep.target.addDep(this) 做了什么？ 也就是 Watcher.addDep 方法的代码逻辑是什么

subs[i].update() 做了什么？ subs 里面存储的是 watcher，也就是 watcher.update 代码逻辑是什么

pushTarget 什么时候被调用 ？ 在 Watcher 也找到了调用  pushTarget 的地方，所以这个问题就变成了 Watcher.get 什么时候会被调用？

接来就是一一查看这些方法的逻辑

### Dep.target.addDep

首先看下 Dep.target.addDep ，我们可以直接找到 `addDep` 方法， 代码也比较少，直接将前后调用关系我们串联一起来理解一下

如图

1. 首先 访问数据时被 getter 劫持，调用 dep.depend() 方法。

2. dep.depend() 内部调用  Dep.target.addDep(this), 传入的参数 this 指向当前 dep 实例

3. 随后在  Dep.target.addDep 内部再调用  dep.addSub(this)，这个dep 就是上一步参数 dep 实例，this 则是当前 watcher 实例

4. dep.addSub 方法中将参数也就是 watcher 实例保存起来

实时绕来绕去，本质上做的事情还是将 Dep.target （某一个Watcher） 保存到当前 dep 实例中，至于为什么 dep.depend() 没有一步位进行保存？   我猜测的原因可能是因为 watcher.addDep 方法需要保存 dep 实例，目前这个做法可以把 dep 收集 watcher 和 watcher 保存这个dep 放在一起执行，方便维护吧。  这仅仅是我本人一个猜测

Watcher 的收集逻辑搞明白了，接下看 update 方法

### subs[i].update()

跟上一步一样直接看下 update 方法的定义

如果当前这个 watcher 是以同步的方式进行派发的，那么直接执行 run()方法

否则将 watcher 添加到异步任务队列，但是如下图，这是开发执行任务队列任务相关的代码，可以看到任务队列开始处理 watcher  的时候，本质上也是执行的 run 方法

所以无论是同步还是异步 从代码上看 update 其实就是做一件事件，就是执行 watcher.run 方法

### watcher.run 

继续顺腾摸瓜，看下 watcher.run 定义 

run 方法中省略掉一部分代码，只关注关键部分。那就是 执行 this.get() 并获取其返回值

而 this.get() 出现了一个关键的方法 pushTarget(this)，那么就找到了给 Dep.target 赋值的地方了

然后执行 this.getter()

从构建函数来看看  this.getter 是保存着  创建 watcher 传进行来的参数 expOrFn

那么现在就只剩搞懂 this.getter 会是什么东西了，  也很简单，因为这个属性在构造函数中赋值的，所以只需要找到 Watcher 在哪些地方会调用就知道了

在源码中找到了三处：

- 图中这段代码是vue初始组件相关的函数，在这里找到了一个生成 Watcher 实例的地方 。此时 watcher.getter 是更新组件的方法

  这里补充一点，就是 Watcher 构造函数根据调用场景会直接调用  this.get() 方法，也就是在创建 Watcher 实例的时候就会将当前 Watcher 保存到 dep.Target 中

  按着这个渲染组件函数继续往下走，在创建 Watcher 之后开始渲染组件，此时就会访问模板中有用到的 data 属性，此时触发 getter 方法，然后收集当前这个  watcher 到 dep 中

  整个过程水到渠成

- 除了这里，在处理 computed 属性时也会生成 Watcher，此时 watcher.getter 是计算函数

- 处理 watch 属性时也会生成 Watcher，此时 watcher.getter 监测的属性名

  这两个没有贴代码了，因为不重要了，我们核心关注在 Watcher上 
  
根据这些调用 watcher 的地方 已经足够我们去认为这个 Watcher 了

通过刚列出来的三个调用Watcher 的地方，其实可以把 Watcher 泛指成一种  事件，这个事件可以承接不同的任务。比如渲染用的 render Watcher，执行计算和监听的 computed Watcher 和 watch Watcher

到这里响应式系统的三大组成元素 侦听器、Watcher、Watcher 收集器 都认识了，接下来就把这三个元素串一起来描述一下组件渲染的过程

## 总结

现在结合组件渲染，把这三个元素的工作流程串在一起

初始化组件时，遍历 data ,为每个属性设置存储描述符 getter/setter，并为每个属性创建 Dep 实例

开始首次渲染组件，实例一个 Watcher 实例 （render Watcher），Watcher  实例保存更新组件的方法

在创建 Watcher 实例时，构建函数会执行 Watcher.get() 方法， 将当前这个 render Watcher 保存到 Dep.target

组件继续完成渲染工作，在渲染的过程中会访问到 data 属性，此时触发 getter 方法，将当前的 Dep.target 也就是 render Watcher 收集到自己的 Dep 中

渲染完成，收集工作也完成

修改了 data 属性，此时触发  setter 方法，派发收集到的 redner Watcher，执行 watcher.getter = 更新组件的方法

那么本次分享核心内容就讲完了，希望大家对 Vue 响应系统的原理会有一个初步的认识


### 数组的更新

接下来就补充一下 Vue 对数组类型的处理。因为数组的长度的变化是不能被 defineProperty 的 setter 劫持到的，也就是正常来说 push。pop 等数组方法是不能触发被监听到，但是Vue 仍然可以做到响应并做出视图更新，这里就稍微讲下 Vue 是如何做到的

主要是 Vue 对数组的方法做了重载

平时调用数组方法并不是直接调用的数组原生的方法，而是调用是Vue 重载后的方法

这个重载后的方法一方面会执行数组原本的方法。同时从当前数组中找到收集到的依赖进行派发更

看到代码中有一个 ob.dep.notify()，dep.notify() 不就是派发 watcher 的功能么，至于这个 ob 是从当前这个数组对象 __ob__获取的，这个__ob__ 是在 data 添加监听功能的时候添加的，为了就在操作数组的时候 找到当前数组对象的收集器

所以平时在使用数组方法改变数组时，也会更新到视图

## Vue3 

Vue 在初始化的时候使用 proxy 方法代理

Vue2需要遍历所有 data 属性添加监听功能，Vue3 使用 proxy 不需要这个遍历过程

Vue2.0 会为每个属性实例化一个事件收集器 Dep，这个Dep 的自己实现的 发布-订阅者模式

Vue3.0 则通过 const targetMap = new WeakMap(); 来做事件收集容器，targetMap 的 key 是代理对象，value 是 depsMap(一个收集事件容器的容器)

depsMap 是 new Map() 结构，代理对象的每个属性收集的事件将存储在这个 depsMap 中，所以找属性收集的事件时，先根据这个属性所属对象从 targetMap 找 depsMap, 在根据具体属性从 depsMap 找事件

在组件渲染的时候，会生成一个 effect 方法，并将当前 effect 保存到全局 activeEffect中，之后在执行渲染操作的时候会读取 data 的属性， 并被 get 劫持，get 方法中将保存在全局的 activeEffect 收集到 depsMap 中

之后当 data 属性被更改时，会被 set 劫持，从 depsMap 取出 effect 并执行













