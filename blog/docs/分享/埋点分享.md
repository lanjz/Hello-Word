---
sidebar: auto
---

# 埋点分享

各位同事下午好，这次给大家分享的内容是 《常见埋点方案的实现思路》  

内容的话跟埋点有关，但重点不会介绍埋点本身，比如埋点的作用了、怎么埋点，以及神策的使用都不是本次分享的重心

这次分享更多是从技术实现角度来了解一些常见埋点方案是如何实现的

本次分享会围绕具体的埋点方案来讲，如 曝光埋点、页面埋点、事件埋点这三个常见的埋点方式

那我们直接进入正题

## 曝光埋点

曝光埋点一般是用来统计页面某个模块、区域能被“看到”的次数

它的作用体现在两点

第一处就是了解页面各个模块的流量分布情况，毕竟页面空间有限、资源有限，需要衡量流量的分发效率，更合理得分配页面资源

第二个就是它是获取点击率的关键元素之一，点击率是通过  点击次数/曝光数 计算得到的，所以想知道点击率真，就得曝光量

接下来我们看下自己如果实现曝光埋点如何

### 明确需求

我们先明确下曝光埋点要注意的地方：

首先所谓的曝光就指元素出现在视窗中，能被用户看得到，也就是说我们需要通过某种手段来监测模块在视窗中的位置 

其次并不是所有出现在视窗中的元素都值得被收集，比如用户快速滑动页面，此时记录这些一闪而过的模块其实没有什么意义   
所以得先规定有效曝光规则：正常来说需要两个条件，一个是一定的曝光面积、另一个则是持续曝光的时间

第三点收集元素的曝光本质是需要监测元素的，所以如果要监测的元素太多，无疑将会影响性能，所以几乎所有的第三方采集平台都会在曝光埋点的文档里注明：“请不要配置过多的曝光埋点，这会严重影响你的页面性能”

### IntersectionObserver

然后就是具体实现了，要实现曝光埋点，最核心的就是需要获取元素的曝光状态，这里可以使用 IntersectionObserver api 来实现

IntersectionObserver 提供了一种异步观察目标元素与祖先元素交叉状态的方法

看下他的用法

1. 首先是 new 一个 IntersectionObserver 实例

2. 然后通过实例的 Observer 方法添加要监测的元素

3. callback 监听元素交叉状态发生变化时的回调

4. option 用于配置一些属性：root 表示目标元素所在的容器节点，如果不指定默认为视窗

5. rootMargin 表示元素到根元素的边距，类似于css的margin属性

6. threshold（齿re shold） 表示相交的比例，也就是设置面积超过多少才算是有效的曝光，他的值既可以是一个数字也可以是一个数组。取值在0-1之间

所以使用 IntersectionObserver 基本能满足我们解决我们获取元素曝光状态的需求 

### 实现思路

然后围绕 IntersectionObserver 就可以实现我们曝光埋点的功能

这里以 Vue 项目为例，来看下曝光埋点功能的具体实现步骤

1. 使用  [Intersection Observer API] 实例化一个全局 `observer`，将需要收集曝光埋点的元素收集到 `observer` 观察列表中， （这里会用Vue的指令来实现）
   
2. 收集到 `observer` 中的元素，如果在保存 500ms 后不还可见，则视为有效
   
3. 当 `observer` 有元素时，执行一次定时器，每 2s 上报一次数据
   
4. 为了防止上报前页面关闭，所以需要将 `observer` 里的数据缓存到 localStorage 中
   
5. 下次进入页面先检查 localStorage 是否有值，有的话直接上报。（这一步不准确等情况）

这是代码实现，整体代码没有复杂的地方

首先定义一个类来实现曝光埋点的实现

1. 检查 localstorage ,如果有数据，则直接上报

2. 实例一个 Intersection Observer

3. 将曝光的元素的保存到  temStore 属性中

4. 启动一个定时器进行上报工作

5. 对于消失的元素如果时间在 500ms 内，则移除这个元素

其次就是提供一个 add 方法用于添加需要监测的元素

然后就是实例一个 Vue 指令来使用这个 Exposure 类，需要曝光埋点的元素使用这个指令就可以了

然后一个曝光埋点的功能就基本实现了

## 页面埋点

接下来是页面埋点

页面埋点就是记录页面的访问量，一些埋点指标如 PV/ UV/IP 都依赖于页面埋点

页面埋点的实现相对还是比较简单的，我们直接从单页面结构入手

正常来说单页面应用是使用路由来进行页面切换，路由又分成了两种，一种是History 模式 ，另一种是Hash 模式

然后还有一些非常规的单页面应用，没有使用到路由，是使用动态组件的形式来进行页面的切换，此时url地址是固定不变的

咋们部门之前的一些项目就是使用的这种方式，所以使用常规的埋点方式就不适用了

先看下常规路由模块是如果进行页面埋点的， History 模式为例

首先 History 模式是使用 History Api 来实现

History Api 的最大特点就是可以在不刷新页面的前提下动态改变浏览器地址栏中的URL地址 

它常见的有五个方法

- back()：向后跳转，类似浏览的后退按钮  
- forward(): 向前跳转，类似浏览的前进按钮  
- go(): 跳转到 history 中指定的一个记录  
- pushState(): 添加一条历史记录  
- replaceState(): 替换当前的历史记录

对应还有一个 popstate  事件, 每当活动的历史记录项发生变化时， 将执行popstate 事件 

看到这里，页面埋点的实现方案就有了，就是使用 popstate 获取 history 变化的时机 ，当 history 发生变化的时候，就可以进行一次页面埋点收集

但是有一个问题就是 pushState 和 replaceState 这两个方法的调用是不会触发  popstate 事件的

这两个方法得额外处理一下

处理的方式就是对他们进行改造，扩展一下

这个就是改造的代码，重写 pushState 和 replaceState 就行了，然后调用这两个方法的同时就可以执行我们想要的其它操作

右边这个是神策的源码，可以看到神策也是这么实现的

所以通过 postate 和这两个方法进行重写，就已经完成面埋点的功能

如果页面 HASH 模式，对于 hash 变化会触发 hashChange 事件，但其实我们并不需要额外处理 hash模式，因为 hash 的变化 也可以触发  PopState 事件 

总结来说路由模式下  使用pushState、replaceState + PopState 事件就可以实现一个页面埋点的功能


### 非路由

接下来看下非路由模式怎么对页面访问进行采集，这种项目的只能手动上报页面埋点了

我自己也有维护一个老项目，也是没有使用路由，对于这类的项目，我目前只想到两种方式

如果切换页面组件的方法统一是通过某个函数的来处理的，那么就可以直接这个函数里手动进行埋点上报

如果切换的方法再多的话，就可能就得使用 minxin 了，使用的 minxin 最大的问题是如果区分 当前组件是页面级别的组件还是普通的组件

以我手头里一个项目为例为便，我发现页面组别的组件才会有 moduleId 属性，所以我借助这个属性来进行判断

对于没用路由的应用 如果大家还有其实方法的，等下也可以补充一下

当前如果项目还有在进行迭代的时候，如果条件允许的话 最好还是花时候改成路由模式比较好


## 元素事件埋点

元素事件埋点收集收集的是用户交互行为，这里归纳事件埋点的四总方式

手动代码埋点、无痕埋点、可视化埋点、Label 插件埋点

### 手动代码埋点

这种埋点方式就是最基础的了，比如现在我们正在使用的神策，在 SDK 初始化之后，我们就可以使用  track()  等相关方法，进行手动的埋点收集

优点：

1. 精准控制埋点位置

2. 灵活的自定义事件和属性，方便采集丰富的业务相关数据

3. 可以满足精细化的分析需求

缺点的话 主要是依赖开发人为操作

1. 埋点代价比较大，每一个控件的埋点都需要添加相应的代码，不仅工作量大，而且需要技术人员参与。

2. 更新的代价比较大，每一次更新埋点方案，都必须修改代码

3. 对代码的侵入太强，埋点多的话会严重污染代码

所以手动代码埋点适用于需要精准控制埋点位置、灵活的自定义事件和属性等精细化需求的场景


### 无痕埋点

无痕埋点也叫无埋点  全埋点 无代码埋点 都是一个意思

先理解一下什么是无痕埋点

这句话是神策对于无埋点那块的说明：Web JS SDK 全埋点包括三种事件：Web 页面浏览、Web 元素点击、Web 视区停留

所以无埋点不是只用于解决元素事件埋点，之所以放在这里只是强调  全埋点方案也是实现元素点击埋点的方案之一

无埋点的作用：只要嵌入sdk，就可以自动收集数据。不再需要额外的埋点代码，这里所指的不需要额外的埋点代码指的就是调用方

所以无代码不是真的没有代码，而是SDK 集成一些埋点方法足以收集大部分场景下埋点信息，缩减了我们手工埋点的工作

比如前面我们说的 页面埋点方案，它的实现跟业务完全没什么相系，就是一个通用的解决方案，所以 SDK 集成这个方案后，我们项目就不需要额外实现页面埋点的收集了，所以就无埋点了

这里的元素事件埋点也是同理，接下就看下无代码到底怎么个回事

首先要明白一件事情就是无代码埋点收集的是什么东西？

于是我看了根据神策的全埋点配置，看了下点击元素时的处理过程，可以发现收集数据就是 元素相关的信息

比如标签名，属性，以及元素在整个 DOM 树的中位置等，也就是收集的东西完成是基于 DOM 元素

那么问题来了，收集到 元素如何与用户的点击行为建立关系

此时就需要给元素建议唯一标识，通过这个唯一标识建立关系

这个唯一标识就是 XPath

### XPath

DOM 其实是个树形结构，XPath 根元素开始到当前元素的路径集合，同一个页面下，这个路径基本上是唯一的，所以通过这个集合来做一个元素标识

有了身份标识之后，之后如果想要知道某个元素的点击量，那么可以根据这个元素的 XPath 从收集的数据中进行过滤和筛选，然后得到埋点结果

所以可以发现无痕埋点的实现关键不在如果收集元素，而后期的数据清理、筛选才是无痕埋点的关键步骤

然后回到元素收集这件事，也是根据神策全埋点开启后的代码执行过程，可以知道痕埋点就是给 document 绑定点击事件，也就是事件委托的方法来监听元素的点击行为，注意事件传播方式要选择 捕获方式， 也就是 true
这样才可以防止被子元素阻止冒泡，导致事件无法触发

无痕埋点功能的实现思路就介绍完了

### 总结

总结一下无痕埋点的优缺点

优点：

1. 自动采集数据，无需开发人员代码埋点
2. 收集用户的所有端上行为，很全面
3. 可以回溯，也就是后期运营空想想到哪一处的点击量，也是可以拿到的，不用重新收集

缺点也是很明显了：

1. 不可见行为数据无法采集
2. 和业务强相关的属性信息采集困难
3. 数据量可能会很大，占用存储空间，所以一般来说会做下限制，比如神策默认的采集规则
4. 依赖 DOM 结构，所以并不是很可靠

## 可视化埋点

可视化埋点运营同事可以直接对页面的元素通过 点点点 的方式就能设置好一个埋点


这是神策可视化埋点界面，其实就是在埋点平台，加载我们要设置埋点的项目，然后点击元素的时候通过 埋点平台，对当前元素进行基本设置，然后保存到后台

我觉得可视化埋点其实就是对无痕埋点的一种优化， 前面说到无痕埋点需要后期通过 XPath 对数据进行清洗和过滤

可视化圈选其实就是通过圈选功能给元素设置埋点，也包含了XPath，这样结合无痕埋点，就可以过滤出圈选的数据了

所以可视化埋点的这块主要看下圈选这部分的功能实现


1. 埋点管理页使用 iframe 加载需要埋点的页面

2. 加载的页面包含 SDK的功能 ，所以埋管理页会和页面建立通信规则，使用 postMessage

3. 当子页面在接收到 圈选 的消息时，在 dom 中插入一段 style 标签，用于圈选时添加选中样式

4. 点击元素时添加高亮样式同时将当前 dom 的 xpath 等元素信息发送给父页面并存储
   
5. 结合无痕埋点数据拿这些 xpath 去清洗、过滤就能拿到我们想要的数据了

所以可视化埋点和无痕埋点其实挺像，优缺点也是大同小异

优点：

1. 自动采集数据，无需开发人员代码埋点
2. 可以做到按需配置，不会像全埋点那样产生大量的无用数据
3. 后期数据分析成本低
4. 运营人员自己就可以进行埋点设置

缺点

1. 不可见行为数据无法采集
2. 和业务强相关的属性信息采集困难
3. 也是依赖 DOM 结构，如果页面结构发生变化的时候，可能就需要进行部分重新配置

## Babel 埋点

全埋点或者可视化确实让埋点的收集变得非常方便，但是他们最大一个问题就是对于业务数据的收集能力实在太弱了

但是手动埋点又存在一些让开发人员非常难受的一些问题

所以这里的 Babel 插件埋点就是帮助我们使用手动埋点的同时，尽量规避这些问题

### Babel

Babel  JavaScript 编译器，它能把同种语言的高版本规则转换为低版本规则。

通俗讲就是将es next(ECMScript2015，ECMScript2016，ECMScript2017等)的语法转换为向后兼容的JavaScript语法，使代码能够运行在当前的和旧版本的浏览器或其它环境中

这终展示的是Babel 的工作原理 

Babel 工作分为三大阶段：

- 解析(Parse)：将代码字符串解析为抽象语法树；

- 转换(Transform)：遍历抽象树，对抽象语法树进行再变换，Babel 插件就是应用在这环节，如果我们使用 Babel 时没有配置任务插件，那么JS语法将原样输出

- 生成(Generate)：使用 babel-generator 模块将 AST 再转换换为 JS 代码

这是一个 JS 转换成 AST 后个类型，每个语句都对应一个 AST 节点，AST 有一个 type 属性来标识当前语句是什么类型的

Babel 插件就是用于改变 AST 结构

### 插件思路

我们先确定下这个 Babel 插件的实现思路

1. 根据函数注释判断是否需要自动埋点

2. 引入埋点函数文件

3. 函数插装：将埋点方法插入到需要埋点的函数

接下就是讲下这个插件如何实现

第一步：这是一个 Babel 插件的空架子

可以发现 Babel 插件其实也就是一个函数，它会将 api 通过参数的形式传回来  
它会返回一个对象，对象中有一个 `visitor` 属性，这个属性中帮助我们访问节点类型

第二步：既然我们需要根据函数的注释来判断是否需要自动埋点，那么首先我们得先确认，函数有哪些形式：

一共有四种

函数声明、函数表达式、箭头函数、类方法

所以我们的 visitor 只需要处理主些类型就行了

多个类型使用 | 来分隔

寻找注释位置

从上面的例子可以看到块注释的 AST 类型是 `leadingComments`，而且函数类型的不同的  `leadingComments` 位置也不同

- 函数声明和类函数的 `leadingComments` 就在函数的 AST 节点下，可以使用path直接获取

- 函数表达式和箭头函数的 `leadingComments` 属性在它们的父级节点，因为他们是通过变量声明的方式赋值函数的，也就是我们的注释其实是在 `VariableDeclarator` 节点下

  因此对于 函数表达式和箭头函数 我们需要通过父级节点去查找


怎么更方便得获取业务数据呢。我目前想到两种方式

首先我们插入的埋点方法绑定了当前有 this，所以埋点方法调用的时候可以直接调用 当前 组件中数据

那么第一种方式就是通过配置文件的形式 ，来配置埋点项需要上报哪些业务数据
配置也可通过异步来获取，所以可以直接后台进行编辑，这样可以更灵活对埋点进行修改

第二种就是也可以扩展一下注释内容，通过注释内容上报一些数据，Babel 插件解析出这些内容作为参数传给埋点方法




然后本次分享就结束了，本人对于埋点这块也是理论大于实践，是浅层得介绍了一些埋点方案的实现思路 

通过这这次分享能帮忙大家更好进行埋点工作，在实际工作中能选择最合适的方式进行埋点方案













