---
sidebar: auto
---

# 评审

各位评委好，我叫兰江州，目前在财经中心成本结算组担任前端开发工作师，目前的职级为 8 级，当前评估职级为9级

接下来我主要会从  性能优化、架构能力、开发语言 这三个方面来举证自己的能力

## 性能优化 - spreadJS

首先是性能优化方面

第一个要举证的例子是目前正在参与的集团预算编制项目CBM，它是用于解决集团业务到财务的编制问题，因为使用群体需要使用 excel 进行数据管理， 之前是使用控件的方式进行使用，使用功能复杂，成本高，因此项目引入SpreadJS，一个 web excel的JS库 ，在使用的过程中发现数据加载存在非常严重的性能问题，上百条数据超过9秒，上千条数据则会导致页面崩溃

针对这种问题，当时我首先是使用谷歌的调试工具 Performance 查看一下数据的加载到显示期间代码的执行情况，最终通过输出结果定位到了两处问题：

1. 首先是根据底部面板发现一个 defineReactive 这个函数，他占用了 20% 的执行时间，这个项目是用 vue 开发的，结合 Vue 的响应式原理，可以判定组件 data 出现了非常大的属性

2. 第二点结合火焰图可以发现大量的时间是在处理表格的样式

### 解决问题

定位到问题之后就可以针对性进行优化了

首先 defineReactive 耗时问题：

解决方法是将体量大的属性移出 data 或者冻结这些属性，减少 vue 对 data 的初始化工作

对于 spreadJS 样式设置的问题，我当时的解决方式是从官方文档中查阅样式设置的所有方法，结合论坛及自己的尝试，总结出设置样式方法的性能优劣情况： 从高到低分别是 全局默认样式  > 行/列样式设置 > Range局部样式设置 > 单元格样式设置

然后将现有样式设置的处理按上述顺序进行优化

优化后在相同数据情况下，数据加载的时候从 9.3s 缩减至 0.4s 


## 性能优化 - 长列表

第二个要举证的优化例子是项目有些地方的下拉选择的数据比较大，每次打这些选项都能感觉到页面很卡顿，也是结合 performance，可以发现在显示下拉选项的过程中,CPU一直在做渲染工作

渲染过程大约要执行 2秒左右

我当然解决方案是重新编写 select 组件， 采用虚拟滚动来显示列表选项，以此来达到控制 Dom 节点渲染数量的目的

优化可以看到 下拉选项的节点不再全部展示，显示的时候 从原来 2s 直接缩短至 64ms

## 架构能力-重构

接下要举证的是架构能力

首先要举证的例子是之前对部门的前端模板做了一次重构工作

重构的原因是入职后第一个任务就是使用这个前端模板独立负责一个项目的前端开发，使用这个前端模块的时候就对这个前端模板的代码进行了头到尾的了解。发现这个前端模板还有很多可以优化地方，于是就中在部门进行了讨论，同时部门的前端小伙伴在之前使用过程中也都有记录了一些问题

所以就对这个模板进行了一次重构

具体的问题会在接下的重构内容中进行介绍

### 页面架构方面

之前路由结构与菜单结构是强耦合的，需要同级进行匹配且code 相同才算是有效路由，最后再进行路由组的注册

且所有的目录菜单都需要注册路由容器

因此就存在了很多问题：

- 菜单与路由构建强耦合
- 这前的设计不支持路由无法进一步拆分
- 路由配置结构冗余
- 各自无法灵活进行修改


优化的页面架构首先菜单的结构和路由结构是各自独立的，他们的关系只有 code，并且在进行路由注册时，只会提取页面级别的路由配置，然后再进行路由注册，改造后路由和菜单可以自个灵活得进行修改，且前端在路由配置上更多灵活


这个张图基本列出了我当前重构的内容，以及重构的思路和原因

### 菜单权限

菜单权限之前设计存在的问题在于，菜单的结构与路由结构必需是一致，这导致了很多问题，比如

各自无法灵活得进行配置与修改，任意一方的修改，另一方也要一起修改

前端无法灵活使用路由

因为要保持结构一致，所以非叶子节点的路由也要注册路由容器组件，这导致路由配置产生了冗余

因此重构后最大的改动就是将他们进行解耦，他们的关系只有 code，至于菜单结构的配置与路由配置没有任何的关系，这即方便了双方的配置同时也增加了前端对路由使用的灵活性

### 组件

对于文件中的资源像 组件、工具方法进行严格的划分

以组件为例，组件管理严格按通用组件、业务组件、应用组件进行划分

对于全局组件统一使用 Vue.use 进行注册使用，这么做的原因一方面是为了让全局组件能统一注册入口进行管理，同时使用 Vue.use 配置传参，可以给让全局组件在某些方面与项目保持一致，比如有些组件可能需要使用请求功能，为了独立性，那么可能会自己封装请求进行处理，那么就会存在一个问题，组件的请求前与请求后很难与项目的请求保持一致，因此在注册组件通过配置将项目中的请求方法传给组件进行使用，组件只需要规定请求的返回格式，传入的请求方法符合这个格式就可以了，这样即保持组件独立性，即省去这块的额外封装，同时行为又能与项目行为保存一致

然后就是重新封装了请求方法，添加防重复请求、自动添加loading ，错误提示等功能

之前一次请求致需要22行代码，新的请求方式只需要13行代码

然后就是删除了很无用的代码和模块，毕竟 More less more fast

以物以类聚、向下分层的规则来管理文件和组织代码，避免出现的臃肿的文件


## 架构能力-iframe

第二例子的背景是项目分成两个项目，并使用 iframe 来加载子项目，有些微前端的意思，

但是当时之所以这么拆分并不因为要拆分业务线、独立维护与部署， 因此拆分前后还是同一批团队来维护的，对于前端而言就需要同时维护两个项目，这无疑就增加开发的调试成本，还需要思考公共模块的管理问题、由于  Iframe 本身存在一些问题，整体用户体验感降低

所以当时就一直在想办法对这块进行优化，中间有想过使用 quainkun  microapp 之类的微前端方案来优化，但最终基于问题本质，最终还是采用了返祖的方案进行优化

就是直接将所有内容直接部署到 iframe 域名下，主域只需要提供一个简单的 iframe 加完整的项目

这种解决方式虽然简单粗暴，但不仅能满足产品的需求，而且规避了微前端的所有问题，无论在用户体验上，还是开发成本都得到极大的提升

解决问题不在技术手段的堆叠， 而是需要围绕问题给出最合适的解决方案


## 开发语言-requestIdleCallback

最后是开发语言能力的举证

第一个例子是  JS单线程的原因，对体量大的数据处理会产生阻塞问题，比如项目中加载一万多条的数据，并需要遍历他们进行加工和显示就需等待 7.5s 左右


## 开发语言-埋点

1. 事件埋点对业务代码的侵入太强，污染代码  
2. 产品只是埋点需求的变更，小程序也需要改代码 -> 审核 -> 发布，整个过程不够灵活

为了解决这些问题，我采用了自动化埋点方案，事件的触发时机等同于函数的执行时机，所以扩展小程序App 方法，给组件中的方法添加 hook，劫持方法的调用根据埋点配置判断是否命中自动实现事件收集


## 开发语言-配置化表格与表单

1. 后台系统常见的表单与表格功能和交互都是相似的，但每次开发都需要重新编写相同的代码逻辑
2. 而且表单与表格的实现基本占用了模板部分一半的代码量

为了更加方便和快速和开发这部分的功能，我封装配置化表单与表格组件，通过配置（JSON）的形式来自动渲染出表格与表单


## 岗位工作目标及对应关键举措

能力举证的例子就介绍完了，接下是我短期内我的工作目标是：

1. 全面完成预算项目的优化工作
   
2. 目前团队正在使用 qiankun 框架来实现微前端，我希望小伙伴们不仅仅只会使用，因此近期会做一次相关知识点的分享，主题为《qiankun 实现原理》

自己重点提升的能力是深入到服务层

关键举措 

1. 优化工作：优化的过程会不断探索优化方法，尽量使用最优的方案来解决问题
   
2. 服务层：一方面业余时间多看看相关知识点、另一方面结合工作多与后台同学请教


## 性能优化Q&A

### 响应式原理？

Vue 响应式原理有三个要素组合：侦听器、依赖收集器、Watcher 事件

侦听器是通过遍历 data 属性然后使用 defineProperty 劫持属性的 set/getter 方法

然后每个属性还会实例一个 依赖收集器，这个收集器是一种发布-订阅者模式

依赖收集器具体收集的就是 Watcher 事件

这个Watcher 事件就是具体渲染组件功能的一个对象

整个流程就是组件在首次渲染的时候，会该跟 data 属性，被 get 劫持，然后收集当前的 Watcher事件，这一步就完成事件的收集功能

之后当修改 data 属性时，被 set 劫持，然后从当前派发当前收集到 watcher ，进行组件更新

### defindProperty 的缺点

无法监听数组方法的变化、通过索引修改值也无法监测到

vue是通过重写数据方法来实现监听功能

索引的修改没有办法，只能通过提供的 $set 方法来进行操作

### 重写方法和 $set 具体做了什么？

以数组为例，在处理data属性的时候，都会给当前属性额外添加一个 __ob__属性，这个__ob__是指向当前属性的依赖收集器

### Vue3？

Vue 在初始化的时候使用 proxy 方法代理，关于收集器两个版本的区别

Vue2.0 会为每个属性实例化一个事件收集器 Dep

Vue3.0 则通过全局变量 const targetMap = new WeakMap(); 来做事件收集容器，targetMap 的 key 是代理对象，value 是 depsMap(一个收集事件容器的容器)

depsMap 是 new Map() 结构，代理对象的每个属性收集的事件将存储在这个 depsMap 中，所以找属性收集的事件时，先根据这个属性所属对象从 targetMap 找 depsMap, 在根据具体属性从 depsMap 找事件

在组件渲染的时候，会生成一个 effect 方法，并将当前 effect 保存到全局 activeEffect中，之后在执行渲染操作的时候会读取 data 的属性， 并被 get 劫持，get 方法中将保存在全局的 activeEffect 收集到 depsMap 中

之后当 data 属性被更改时，会被 set 劫持，从 depsMap 取出 effect 并执行

### Object.freeze

- 属性描述符：enumerable、configurable

- 数据描述符：value、writable

- 存储描述符：get、 set

```js
var obj = {
    prop: 42
};

Object.freeze(obj);

Object.getOwnPropertyDescriptor(obj, 'prop')

// {value: 42, writable: false, enumerable: true, configurable: false}
```

### Object.freeze 属性值是对象，可以修改么

可以

### Object.freeze 对数组有效么

有

### freeze 和 seal 区别

使用Object.freeze()冻结的对象中的现有属性值是不可变的。用Object.seal()密封的对象可以改变其现有属性值。

- seal 无法新增或修改属性

### 虚拟滚动实现思想

外层定义一个固定高度的 div

内层定义一个所有数据高度的容器

监听外层滚动事情，通过滚动条的高度来判断当前滚动位置应显示的数据位置

然后显示数据那层再通过 transform 偏移量保存与 scrollTop 一致

```js
  scroll(e) {
    let {scrollTop} = e.target
    let ind = Math.floor(scrollTop / itemHeight) // 从第几条数据开始显示
    ind = Math.min(ind, this.dataLen - visibilityNum)
    this.start = ind
    // Math.abc(...) 是滚动到底部时，列表应该所在的偏移量
    this.top = Math.min(scrollTop, Math.abs(scrollTop - (visibilityNum * itemHeight - this.boxHeight)))
  }
```


### 如何虚拟滚动元素高度都不致呢

中间滚动过程：假可见容易高度为 10，那么列表容器假设为 50px,顶部还一个空元素用于撑开顶部没有渲染出来的列表高度， 此时可视区域为 20到30 数据，首属各有20条数据，这个数据都是估算数据，部除了可视区域的显示，顶部和渲染区域能足够用于滚动却可，那么在滚动的过程中，以一个可见视图高度为一个单位，比如我滚动到了20，此时削掉头部10条数据，顶空间DVI就增加削掉元素的高度各，向上滚动时也是同理

一开始滚动的时候，就判断阙值

结尾滚动的时候，当前列表已经把最后的数据列上去时，此时可以判断最底离顶的高度，调整顶部空白高度，让空白DIV + 渲染列表的高度等于最后一个元素到顶的高度



### 性能指标

- FCP：首次内容绘制

- LCP：最大内容绘制

- FID (First Input Delay)：首次输入延迟，首次输入延迟

### 重排会产生比重绘更大的开销

## 架构能力 Q&A

### 防重复请求思路

- 使用url method 参数 作为每一个请求的唯一标识

- 如果标识重复出现了，说明重复发起了请求，则通过 CancelToken 直接取消当前请求

### 如果解决 url 同步问题

1. iframe 项目监听 url 变化，通过 postMessage 通知父项目

2. history 模式下 pushState 和placeState是 是不是能触发 onpopstate 事件的，通信重写来解决

   ```js
    const bindEventListener = function(type) {
        const historyEvent = history[type];
            return function() {
                const newEvent = historyEvent.apply(this, arguments);
                const e = new Event(type);
                e.arguments = arguments;
                window.dispatchEvent(e);
            return newEvent;
        };
    };
    history.pushState = bindEventListener('pushState');
    history.replaceState = bindEventListener('replaceState');
    ```

### render 方法是否有性能问题

vue 模板本身就是会编译成 render

### render 里的 h 方法返回的是什么

虚拟 Dom

### createElement ?

`createElement`接收参数如下：

- `tag`: {String | Object | Function}表示一个 HTML 标签名、组件选项对象

- `data`: 可选参数，表示 `VNode` 的数据，完整的数据对象如下

  ```js
    {
      // 和`v-bind:class`一样的 API
      'class': {
        foo: true,
        bar: false
      },
      // 和`v-bind:style`一样的 API
      style: {
        color: 'red',
        fontSize: '14px'
      },
      // 正常的 HTML 特性
      attrs: {
        id: 'foo'
      },
      // 组件 props
      props: {
        myProp: 'bar'
      },
      // DOM 属性
      domProps: {
        innerHTML: 'baz'
      },
      // 事件监听器基于 "on"
      // 所以不再支持如 v-on:keyup.enter 修饰器
      // 需要手动匹配 keyCode。
      on: {
        click: this.clickHandler
      },
      // 仅对于组件，用于监听原生事件，而不是组件使用 vm.$emit 触发的事件。
      nativeOn: {
        click: this.nativeClickHandler
      },
      // 自定义指令. 注意事项：不能对绑定的旧值设值
      // Vue 会为您持续追踨
      directives: [
        {
          name: 'my-custom-directive',
          value: '2'
          expression: '1 + 1',
          arg: 'foo',
          modifiers: {
            bar: true
          }
        }
      ],
      // 如果子组件有定义 slot 的名称
      slot: 'name-of-slot'
      // 其他特殊顶层属性
      key: 'myKey',
      ref: 'myRef'
    }
  ```

- `children`：{String | Array} 表示子节点

这里着重了解一下 `createComponent` 第一个参数 `tag` ， `tag` 可以有的类型以及对应的内部处理大致如下

- 如果是 `String` 类型

  - 选判断如果是内置的一些节点，则直接创建一个普通 `VNode`

  - 如果是为已注册的组件名，则通过 `createComponent` 创建一个组件类型的 `VNode`

-  如果是 `tag `一个 Component 类型，则直接调用 `createComponent` 创建一个组件类型的 `VNode` 节点

- 其它值暂不讨论


## 开发语言 Q&A

**requestIdleCallback缺陷**

- 兼容性一般：如 IE、Safari  不支持

- requestIdleCallback FPS只有20，常规是 60，流畅度也是低于常规

**想要实现requestIdleCallback的处理，有2个点需要解决:**

- 如何判断一帧是否有空闲？

  requestAnimationFrame 计算一帧到期时间点

  估算一帧结束时间：`const deadline = raf + 1000/60;`

- 下一次宏任务判断时间是否有超过过期时间 `deadlineTime - performance.now()`

   如果时间则时间任务

**为什么使用 MessageChannel  执行宏任务？**

因为 setTimeout 有阈值，4ms

### 可以用 setTimeout 么？

可以！ 但没有 requestIdleCallback 好

serTimeout 只是粗暴得将任务塞到下一次宏任务执行，会跟下一次宏任务里的任务一起占用执行时间

而requestIdleCallback更温和点，只在一帧的空闲时间去执行

## 无埋点

无埋点也叫全埋点， 通过捕获的形式给 body 添加监听事件，这样所以的 元素点击就能收集到，然后就是传 xpath 给后端，后端进行过滤

## 圈视化埋点

todo

## 配置化表单的特点

1. 使用 render 方法代替 if/else

2. 支持个性化元素

3. 封装了交互，即使使用了 slot 来展示，也可交互

## 关于财经建设这块

我们这份开发的根本是要开发一款程序，这个程序运行的质量、可行性、体验才是我们追求的最终目的
然后再往前推一点则是考虑 更高效开发过程  代码管理 等  

而所有工具及技术 及流程都是服务于其中某一环节的

并不是为了用而用，而是为解决某类问题才去用

我入职到目前八个月左右，就我目前所想，用不到这些技术，反而这些技术增加了开发的复杂度

我个人更倾向于先关注于最基本的东西。 比如代码本身，我更希望让团队都具有一些共识，就是把自己负责的项目  当做自己的作品一样去认真对待，这些不在于要使用多少牛B的技术，而尽量去完善自己写的代码和功能， 把代码写漂亮点。在思考代码优化和性能优化的过程中去自然而然引用一些技术来解决问题

而不是盲目追求或使用某类技术
