---
sidebar: auto
---

# 评审

各位评委好，我叫兰江州，目前在财经中心成本结算组担任前端开发工作师，目前的职级为 8 级，当前评估职级为9级

接下来我主要会从  性能优化、架构能力、开发语言 这三个方面来举证自己的能力

## 性能优化 - spreadJS

首先是性能优化方面

第一个要举证的例子是目前正在参与的一个项目，这个项目有引入 SpreadJS，初期使用的时候发现数据加载存在非常严重的性能问题，上百条数据超过9秒，上千条数据则会导致页面崩溃

针对这种问题，当时我首先是使用谷歌的调试工具 Performance 查看一下数据的加载到显示期间代码的执行情况，最终通过输出结果定位到了两处问题：

1. 首先是根据底部面板发现一个 defineReactive 这个函数，他占用了 20% 的执行时间，这个项目是用 vue 开发的，结合 Vue 的响应式原理，可以判定组件 data 出现了非常大的属性

2. 第二点结合火焰图可以发现大量的时间是在处理表格的样式

### 解决问题

定位到问题之后就可以针对性进行优化了

首先 defineReactive 耗时问题：

解决方法是将体量大的属性移出 data 或者冻结这些属性，减少 vue 对 data 的初始化工作

对于 spreadJS 样式设置的问题，我当时的解决方式是从官方文档中查阅样式设置的所有方法，结合论坛及自己的尝试，总结出设置样式方法的性能优劣情况： 从高到低分别是 全局默认样式  > 行/列样式设置 > Range局部样式设置 > 单元格样式设置

然后将现有样式设置的处理按上述顺序进行优化

优化后在相同数据情况下，数据加载的时候从 9.3s 缩减至 0.4s 


## 性能优化 - 长列表

第二个要举证的优化例子是项目有些地方的下拉选择的数据比较大，每次打这些选项都能感觉到页面很卡顿，也是结合 performance，可以发现在显示下拉选项的过程中,CPU一直在做渲染工作

渲染过程大约要执行 2秒左右

我当然解决方案是重新编写 select 组件， 采用虚拟滚动来显示列表选项，以此来达到控制 Dom 节点渲染数量的目的

优化可以看到 下拉选项的节点不再全部展示，显示的时候 从原来 2s 直接缩短至 64ms

## 架构能力-重构

接下要举证的是架构能力

首先要举证的例子是之前对部门的前端模板做了一次重构工作

第一次使用这个前端模块的时候就对这个前端模板的代码进行了头到尾的了解。然后发现这个前端模板还有很多可以优化地方，
比如。。。。。。。。

所以就对主个模板进行了一次重构

这个张图基本列出了我当前重构的内容，以及重构的思路和原因


## 架构能力-iframe

第二例子的背景是项目分成两个项目，并使用 iframe 来加载子项目，有些微前端的意思，

但是当时之所以这么拆分并不因为要拆分业务线、独立维护与部署，而是项目购买了一个第三方库，需要域名授权才能使用，所以就把部分业务功能放一个主域名下，部分功能部署到另一个域名下，
然后再通过 iframe 来结合成完整的的项目

因此拆分前后还是同一批团队来维护的，对于前端而言就需要同时维护两个项目，这无疑就增加开发的调试成本，还需要思考公共模块的管理问题、由于  Iframe 本身存在一些问题，整体用户体验感降低

所以当时就一直在想办法对这块进行优化

### 解决问题

由于域名限制问题，就没法使用目前比较流行的一些微前端解决方案 如 qiankun、microapp 等框架， 也就是 iframe 的使用避免不了，然后回归到当时这些设计的原因本质其实就是想希望通过主域来完整显示完整的项目内容

于是我想到一个更加简单的方式，就是直接将所有内容直接部署到 iframe 域名下，主域只需要提供一个简单的 iframe 加完整的项目

这种解决方式虽然简单粗暴，但不仅能满足产品的需求，而且规避了微前端的所有问题，无论在用户体验上，还是开发成本都得到极大的提升


## 开发语言-requestIdleCallback

最后是开发语言能力的举证

第一个例子是  JS单线程的原因，对体量大的数据处理会产生阻塞问题，比如项目中加载一万多条的数据，并需要遍历他们进行加工和显示就需等待 7.5s 左右


## 开发语言-埋点

1. 事件埋点对业务代码的侵入太强，污染代码  
2. 产品只是埋点需求的变更，小程序也需要改代码 -> 审核 -> 发布，整个过程不够灵活

为了解决这些问题，我采用了自动化埋点方案，事件的触发时机等同于函数的执行时机，所以扩展小程序App 方法，给组件中的方法添加 hook，劫持方法的调用根据埋点配置判断是否命中自动实现事件收集


## 开发语言-配置化表格与表单

1. 后台系统常见的表单与表格功能和交互都是相似的，但每次开发都需要重新编写相同的代码逻辑
2. 而且表单与表格的实现基本占用了模板部分一半的代码量

为了更加方便和快速和开发这部分的功能，我封装配置化表单与表格组件，通过配置（JSON）的形式来自动渲染出表格与表单


## 岗位工作目标及对应关键举措

能力举证的例子就介绍完了，接下是我短期内我的工作目标是：

1. 全面完成预算项目的优化工作
   
2. 目前团队正在使用 qiankun 框架来实现微前端，我希望小伙伴们不仅仅只会使用，因此近期会做一次相关知识点的分享，主题为《qiankun 实现原理》

自己重点提升的能力是深入到服务层

关键举措 

1. 优化工作：优化的过程会不断探索优化方法，尽量使用最优的方案来解决问题
   
2. 服务层：一方面业余时间多看看相关知识点、另一方面结合工作多与后台同学请教



## 架构能力 Q&A

### 防重复请求思路

- 使用url method 参数 作为每一个请求的唯一标识

- 如果标识重复出现了，说明重复发起了请求，则通过 CancelToken 直接取消当前请求



接下来是架构能力的举证

预算项目使用了一个 Spreadjs 库，与Spread 相关的模块部署在特定域名下，所以主项目使用 iframe 形式对子项目进行加载

说白了就是有点像微前端，所以问题我这里也直接围绕微前端来说

这个我总结的采用微前端后给当前项目带的问题

微前端的好多无疑就是可以拆分精力 ，各自开发与部署，但是如果拆分后还是同一批来开发的，那就是缺点了，也就是一个要要维护两个项目

变成两个项目后增加开发  调试成本了，同一批人，同一个项目，肯定会有相同的部分，要么两边 维护，要么另外想法法子来管理公共部分
因为当前使用 iframe  iframe 又本身主些些问题，影响体验

这些都是在我这个项目产生的问题，再说下微前端的优点，可独立技术栈、独立部署、业务拆解、单独迭代

可前端提到的，如果还同一批人同一团队 来维护这个的时候，这些优点其实意义很小。

所以这个项目即没享受到微前端带来的好处，而又要承担微前端所带来的问题

### 如果解决 url 同步问题

1. iframe 项目监听 url 变化，通过 postMessage 通知父项目

2. history 模式下 pushState 和placeState是 是不是能触发 onpopstate 事件的，通信重写来解决

   ```js
    const bindEventListener = function(type) {
        const historyEvent = history[type];
            return function() {
                const newEvent = historyEvent.apply(this, arguments);
                const e = new Event(type);
                e.arguments = arguments;
                window.dispatchEvent(e);
            return newEvent;
        };
    };
    history.pushState = bindEventListener('pushState');
    history.replaceState = bindEventListener('replaceState');
    ```

### render 方法是否有性能问题

vue 模板本身就是会编译成 render

### render 里的 h 方法返回的是什么

虚拟 Dom

### createElement ?

`createElement`接收参数如下：

- `tag`: {String | Object | Function}表示一个 HTML 标签名、组件选项对象

- `data`: 可选参数，表示 `VNode` 的数据，完整的数据对象如下

  ```js
    {
      // 和`v-bind:class`一样的 API
      'class': {
        foo: true,
        bar: false
      },
      // 和`v-bind:style`一样的 API
      style: {
        color: 'red',
        fontSize: '14px'
      },
      // 正常的 HTML 特性
      attrs: {
        id: 'foo'
      },
      // 组件 props
      props: {
        myProp: 'bar'
      },
      // DOM 属性
      domProps: {
        innerHTML: 'baz'
      },
      // 事件监听器基于 "on"
      // 所以不再支持如 v-on:keyup.enter 修饰器
      // 需要手动匹配 keyCode。
      on: {
        click: this.clickHandler
      },
      // 仅对于组件，用于监听原生事件，而不是组件使用 vm.$emit 触发的事件。
      nativeOn: {
        click: this.nativeClickHandler
      },
      // 自定义指令. 注意事项：不能对绑定的旧值设值
      // Vue 会为您持续追踨
      directives: [
        {
          name: 'my-custom-directive',
          value: '2'
          expression: '1 + 1',
          arg: 'foo',
          modifiers: {
            bar: true
          }
        }
      ],
      // 如果子组件有定义 slot 的名称
      slot: 'name-of-slot'
      // 其他特殊顶层属性
      key: 'myKey',
      ref: 'myRef'
    }
  ```

- `children`：{String | Array} 表示子节点

这里着重了解一下 `createComponent` 第一个参数 `tag` ， `tag` 可以有的类型以及对应的内部处理大致如下

- 如果是 `String` 类型

  - 选判断如果是内置的一些节点，则直接创建一个普通 `VNode`

  - 如果是为已注册的组件名，则通过 `createComponent` 创建一个组件类型的 `VNode`

-  如果是 `tag `一个 Component 类型，则直接调用 `createComponent` 创建一个组件类型的 `VNode` 节点

- 其它值暂不讨论

## 性能优化Q&A

### 响应式原理？

Vue 响应式原理有三个要素组合：侦听器、依赖收集器、Watcher 事件

侦听器是通过遍历 data 属性然后使用 defineProperty 劫持属性的 set/getter 方法

然后每个属性还会实例一个 依赖收集器，这个收集器是一种发布-订阅者模式

依赖收集器具体收集的就是 Watcher 事件

这个Watcher 事件就是具体渲染组件功能的一个对象

整个流程就是组件在首次渲染的时候，会该跟 data 属性，被 get 劫持，然后收集当前的 Watcher事件，这一步就完成事件的收集功能

之后当修改 data 属性时，被 set 劫持，然后从当前派发当前收集到 watcher ，进行组件更新

### defindProperty 的缺点

无法监听数组方法的变化、通过索引修改值也无法监测到

vue是通过重写数据方法来实现监听功能

索引的修改没有办法，只能通过提供的 $set 方法来进行操作

### 重写方法和 $set 具体做了什么？

以数组为例，在处理data属性的时候，都会给当前属性额外添加一个 __ob__属性，这个__ob__是指向当前属性的依赖收集器

### Vue3？

Vue 在初始化的时候使用 proxy 方法代理，关于收集器两个版本的区别

Vue2.0 会为每个属性实例化一个事件收集器 Dep

Vue3.0 则通过全局变量 const targetMap = new WeakMap(); 来做事件收集容器，targetMap 的 key 是代理对象，value 是 depsMap(一个收集事件容器的容器)

depsMap 是 new Map() 结构，代理对象的每个属性收集的事件将存储在这个 depsMap 中，所以找属性收集的事件时，先根据这个属性所属对象从 targetMap 找 depsMap, 在根据具体属性从 depsMap 找事件

在组件渲染的时候，会生成一个 effect 方法，并将当前 effect 保存到全局 activeEffect中，之后在执行渲染操作的时候会读取 data 的属性， 并被 get 劫持，get 方法中将保存在全局的 activeEffect 收集到 depsMap 中

之后当 data 属性被更改时，会被 set 劫持，从 depsMap 取出 effect 并执行

### Object.freeze

- 属性描述符：enumerable、configurable

- 数据描述符：value、writable

- 存储描述符：get、 set

```js
var obj = {
    prop: 42
};

Object.freeze(obj);

Object.getOwnPropertyDescriptor(obj, 'prop')

// {value: 42, writable: false, enumerable: true, configurable: false}
```

### Object.freeze 属性值是对象，可以修改么

可以

### ### Object.freeze 对数组有效么

有

### freeze 和 seal 区别

使用Object.freeze()冻结的对象中的现有属性值是不可变的。用Object.seal()密封的对象可以改变其现有属性值。

- seal 无法新增或修改属性

### 虚拟滚动实现思想

外层定义一个固定高度的 div

内层定义一个所有数据高度的容器

监听外层滚动事情，通过滚动条的高度来判断当前滚动位置应显示的数据位置

然后显示数据那层再通过 transform 偏移量保存与 scrollTop 一致


### 如何虚拟滚动元素高度都不致呢

之有想过这个问题，我的想法是滚动的过程中，可能从遍历元素高度，来判断切换数据的时机

当然切换后的数据高度跟之前也会不致，对于内层的偏移也得考虑当前这个差来进行设置

### 性能指标

- FCP：首次内容绘制

- LCP：最大内容绘制

- FID (First Input Delay)：首次输入延迟，首次输入延迟

### 重排会产生比重绘更大的开销

## 开发语言 Q&A

**requestIdleCallback缺陷**

- 兼容性一般：如 IE、Safari  不支持

- requestIdleCallback FPS只有20，常规是 60，流畅度也是低于常规

**想要实现requestIdleCallback的处理，有2个点需要解决:**

- 如何判断一帧是否有空闲？

  requestAnimationFrame 计算一帧到期时间点

  估算一帧结束时间：`const deadline = raf + 1000/60;`

- 下一次宏任务判断时间是否有超过过期时间 `deadlineTime - performance.now()`

   如果时间则时间任务

**为什么使用 MessageChannel  执行宏任务？**

因为 setTimeout 有阈值，4ms

### 可以用 setTimeout 么？

可以！ 但没有 requestIdleCallback 好

serTimeout 只是粗暴得将任务塞到下一次宏任务执行，会跟下一次宏任务里的任务一起占用执行时间

而requestIdleCallback更温和点，只在一帧的空闲时间去执行

## 无埋点

无埋点也叫全埋点， 通过捕获的形式给 body 添加监听事件，这样所以的 元素点击就能收集到，然后就是传 xpath 给后端，后端进行过滤

## 圈视化埋点

todo


## 关于财经建设这块

我们这份开发的根本是要开发一款程序，这个程序运行的质量、可行性、体验才是我们追求的最终目的
然后再往前推一点则是考虑 更高效开发过程  代码管理 等  

而所有工具及技术 及流程都是服务于其中某一环节的

并不是为了用而用，而是为解决某类问题才去用

我入职到目前八个月左右，就我目前所想，用不到这些技术，反而这些技术增加了开发的复杂度

我个人更倾向于先关注于最基本的东西。 比如代码本身，我更希望让团队都具有一些共识，就是把自己负责的项目  当做自己的作品一样去认真对待，这些不在于要使用多少牛B的技术，而尽量去完善自己写的代码和功能， 把代码写漂亮点。在思考代码优化和性能优化的过程中去自然而然引用一些技术来解决问题

而不是盲目追求或使用某类技术
