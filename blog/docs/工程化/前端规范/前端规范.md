---
sidebar: auto
navbar: false
---


# 前端开发规范

## 交互与样式

### 布局

在缺少 UI 设计的情况下，元素布局应遵循两点：

1. **对齐：** 元素的排列，左右及上下布局时尽量保存对齐，工整

2. **统一**：不同的页面中的相似模块，样式应该保存统一

只要达到上面两点，界面都丑不到哪去

### 样式规则

在编写样式时应遵循以下规则：

- 对于通用型的样式值应该使用样式变量

  为了更方便得使用样式变量，可以借助 Webpack 将样式进行全局注入。eg: `style-resources-loader`

- 为了避免样式污染，Vue 组件中的样式应该添加 `scoped` 属性，如果需要对第三方模块的样式进行覆盖，可以使用 `::v-deep` 或 `/deep/`，推荐使用 `::v-deep`，因为 `/deep/` 在 Vue3.0 项目中会报错，而且网传 `::v-deep` 的编译速度会更快

- 样式的类名统一使用  `kebab-case` (短横线分隔命名)形式。eg:

   ```css
    .app-content{}
   ```

- 为了能直观得区分全局样式和局部样式，全局样式类名应该统一添加 `global` 变量。eg: `.global-[类名]`

- 需要全局对第三方框架的样式进行覆盖时，应该通过特定父级选择器控制影响范围。eg:

   ```scss
    .c-tabs{
      .el-tabs__item{
        line-height: 45px;
      }
    }
   ```

  那么只在 `.c-tabs` 元素下面，`el-tabs` 的样式覆盖才生效

- 样式书写格式

  当属性超过两个时，一个属性一行

  ```css
  /*bad*/
  .layout{ display: block; width: 50px; height: 50px}
  
  /*good*/
  .layout{
    display: block;
    width: 50px;
    height: 50px
  }
  ```

### 界面反馈

使用 `loading`，`toast` 给予用户操作反馈

## 命名

### 文件命名

- 图片命名：kebab_case (下划线分隔命名)

- 文件夹命名：kebab-case (短横线分隔命名)

- 样式文件命名：kebab-case (短横线分隔命名)

- Vue 文件命名统一采用 kebab-case (短横线分隔命名)

  使用组件时应使用 PascalCase（这点可能会存在歧义）. PascalCase 和 kebab-case 的优缺点：

  **优点**

  - 编辑器可以在模板里自动补全组件名，因为 PascalCase 同样适用于 JavaScript

  - `<MyComponent>` 视觉上比 `<my-component>` 更能够和单个单词的 HTML 元素区别开来

  - PascalCase 对 JSX 更友好

  **缺点**

  - 由于 HTML 是大小写不敏感的，如果名称过于简单，可以会与未来新增的元素名冲突

  - 在 DOM 模板中必须仍使用 `kebab-case`。但是基本不用 DOM 模板

- Vux Module 文件统一采用 camelCase (驼峰式命名)

- 其它 JS 文件的命名统一采用 kebab-case (短横线分隔命名)

### 变量命名

- 样式的类名统一使用 kebab-case (短横线分隔命名)

- JS 变量统一采用 camelCase (驼峰式命名)

- 路由命名统一使用 kebab-case (短横线分隔命名)

## HTML

- HTML标签名、类名、标签属性和大部分属性值统一用小写

- 元素属性值使用双引号语法
## JS 规范

### 变量声明

- `var` 存在变量提升的情况，所以使用 `const` 和 `let` 来声明变量

  - 如果变量是不可变的，使用 `const`

  - 如果变量是可变的，使用 `let`

- 变量不要进行链式赋值，变量链式赋值会创建隐藏的全局变量

  ```js
  // bad
  (function example() {
    // 等同于 let a = ( b = ( c = 1 ) );
    let a = b = c = 1
  }())
  
  console.log(a) // throws ReferenceError
  console.log(b) // 1
  console.log(c) // 1
  ```

- 未使用的变量要删除。因为既浪费空间并会给读者造成困扰

### 字符串

- 字符串统一使用单引号的形式 `''`

  ```js
  // bad
  const name = "FE"
  
  // good
  const name = 'FE'
  ```
  
   Webstorm 默认使用双引号, 修改为单引号的方式为：`setting -> Editor -> Code Style -> JavaScript -> Punctuation -> Use [Single] quotes [always]`

- 程序化生成字符串时，请使用模板字符串

  ```js
  const test = 'test'
  
  // bad
  const str = 'a' + 'b' + test
  
  // good
  const str = `ab${test}`
  ```

### 对象

- 使用字面量值创建对象

  ```js
  // bad
  const a = new Object
  
  // good
  const a = {}
  ```

- 使用 `.` 符号来访问对象属性，只有使用变量属性时才使用中括号的形式访问属性

  ```js
  const obj = { name: 'SF', age: 10 }
  const key = 'age'
  
  // bad
  console.log(obj['name'])
  // good
  console.log(obj.name)
  console.log(obj[key])
  ```

- 对象中的属性函数使用简写方式

  ```js
  // bad
  const item = {
    value: 1,
  
    addValue: function (val) {
      return item.value + val
    }
  }
  
  // good
  const item = {
    value: 1,
  
    addValue (val) {
      return item.value + val
    }
  }
  ```

- 用对象属性值的简写方式，让对象更简短且描述更清楚

  ```js
  const name = 'FrontEnd'
  
  // bad
  const item = {
    name: name
  }
  
  // good
  const item = {
    name
  }
  ```

- 同一业务类别的属性应放置在一起，在此基础上简写和非简单对象属性都应分别放在一起, 这样可使代码更加直观

  ```js
  const job = 'FrontEnd'
  const name = 'SF'
  
  // bad
  const item = {
    pageSize: 2,
    sex: 'male',
    name,
    pageNum: 10,
  }
  
  // good
  const item = {
    sex: 'male',
    name,
    // 分页相关的放在一起
    pageSize: 2,
    pageNum: 10,
  }
  
  // bad
  const item = {
    sex: 'male',
    job,
    age: 25,
    name
  }
  
  // good
  const item = {
    job,
    name,
    sex: 'male',
    age: 25
  }
  ```

- 只对非法标识符的属性使用引号，因为通常来说我们认为这样主观上会更容易阅读，这样会带来代码高亮上的提升，同时也更容易被主流 JS 引擎优化

  ```js
  // bad
  const bad = {
    'name': 'SF',
    'other-name': 'Express'
  }
  
  // good
  const good = {
    name: 'SF',
    'other-name': 'Express'
  }
  ```

- 不要直接使用 `Object.prototype` 的方法, 例如 `hasOwnProperty`, `isPrototypeOf` 等方法，因为这些方法可能会被对象自身的同名属性覆盖

  ```js
  // bad
  console.log(object.hasOwnProperty(key))
  
  // good
  console.log(Object.prototype.hasOwnProperty.call(object, key))
  
  // best 如果有多次调用的话
  const has = Object.prototype.hasOwnProperty // 缓存
  console.log(has.call(object, key))
  ```

- 优先使用对象展开运算符 `...` 来做对象浅拷贝而不是使用 `Object.assign`，使用 `对象剩余操作符` 来获取对象剩余属性

  ```js
  // bad
  const original = { a: 1, b: 2 }
  const copy = Object.assign({}, original, { c: 3 })
  
  // good
  const original = { a: 1, b: 2 }
  const copy = { ...original, c: 3 }
  
  const { a, ...other } = copy // other => { b: 2, c: 3 }
  ```

### 数组

- 使用字面量值创建数组

  ```js
  // bad
  const items = new Array()
  
  // good
  const items = []
  ```

- 如果一个数组有多行则要在数组的开括号后和闭括号前使用新行，简洁工整即可

  ```js
  // bad
  const arr = [
    [0, 1], [2, 3], [4, 5]
  ]
  // good
  const arr = [[0, 1], [2, 3], [4, 5]]
  
  // bad
  const objectInArray = [{
    id: 1
  }, {
    id: 2
  }]
  // good
  const objectInArray = [
    { id: 1 },
    { id: 2 }
  ]
  // good 如果对象属性较多
  const objectInArray = [
    {
      id: 1,
      id2: 1,
      id3: 1,
      id4: 1,
    },
    {
      id: 2,
      id2: 2,
      id3: 2,
      id4: 2,
    }
  ]
  ```

- 使用展开运算符 `...` 操作数组的复制  
  使用展开运算符 `...` 将可迭代对象转换为数组

  ```js
  itemsCopy = [...items]
  
  const foo = document.querySelectorAll('.foo')
  const nodes = [...foo]
  ```

- 使用 `Array.from` 来将一个不可迭代类数组对象转换为数组

  ```js
  const arrLike = { 0: 'foo', 1: 'bar', 2: 'baz', length: 3 }
  
  // bad
  const arr = Array.prototype.slice.call(arrLike)
  
  // good
  const arr = Array.from(arrLike)
  ```

- 使用数组的 `map` 等方法时，如果语句单一，使用单行写法省略 `return`

  ```js
  // bad
  [1, 2, 3].map(x => {
    const y = x + 1
    return y
  })
  
  // good
  [1, 2, 3].map(x => x + 1)
  ```

### 解构赋值

- 当需要使用对象的多个属性时，使用解构赋值

  ```js
  // bad
  function getFullName (user) {
    const firstName = user.firstName
    const lastName = user.lastName
  
    return `${firstName} ${lastName}`
  }
  
  // good
  function getFullName (user) {
    const { firstName, lastName } = user
  
    return `${firstName} ${lastName}`
  }
  
  // better
  function getFullName ({ firstName, lastName }) {
    return `${firstName} ${lastName}`
  }
  ```

- 当需要使用数组的多个值时，同样使用解构赋值

  ```js
  const arr = [1, 2, 3, 4]
  
  // bad
  const first = arr[0]
  const second = arr[1]
  
  // good
  const [first, second] = arr
  ```

### 函数

- 不要使用 `Function` 构造函数创建函数, 此方式创建函数和对字符串使用 `eval()` 一样会产生漏洞

  ```js
  // bad
  const add = new Function('a', 'b', 'return a + b')
  
  // bad
  const subtract = Function('a', 'b', 'return a - b')
  ```

- 用圆括号包裹自执行匿名函数

  ```js
  (function () {
    console.log('Hello World')
  }())
  ```

- 不要在条件语句里使用声明函数：

  ```js
  // bad
  if (isUse) {
    function test () {
      // do something
    }
  }
  
  // good
  let test
  if (isUse) {
    test = () => {
      // do something
    }
  }
  ```

- 使用剩余运算符 `...` 代替 `arguments`，因为 `arguments` 只是一个类数组，而 `...` 是一个真正的数组

  ```js
  // bad
  function test () {
    const args = Array.prototype.slice.call(arguments)
    return args.join('')
  }
  
  // good
  function test (...args) {
    return args.join('')
  }
  ```

- 使用参数默认值的注意点：

  ```js
  function handleThings (opts = { }) {
    console.log(opts)
  }
  handleThings(undefined) // {}
  handleThings(null) // null
  ```

  注意函数的默认值处理不了 `null`，所以根据情况使用以下方式会更保险

  ```js
  function handleThings (opts) {
    opts = opts || {}
    // ...
  }
  ```

- 不要更改函数参数

  ```js
  // bad
  function f1 (obj) {
    obj.key = 1
  }
  ```

- 如果语句单一，可以省略花括号

  ```js
  // bad
  [1, 2, 3].map(number => {
    return `A string containing the ${number}.`
  })
  
  // good
  [1, 2, 3].map(number => `A string containing the ${number}.`)
  
  // good 如果返回对象，则在外层加上括号
  [1, 2, 3].map((number, index) => ({
    index: number
  }))
  ```

### 比较运算符

- 使用 `===` 和 `!==` 而非 `==` 和 `!=`

- 条件声明例如 `if` 会用 `ToBoolean` 这个抽象方法将表达式转成布尔值并遵循如下规则

  - 任何对象都等于 `true`

  - Undefined 等于 `false`

  - Null 等于 `false`

  - Booleans 等于 布尔值

  - Numbers 在 `+0`, `-0`, 或者 `NaN` 的情况下等于 `false`, 其他情况是 `true `

  - Strings 为 `''` 时等于 `false`, 否则是 `true`

### 分号

正常情况下为了代码的简洁性及遵循 Standard 的规范，不建议使用分号

但实际工作中还是要注意根据上下行代码来决定要不要使用分号，比如下面的代码

```js
function unSort(arr) {
  const copyList = arr.concat()
  const len = copyList.length
  for (let i = 0; i < len; i++) {
    const changeIndex = Math.floor(Math.random() * len); // 此处不加分号，代码将会运行报错
    [copyList[i], copyList[changeIndex]] = [copyList[changeIndex], copyList[i]]
  }
  return copyList
}
unSort([1,2,3,4,5])
```

:::warning
对于上面代码的情况，应该给上注释，给予提醒
:::

### 不修改内置对象的原型

除了十分特殊情况不修改内置对象的原型. 如果修改，请在项目工程的醒目位置给予说明

### 模块

- 引用同一文件中多个时模块时， 多个 `import` 应书写在一起

```js
// bad
import foo from 'foo'
import { named1, named2 } from 'foo'

// good
import foo, { named1, named2 } from 'foo'
```

- 将所有 `import` 语句放在文件最前方

```js
// bad
import foo from 'foo'
foo.init()

import bar from 'bar'

// good
import foo from 'foo'
import bar from 'bar'

foo.init()
```

- 多行导入应该像多行数组和对象文字一样缩进

```js
// bad
import { moduleA, moduleB, moduleC, moduleD, moduleE } from 'modules'

// good
import {
  moduleA,
  moduleB,
  moduleC,
  moduleD,
  moduleE
} from 'modules'
```

### 其它编码规范

- 大括号

  ```js
  // 不推荐
  if (foo) {
    bar()
  }
  else {
    baz()
  }
  
  // 不推荐
  if (foo)
  {
    bar()
  }
  else
  {
    baz()
  }
  
  // 推荐
  if (foo) {
    bar()
  } else {
    baz()
  }
  ```

- 变量命名

  当命名变通 JS 变量时，使用驼峰式命名（camelCase）

- 逗号风格

  标准风格，逗号放置在当前行的末尾

  ```js
  // bad
  const foo = 1
          ,
          bar = 2
  
  const foo = 1
          , bar = 2
  
  const foo = ['name'
    , 'age']
  
  // good
  const foo = 1,
        bar = 2
  
  const foo = [
    'name',
    'age'
  ]
  ```

- 构造函数首字母大写

  ```js
  // bad
  const fooItem = new foo()
  
  // good
  
  const fooItem = new Foo()
  ```

- 链式调用

  如果单行代码量不多那么链式调用可以放在同一行，增加可读性，如果单代码数量多，则通过换行来进行链式调用

  ```js
  const tar = day().a().b().c()
  // 或
  const tar = day()
          .a()
          .b()
          .c()
  ```

- 空行

  空白行对于分离代码逻辑有帮助，但最大连续空行数为 2

- 空格

  - 操作符两边需要添加空格

    ```js
    // bad
    const sum = 1+2
    
    // good
    const sum = 1 + 2
    ```

  - 对象的 `{ }` 和数组 `[ ]` 两边添加空格  
    对象属性 `:` 后添加添加空格  
    数组属性 `,` 后添加添加空格

    ```js
    // bad
    const obj = {name:'sf'}
    const arr = [1,2]
    // good
    const obj = { name: 'sf' }
    const arr = [ 1, 2 ]
    ```

  - 函数声明的空格

    暂定

  - 条件语句的空格

    暂定

## Vue

Vue 的编写大多是参考 [Vue 风格指南](https://cn.vuejs.org/v2/style-guide/index.html#%E8%A7%84%E5%88%99%E5%BD%92%E7%B1%BB)

### 组件命名

首先总结下 PascalCase 相比 kebab-case 有一些优势：

- 编辑器可以在模板里自动补全组件名，因为 PascalCase 同样适用于 JavaScript。

- `<MyComponent>` 视觉上比 `<my-component>` 更能够和单个单词的 HTML 元素区别开来，因为前者的不同之处有两个大写字母，后者只有一个横线。

- 如果你在模板中使用任何非 Vue 的自定义元素，比如一个 `Web Component`，`PascalCase` 确保了你的 Vue 组件在视觉上仍然是易识别的。

- 不幸的是，由于 HTML 是大小写不敏感的，在 DOM 模板中必须仍使用 kebab-case

基本上面的优缺点比较，目前总结项目中的组合命名规范如下：

- Vue 文件使用横线连接 (kebab-case)

  - 使用组件时应使用 PascalCase

- `components` 下的组件名为多个单词

  组件名应该始终是多个单词的，根组件 App 以及 `<transition>`、`<component>` 之类的 Vue 内置组件除外

```js
// bad
Vue.component('todo', {
  // ...
})
export default {
  name: 'Todo',
  // ...
}

// good
Vue.component('todo-item', {
  // ...
})
export default {
  name: 'TodoItem',
  // ...
}

```


- 组件名应该倾向于完整单词而不是缩写

- 应用特定样式和约定的基础组件 (也就是展示类的、无逻辑的或无状态的组件) 应该全部以一个特定的前缀开头，比如 Base、App 或 V

  ```js
  // bad
  components/
  |- MyButton.vue
  |- VueTable.vue
  |- Icon.vue
  
  // good
  components/
  |- BaseButton.vue
  |- BaseTable.vue
  |- BaseIcon.vue
  components/
  |- AppButton.vue
  |- AppTable.vue
  |- AppIcon.vue
  ```

- 组件名应该以高级别的 (通常是一般化描述的) 单词开头，以描述性的修饰词结尾

```js
// bad
components/
|- ClearSearchButton.vue
|- ExcludeFromSearchInput.vue
|- LaunchOnStartupCheckbox.vue
|- RunSearchButton.vue
|- SearchInput.vue
|- TermsCheckbox.vue

// good

components/
|- SearchButtonClear.vue
|- SearchButtonRun.vue
|- SearchInputQuery.vue
|- SearchInputExcludeGlob.vue
|- SettingsCheckboxTerms.vue
|- SettingsCheckboxLaunchOnStartup.vue
```

- JS/JSX 中的组件名应该始终是 PascalCase

### Prop 定义

Prop 定义应该尽量详细，至少需要指定其类型

```js
// bad
props: ['status']

// good
props: {
  status: String
}

// best
props: {
  status: {
    type: String,
    required: true,
    validator: function (value) {
      return [
        'syncing',
        'synced',
        'version-conflict',
        'error'
      ].indexOf(value) !== -1
    }
  }
}
```

### v-for 设置 key

`key` 尽量是唯一值

### 避免 v-if 和 v-for 用在一起

因为 `v-for` 的优先级比 `v-if` 高，所以总是先完成遍历工作后再执行 `v-if`

```html
// bad
<ul>
  <li
    v-for="user in users"
    v-if="shouldShowUsers"
    :key="user.id"
    >
    {{ user.name }}
  </li>
</ul>

// good
<ul v-if="shouldShowUsers">
  <li
      v-for="user in users"
      :key="user.id"
  >
    {{ user.name }}
  </li>
</ul>
```

### 为组件样式设置作用域

即 `scoped`

### 私有 property 名

对于注入的全局方法和属性及使用 `minxin` 这类公共 API 添加使用 `$_` 前缀。并附带一个命名空间以回避和其它作者的冲突 (比如 `$_yourPluginName_`)

```js
// minixin
var myGreatMixin = {
  // ...
  methods: {
    $mixinUpdate: function () {
      // ...
    }
  }
}
```

### 多个 attribute 的元素

超过二个属性，或者存在单个属性过长时，应该每个 `attribute` 一行

```html
// bad
<img src="https://vuejs.org/images/logo.png" alt="Vue Logo">
<MyComponent foo="a" bar="b" baz="c"/>

// good
<img
  src="https://vuejs.org/images/logo.png"
  alt="Vue Logo"
>
<MyComponent
  foo="a"
  bar="b"
  baz="c"
/>
```

### 模板中的表达式要简单

组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法

```js
// bad
{{
  fullName.split(' ').map(function (word) {
    return word[0].toUpperCase() + word.slice(1)
  }).join(' ')
}}

// good
<!-- 在模板中 -->
{{ normalizedFullName }}
// 复杂表达式已经移入一个计算属性
computed: {
  normalizedFullName: function () {
    return this.fullName.split(' ').map(function (word) {
      return word[0].toUpperCase() + word.slice(1)
  }).join(' ')
  }
}
```

### 指令缩写

指令缩写 (用 `:` 表示 `v-bind:`、用 `@` 表示 `v-on:` 和用 `#` 表示 `v-slot:`)

### data属性注意点

`data` 作为存储组件数据的地方，很容易变得臃肿，过多的属性非常不利后期的开发和维护，所以开发时应该尽可能保持 `data` 的简洁性，所以基于 Vue 的响应式原理，定义属性时应遵循以下原则：

- `data(){}` 应只存放视图中会使用到且会发生变化的属性

- 对于视图中用不到的属性，应直接定义在组件实例中（ `this`）

  ```js
  {
    methods: {
      async fetchList(){
        if(this.loadingST) return
        this.loadingST = true
        await fetch({
          url: '',
          params: {
            id: this.uidST
          }
        })
        this.loadingST = false
      }
    },
    mounted(){
      this.uidST = this.$router.params.id
    }
  }
  ```

  如上面使用的两个属性 `loadingST` 、`uidST`， 可以直接定义在 `this` 中，且为了让开发者直观得知晓当前属性不属于 `data` 中定义的，所以统一在名称后面添加 `ST` 字符（static 缩写）

- 对于视图会使用，但是后期数据又不会发生变化对象类型的数据，使用 `Object.freeze` 进行属性冻结

  ```js
  {
    data(){
      roleTypeDic: Object.freeze([
        { value: 0, label: isZn ? "管理员" : "Administrators",},
        { value: 1, label: isZn ? "子管理员" : "Secondary Administrator",},
        { value: 2, label: isZn ? "普通用户" : "Ordinary users",},
      ])
    }
  }
  ```

- 对于复杂的属性，应该放在 `data` 外进行定义，如果类似的数据比较多，应该放在单独的文件中进行管理

  ```js
  // 放单独的文件
  import {roleTypeDic} from './cofig'
  // 没有访问任何this时，可以放在这里
  let roleTypeDic = Object.freeze([
    { value: 0, label: isZn ? "管理员" : "Administrators",},
    { value: 1, label: isZn ? "子管理员" : "Secondary Administrator",},
    { value: 2, label: isZn ? "普通用户" : "Ordinary users",},
  ])
  {
    data(){
      // 也可以放在最终的 return 之前
      let roleTypeDic = Object.freeze([
        { value: 0, label: isZn ? "管理员" : "Administrators",},
        { value: 1, label: isZn ? "子管理员" : "Secondary Administrator",},
        { value: 2, label: isZn ? "普通用户" : "Ordinary users",},
      ])
      return {
        roleTypeDic
      }
    }
  }
  ```

- 对于同一操作类别的属性，属性定义的位置尽量放在一起

  ```js
    data() {
      let isZn = window.sessionStorage.getItem('lang') === 'zh-CN'
      let roleTypeDic = Object.freeze([
        { value: 0, label: isZn ? "管理员" : "Administrators",},
        { value: 1, label: isZn ? "子管理员" : "Secondary Administrator",},
        { value: 2, label: isZn ? "普通用户" : "Ordinary users",},
      ])
      return {
        // 搜索相关的属性
        tableColumns: tableConfig.call(this),
        searchForm: { roleName: '', roleType: '',},
        // 编辑修改相关的属性
        roleInfoForm: {},
        roleTypeDic,
        editFormVisible: false,
        // 授权相关的属性
        authChecked: [],
        treeProps: {
          children: "children",
          label: "moduleName",
        },
        authorizationData: [],
        authorizationVisible: false,
        defaultExpandedKeys: [],
  
        isLoading: false
      };
    },
  ```

### Vuex

Vuex 不仅仅只是用于维护公共数据或状态，同时它也是充当数据层的存储，api 维护等功能，如果有了解视图容器和数据容器的概念，那么 Vuex 就是充当数据容器的角色。恰当得使用 Vuex 可以减少 Vue 业务组件的代码量，让组件更加纯粹

先看一下例子：

```js
// actions.js 
// actions 常量定义
export default{
  USER_LOGIN_POST: 'USER_LOGIN_POST',
  USER_INFO_PUT: 'USER_INFO_PUT',
}

// mutations.js
// mutations 常量定义
export default{
  USER_INFO_UPDATE: 'USER_INFO_UPDATE',
}
```

```js
// module: userinfo.js
import MUTATIONS from '../const/mutations.js'
import ACTIONS from '../const/actions.js'

const state = {
  userinfo: {}, // 用户登录信息
  roles: [] , // 包含角色
}

const getters = {
  isLogged: state => {
    return !!state.userinfo.userId
  },
}

const mutations = {
  [MUTATIONS.USER_INFO_UPDATE](state, data) {
    state.userinfo = data
  },
}

const actions = {
  async [ACTIONS.USER_LOGIN_POST]({ state, commit, dispatch }, options = {}){
    let { _force = false, ...params } = options
    const { userinfo } = state
    // 如果已经存在 userinfo 则直接取已有的值
    if(!_force && userinfo.mobile){
      return { data: userinfo}
    }
    let res = await fetch()
    if(!res.err){
      commit(MUTATIONS.USER_INFO_UPDATE, res.data)
    }
    return res
  },
  async [ACTIONS.USER_INFO_PUT]({ state, commit, dispatch }, params = {}){
    let { res } = await fetch()
    if(!res.err){
      commit(MUTATIONS.USER_INFO_UPDATE, res.data)
    }
    return res
  }
}

export default {
  namespaced: true,
  state,
  getters,
  mutations,
  actions
}
```

结合例子总结 Vuex 的缩写规范如下：

#### state

`state` 正常情况应该结构尽量扁平，但也不应刻意去拆分对象，如上面的 `state.userinfo` ，在往常的使用中经常会看细分到具体的 `userinfo` 属性，如 `username`,`age` 等等，这么做的只会增加额外的 `mutations` 定义与处理，容易造成冗余

基于 `state.userinfo` 的例子，缺点则是当调用对象属性时，如果当前 `stata` 不是对象结构容易那么就会产生错误  
所以我们需要清晰的定义 `state` 的初始值，及赋值时要保证类型的一致性，使用的时候要做好容错处理

#### mutations

- mutations 使用大写及下划线的常量作为命名。eg: `[目标对象]_UPDATE`，从命名中直接观知道 `我要更新什么`

- mutations 应该是个纯函数，作用只用于更新 state，任何其它副作用的操作应该放在 actions 中

#### actions

- actions 使用大写及下划线的常量作为命名。eg: `[目标对象]_[操作类别]`，从命名中直观知道 `我要怎么操作这个对象`

  如我要对 `userinfo` 这个对象做的 增，删，改，查，那么 actions 命名应该为 `USER_INFO_ADD`, `USER_INFO_DELETE`, `USER_INFO_PUT`, `USER_INFO_GET` 等等的。

  需要注意的是如果涉及到接口，`[操作类别]` 的命名不要被具体的接口请求方式所影响。eg:

  ```js
  async [ACTIONS.USER_INFO_GET]({ state, commit, dispatch }, params = {}){
    let { res } = await http.post() // 接口使用的 post 方法去获取用户信息
    if(!res.err){
      commit(MUTATIONS.USER_INFO_UPDATE, res.data)
    }
    return res
  }
  ```

  对于数据通过接口怎么获取，这是后端的事情，前端还是根据自己的操作性质去命名

- 对于不更新的数据，在 actions 处要做防重复请求处理

  ```js
    async [ACTIONS.DICT_GET]({ state, commit, dispatch }, options = {}){
      let { _force = false, ...params } = options
      const { dict } = state
      // 如果已经存在 dict 则直接取已有的值
      if(!_force && dict.length){
        return { data: dict}
      }
      let res = await fetch()
      if(!res.err){
        commit(MUTATIONS.DICT_UPDATE, res.data)
      }
      return res
    },
  ```

上面有提到 Vuex 作为数据容器，数据如果获取，是否要缓存等操作的也应该放在 Vuex 中处理，Vue 页面只需调用 `ACTIONS.DICT_GET` 接口取数据即可  
换句话说 `ACTIONS.DICT_GET` 只是提供给组件获取 `dict` 数据的接口，至少这个接口具体如果获得数据，组件并不关心  
上面例子加了 `_force` 属性，提供了重新获取数据的途径

**还有一个要注意是上面缓存返回的数据和通过请求返回的数据格式要保持一致**

:::tip
当数据存在更新的可能性时，不建议缓存
:::

## 封装公共代码

对于重复出现的代码要进行封装。如

- 请求接口的错误处理

- 非业务功能的工具类

- 复用的组件

- 重复性工作

### utils/helper

封装工具函数是不可避免的，但是工具函数可分为两类。跟业务无关的通用方法和跟业务相关的通用方法

跟业务无关的如格式转换、拷贝之类的函数统一放在 `util` 文件夹中

跟业务有关系的如状态的枚举映射、业务数据格式转换等等的只要是当前业务扯上关系的放在 `helper` 中

函数的封装要遵循的原则

- 功能单一

- 确定函数的输入输出

- 简洁明了的注释


## 删除无用代码

对于复制过来的文件或者经过迭代产生的无用的代码，一定要删除！！如果实在不舍得某断代码可以使用以下方法进行额外存储：

1. 使用 `git stash` 存储

2. 单独删除某段代码后，单独做次 `git commit` ，写好说明即可


## 识别代码坏味道

下面识别代码坏味道的方法引用至 【 重构改善既有代码的设计 】 这本书中. 给大家帮下参考

- 遇到有歧义的变量。变量名包含了我们对当前代码的理解，好的变量或函数名应该能清楚表达自己的功能和目的，变量名称是代码清晰的关键。

  > 不用太过担心修改变量，会引发其它的错误，因为我们现在使用的编辑器都很强大，可以通过查找或者全局搜索等功能变量被使用的地方

- 重复代码

  一个以上的地点看到相同的程序结构

  解决策略：设法将它们合而为一

- 过长函数或过大的类

  毕竟代码越长越难以理解，至于如何确定哪段代码该进行分解。书中列了几个技巧：1. 寻找注释。2. 条件表达示和循环

  解决策略：拆解函数

- 发散式变化

  一个函数经常因为不同的原因在不同的方向上发生变化，这里我的理解是有可能这个函数做的事情太多，职责不明确（墙头草）

  解决策略：拆解函数，提炼内容

- 霰弹式修改

  每遇到某种变化，你都必须在许多不同的方法/类内做出许多小修改，

  解决策略：应该把这些有相关的代码尽量放在一起

- 夸夸其谈未来性

  企图以各式各样的钩子和特殊情况来处理一些非必要的事情，这么往往造成系统更难理解和维护

  解决策略：该搬就搬吧

- 令人迷惑的暂时字段

  某个函数内部需要因为一特殊情况而加一些额外处理的代码

  解决策略：将这些孤儿放进单独的函数中

- 过多的注释

  不是说不该写注释，但当看到某个函数需要很多注释来说明的时候，往往说明这的功能或流程是复杂的，我们关注的是这么复杂的部分而不是注释本身

- 平行继承体系

  为某个类添加一个子类，必须也为另一个类相应增加一个子类

  解决策略：让一个继承体系的实例引用另一个继承体系的实例

- 冗赘类

  如果一个类的所得不值其身价，它就应该消失。

- 长参数列，依恋情结，数据泥团，基本类型偏执，过度耦合的消息链,不完美的库类，纯稚的数据类，被拒绝的遗赠

**在完成功能编码的时候，一般会在页面自己做下自测，但同时建议回头再梳理一下自己刚写的代码，通常都能发现可以优化的地方**
