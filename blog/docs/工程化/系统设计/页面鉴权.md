# 页面鉴权

本文主要记录一下基于 Vue 开发的页面鉴权

首先关于页面鉴权这块需要考虑哪些问题：

### 路由结构

```js
let menuRoutes = [] // 菜单路由
export const reoutes = [
  {
    path: "/",
    component: Index,
    name: "index",
    children: menuRoutes
  },
  {
    path: "/login",
    component: Login,
    name: 'login'
  },
]
```

假设粟子中的  `Index.vue` 页面包含 `菜单组件+<router-view>` 两个组件 ，这个 `<router-view>` 是用来显示菜单路由的，从页面结构来说所有的菜单路由都是这个 `Index.vue` 的子路由。

要注意的是菜单数据的结构只是用于菜单组件的显示，不要跟路由配置混在一起，假设当前有一个菜单为：

```
        ┌ 页面一
- 菜单  -|
        └ 页面一
```

那么 `menuRoutes` 的路由配置应该是：

```js
let menuRoutes = [
   {
      path: "/menu/page1",
      component: Page1,
      name: 'page1'
   },
   {
      path: "/menu/page2",
      component: Page2,
      name: 'page2'
   },     
]
```

下面这个错误的：

```js
let menuRoutes = [
   {
      path: "/menu",
      component: Menu,
      name: 'menu',
      children: [
         {
            path: "page1",
            component: Page1,
            name: 'page1'
         },
         {
            path: "page2",
            component: Page2,
            name: 'page2'
         },
      ]
   },
]
```

### 如何控制用户可访问的页面

在登录后获取到用户可访问的菜单，一般来说这个菜单结构是树形的，但是只我们关心页面组别的菜单，然后通过遍历得到页面级别的菜单项再匹配得到对应的路由，然后通过 `addRoute('index', config)` 动态添加为 `Index.vue` 的子路由

动态添加完成之后就判断当前访问的路径是否是有效的路由，如果不是则跳到其它任一页面中

:::tip
可以通过 `router.getRoutes()` 获取当前已经注册的所有路由
:::

### 在哪里做鉴权判断

经过实践在 `router.beforeEach` 中做鉴权判断是最佳的方式

```js
router.beforeEach(async (to, from, next) => {
  let doNext = (tar=undefined) => {
      // 执行这个方法，说明已经登录，之后就是判断目标路由是否是已经注册的路由
    let isValidRoute = router.getRoutes().find(item => item.path === to.path)
    if(!isValidRoute){
      let similarRoute = router.getRoutes().find(item => item.path.indexOf(to.path)>-1)
      // 如果没有匹配到当前路由，则尝试跳转到类似路径开头的路由，比如当前路径为 `/menu`，那么可以直接跳到 `/menu/page1` 中
      next(similarRoute ? similarRoute.path: '/404')
    } else {
      next(tar)
    }
  }
  if (['/login'].includes(to.path)) {
    退出登录后要做的事情()
    next()
  } else if(已经登录){ // 已经登录
    doNext()
  } else {
    let { err } = await 静默登录()  // 通过未过期的cookie等方式，尝试直接登录
    if(!err){
      doNext(to.path) // 使用 next(to.path) 而不是使用 next()，重新进入路由进行匹配
    } else {
      next('/login') // 跳到登录页，如果 静默登录() 包含了前端登录页的逻辑，这里可以直接忽略
    }
  }
})
```

注意上面的静默登录成功后，执行的是 `next(to.path)` 面不是 `next()`，因为如果当前从浏览器直接访问需要鉴权的页面，此时还没鉴权，也就意味着当前匹配不到目标路由，那么页面匹配到一个空白页面获者 404 页面，之后即使 `addRoute` 执行成功后， `next()` 也不会进行路由的重新匹配，所以使用 `next(to.path)`，再次跳到相同页面来激活路由匹配

**为什么不在app.vue中做鉴权**

考虑这个场景：点击退出后 `push` 到登录页，再点击返回到首页，此哪并不会重新触发鉴权，`app.vue` 是根页面，并不会重新执行 `mounted` 钩子

**为什么不在Index.vue中做鉴权**

考虑这个场景：因为当用户直接进入到需要鉴权的页面，需要通过异步鉴权后，无法直接匹配页面组件产生页面空白
