# 埋点方案

## Babel 埋点

[Babel-Loader](/Node/Webpack/Babel-Loader.md) 之前有大致的了解过，现在实现可以帮我们注册埋点方法的 Babel 插件

确定思路：

1. 根据函数块级注释判断是否需要自动埋点

2. 引入埋点函数文件

3. 函数插装：将埋点方法插入需要埋点的函数

一个Babel插件的架子:

```js
function autoTracker({types: t, template}) {
    return {
        visitor: { 
            
        }
    };
}

module.exports = autoTracker;
```

可以发现 Babel 插件其实也就是一个函数，它会将 api 通过参数的形式传回来  
它会返回一个对象，对象中有一个 `visitor` 属性，这个属性中声明的函数会在 `transform` 的过程中被调用  

既然我们需要根据函数的注释来判断是否需要自动埋点，那么首先我们得先确认，函数有哪些形式：

```js
// 函数声明
function tracker() {}

// 函数表达式
const tracker = function () {}

// 箭头函数
const tracker = () => {}

// 类方法
class Test {
    tracker() {}
}

```

它们在AST中所对应的类型：

```js
函数声明 = FunctionDeclaration

函数表达式 = FunctionExpression

箭头函数 = ArrowFunctionExpression

类方法 = ClassMethod
```

我们的插件只需处理这些类型：

```js
// 多个类型我们使用|来分隔
function autoTracker({types: t, template}) {
    return {
        visitor: { 
            'FunctionDeclaration|ArrowFunctionExpression|FunctionExpression|ClassMethod'(path, state) {
            }
        }
    };
}

module.exports = autoTracker;
```

可以看到方法中有两个参数：

- path：path 对象中维护了相邻节点的关系，可以通过 path 属性拿到父级和兄弟节点，path 属性中还提供了增删改 AST 的方法。

- state：多个AST节点间需要进行数据传递，则通过 state

### 根据函数块级注释判断是否需要自动埋点

我们通过 [astexplorer](https://astexplorer.net/) 来查看，上面四种函数注释的AST节点类型是什么：

![](./static/miandian/functionDeclaration.png)

![](./static/miandian/class-method.png)

![](./static/miandian/functionExpress.png)

![](./static/miandian/arrowFunctin.png)

从上面的例子可以看到块注释的 AST 类型是 `leadingComments`，上面函数类型的不同的  `leadingComments` 位置也不同

- 函数声明和类函数的 `leadingComments` 就在函数的 AST 节点下，可以使用path直接获取

- 函数表达式和箭头函数的 `leadingComments` 属性在它们的父级节点，因为他们是通过变量声明的方式赋值函数的，也就是我们的注释其实是在 `VariableDeclarator` 节点下

  因此对于 函数表达式和箭头函数 我们需要通过父级节点去查找

查找块节点的代码为：

```js
function autoTracker({types: t, template}) {
    return {
        visitor: {
            'FunctionDeclaration|ArrowFunctionExpression|FunctionExpression|ClassMethod'(path, state) {
                // 先查找同节点下是否有 leadingComments
                const comment = path.get("leadingComments");
                if(comment.length){
                    setAutoTracker(path, state, template, comment.map(item => item.node))
                } else {
                    // 没有则从父级节点查找
                    path.findParent((parentPath) => {
                        const findComment = parentPath.node.leadingComments;
                        if(findComment&&findComment[0]) {
                            setAutoTracker(path, state, template, findComment)
                            return true;
                        }else {
                            return true;
                        }
                    });
                }
            },
        }
    };
}
```