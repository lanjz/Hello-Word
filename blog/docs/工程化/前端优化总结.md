# 前端优化总结

- DNS 预解析

  ```html
  <meta http-equiv="x-dns-prefetch-control" content="on" /> <!--告诉浏览器，当前页面要做DNS预解析-->
  <link rel="dns-prefetch" href="//bdimg.share.baidu.com" /> <!--使用link标签来强制查询特定主机名-->
  ```

- 在脚本中尽量减少DOM操作，避免过度触发重排重绘

- 使用CSS动画代替JS动画

  JS 动画会触发高频率的重排重绘(但是可以使用 `requestAnimationFrame` 优化)

  CSS3动画可以开始CPU硬件加速，简单动画使用 CSS3 实现代码比较简洁，但是强制使用了 GPU 的硬件加速，也会导致浏览器一直处于高负荷运转的状态，这反而会让动画变的卡顿

- 请求开启缓存和压缩`Content-Encoding: gzip`

- 预加载

- 图片懒加载

- 模块、组件按需加载

- 小图片使用 base64 请求请求或图片合并

- CDN 加载资源

- HTTP2.0

- webpack tree shiking、压缩

- 首屏渲染问题

## 图片相关

### 图片懒加载

1. 首先，将图片的地址放在其它属性(data-url)中，而不是 src。

2. 页面加载时根据 scrollTop 的值判断图片是否在可视区域,如果在可视区域，则将 data-url 属性中的值取出存放到src属性中（首屏的图片可以直接加载）。

3. 在滚动过程中，判断图片是否在可视区域，如果在，则将 data-url 属性中的值放到 src 属性中

如何判断图片在可视区域？

1. 根据滚动条高度和图片位置信息进行判断

2. 使用 `Intersection Observer API` (推荐)

### css sprite

css sprite（CSS精灵或者雪碧图），即将几个小的图片合并在一张图片中，利用 `background-position` 来显示对应的图片

这种方式的优点表现在：

- 减少了请求资源的请求

- 可以利用到缓存

这种方式要注意合并图片的大小，过大的话反而适得其反

### base64

优点：无需额外的请求

缺点：额外增加了 HTML/CSS 文件的大小

### 字体图标

优点：无需额外的请求，使用灵活（可以方便得控制大小、颜色等）

## 首屏渲染相关

### 延迟加载 JS 资源

DOM 渲染和 JS 执行是互斥的，所以正常情况下我们应该优化进行 DOM 的渲染，优化方式：

- JS脚本的加载和执行尽量后在文档后面

- 加载外部 JS 资源时添加 `defer` 或 `async` 属性

  - defer 属性：渲染 DOM 的过程将和 JS 脚本加载的过程异步进行，但是 JS 脚本的执行要在所有元素解析完成之后（只适用于外部脚本文件）
  
  - 


https://segmentfault.com/a/1190000019306567