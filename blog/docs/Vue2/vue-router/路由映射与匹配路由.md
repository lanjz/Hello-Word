VueRouter生成路由映射与匹配路由的相关实现是在`src/create-matcher.js`中

`createMatcher`方法定义：

- 参数： 

    - routes: Array<RouteConfig>：`new VueRouter(config)`时转入的路由配置`config`

    - router: VueRouter实例

- 返回值：

  - match: 匹配路由的方法

  - addRoutes: 添加路由映射的方法

## 添加路由映射

源码中定义了三个变量`pathList`、`pathMap`、`nameMap`三个变量来存储路由的映射关系，这个三个变量是声明在`src/create-route-map.js`中定义的`createRouteMap`函数中

- pathList：`Array<string>`，存在是路由配置中`path`属性对应的值

- pathMap：以`path`属性为key，`RouteRecord`类型为值的对象

- nameMap：以`name`属性为key，`RouteRecord`类型为值的对象

### 关于RouteRecord类型

文件位置：`types/router.d.ts`中

```
export interface RouteRecord {
  path: string;
  regex: RegExp;
  components: Dictionary<Component>;
  instances: Dictionary<Vue>;
  name?: string;
  parent?: RouteRecord;
  redirect?: RedirectOption;
  matchAs?: string;
  meta: any;
  beforeEnter?: (
    route: Route,
    redirect: (location: RawLocation) => void,
    next: () => void
  ) => any;
  props: boolean | Object | RoutePropsFunction | Dictionary<boolean | Object | RoutePropsFunction>;
}
```

结合`addRouteRecoed`中`record`的初始值

```
  const record: RouteRecord = {
    path: normalizedPath,
    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),
    components: route.components || { default: route.component },
    instances: {},
    name,
    parent,
    matchAs,
    redirect: route.redirect,
    beforeEnter: route.beforeEnter,
    meta: route.meta || {},
    props: route.props == null
      ? {}
      : route.components
        ? route.props
        : { default: route.props }
  }
```

- `path`：规范化的路径字符串
  ```
 const normalizedPath = normalizePath(
    path,
    parent,
    pathToRegexpOptions.strict
  )
  ```
  它会根据`parent`的值，生成最终的一个路径字符串

-` regex`：利用`path-to-regexp`工具库生成的一个正则表示式，例子：

  ```
  var keys = []
var re = pathToRegexp('/foo/:bar', keys)
// re = /^\/foo\/([^\/]+?)\/?$/i
// keys = [{ name: 'bar', prefix: '/', delimiter: '/', optional: false, repeat: false, pattern: '[^\\/]+?' }]
  ```

  - `components`：Vue组件对象

  - `instances `：表示组件的实例，也是一个对象类型

  - `name`：路由配置项中的`name`属性

  - `parent `：父级的`RouteRecord`，当存在子路由时，递归调用`addRouteRecord`方法，并将当前有的`record`作为`parent`参数传入使用

  ````
  route.children.forEach(child => {
      const childMatchAs = matchAs
        ? cleanPath(`${matchAs}/${child.path}`)
        : undefined
      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs)
    })
  ```

  - `matchAs`：(存在子路由时，如果存在`matchAs`则把`matchAs`与`child.path`根据一些规则合并成一个新的路径字符串保存在`matchAs`属性中)?

  - `redirect`：重定向的配置设置

  - `beforeEnter`：钩子里函数

  - `meta`：面包屑配置

  - `props`：传递参数到组件中的`props`属性中

    - 用法1：平时我们需要获取路由参数（假设是id），是通过`this.$route.params.id`获取的，如果设置`props:true`，则组件内部props属性中添加`props:['id']`，则可以通过`this.id`获取到`id`值

    - 用法2：利用props添加额外参数：`props:{myName: 'lanjz'}`，然后组件内部props属性中添加`props:['myName']`，则可以通过`this.myName`获取到`myName`值


`createRouteMap`函数中遍历路由配置，通过`addRouteRecord`方法向`pathList`、`pathMap`、`nameMap`添加项和映射关系

### 例子

```
const routes2 = [
		{ path: '/foo2', name: 'foo2', component: { name: 'foo2' } },
		{ path: '/baz2/:testparam', name: 'baz2', component: { name: 'baz2' } },
	]

const routes = [
		{
			path: '/',
			name: 'home',
			component: { name: 'home' }
		},
		{
			path: '/foo',
			name: 'foo',
			component: { name: 'foo' },
			children: routes2
		},
		{
			path: '/baz/:testparam',
			name: 'baz',
			component:
				{ name: 'baz' }
		},
		{
			path: '/error/*',
			name: 'error',
			component: { name: 'error' }
			
		},
		{
			path: '*',
			props: true,
			name: 'notFound',
			component: { name: 'notFound' }
		}
	]
```

结果：

```
// pathList
["", "/foo2", "/baz2/:testparam", "/foo", "/baz/:testparam", "/error/*", "*"]

// pathMap
{
		"": RounteRecord,
		"/foo2": RounteRecord,
		"/baz2/:testparam": RounteRecord,
		"/foo": RounteRecord,
		"/baz/:testparam": RounteRecord,
		"/error/*": RounteRecord,
		"*": RounteRecord
	}

// nameMap

{
		"baz": RounteRecord,
		"baz2": RounteRecord,
		"error": RounteRecord,
		"foo": RounteRecord,
		"foo2": RounteRecord,
		"home": RounteRecord,
		"notFound": RounteRecord
	}
```

## 路由匹配

先看下两个重要的类型：`Location`和`Route`

### Location

```
declare type Location = {
  _normalized?: boolean;
  name?: string;
  path?: string;
  hash?: string;
  query?: Dictionary<string>;
  params?: Dictionary<string>;
  append?: boolean;
  replace?: boolean;
}
```

### Route 

```
declare type Route = {
  path: string;
  name: ?string;
  hash: string;
  query: Dictionary<string>;
  params: Dictionary<string>;
  fullPath: string;
  matched: Array<RouteRecord>;
  redirectedFrom?: string;
  meta?: any;
}
```

(这两个很像，后面再补充)?

回到`createMatcher`中的`match`方法，首先调用`normalizeLocation`方法，传入`raw`和`currentRoute`生成新的`location`

### `raw`和`currentRoute`到底是啥

我们的到这两个参数最初是哪传进来的，首先在`src/index.js`中的`init`方法

```
history.transitionTo(
        history.getCurrentLocation(),
        setupHashListener,
        setupHashListener
      )
```

这里的`history.getCurrentLocation()`就是`row`，而这里`history.getCurrentLocation()`为当前url中的hash值，是个字符串

`history.transitionTo`方法内部调用`this.router.match(location, this.current)`

这里的`this.current`就是`currentRoute`，他是根据`createRoute`方法返回的一个`Route`类型

无论是`Route`还是`row`，它们可能存在相同的属性，所以通过`normalizeLocation`方法，将他们属性合并

合并的规则是：

- path：优先取`row`

- query：`row`会覆盖`Route`

- hash：优先取`row`

### 得到合并到后`location`，开始查找对应的`RouteRecord`对象

- 通过`name`查看

  首先通过`name`属性去`nameMap`查看对应的`record`，如果没有找到则通过`_createRoute(null, location)`生成一个新的`route`并返回，如果存在则合并`currentRoute`中的`params`参数，通过
`fillParams(record.path, location.params, `named route "${name}"`)`生成新的`location.path`，最后返回`_createRoute(record, location, redirectedFrom)`的结果

- 通过`path`查找

  我们得到的`path`是一个真实路径，而`record`中的`path`可能会有`params`，因此需要对所有`pathList`做顺序匹配，如果匹配到则也通过`_createRoute(record, location, redirectedFrom)`去生成一条新路径。


