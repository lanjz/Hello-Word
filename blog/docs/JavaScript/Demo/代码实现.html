<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>

</body>
<script>
  /*防抖*/
  function de(fn, delay) {
    let time = null
    return () => {
      clearTimeout(time)
      time = setTimeout(fn.bind(null, ...arguments), delay)
    }
  }

  /*劫流*/
  function de(fn, delay) {
    let run = false
    return () => {
      if(run) return
      run = true
      fn.call(null, ...arguments)
      setTimeout(() => {
        run = false
      }, delay)
    }
  }

  /*new 实现*/
  function _new(fn, ...arg) {
    let obj = Object.create(fn.prototype)
    fn.call(obj, ...arguments)
    return fn
  }

  /*LazyMan*/
  function LazyMan(name) {
    this.stack = []
    Promise.resolve().then(() => {
      this.run()
    })
    console.log(' Hi I am ' + name)
  }

  LazyMan.prototype.eat = function (data) {
    this.stack.push(() => {
      console.log(`I am eating ${data}`)
    })
    return this
  }
  LazyMan.prototype.sleep = function (time) {
    this.stack.push(() => {
      setTimeout(() => {
        console.log(`等待了${time}秒...`)
      }, time * 1000)
    })
    return this
  }
  LazyMan.prototype.sleepFirst = function (time) {
    this.stack.unshift(() => {
      setTimeout(() => {
        console.log(`等待了${time}秒...`)
      }, time * 1000)
    })
    return this
  }
  LazyMan.prototype.run = async function (time) {
    let shift = this.stack.shift()
    while (shift) {
      await shift()
      shift = this.stack.shift()
    }
  }

  function LM() {
    return new LazyMan(...arguments)
  }

  LM('Tony').eat('lunch').eat('dinner').sleepFirst(5).sleep(10).eat('junk food');

  /*深铐贝*/
  function tarObk() {
    let sym = Symbol('我是一个Symbol')
    const ob = {
      // number: 123,
      // string: '深铐贝',
      // boolean: true,
      // undefined: undefined,
      // null: null,
      obj: {
        name: '我是一个对象',
        id: 1
      },
      arr: [0, 1, 2],
      func: (() => {
        let i = 1
        return () => {
          i = i + 1
          console.log('当前i的值：' + i)
        }

      })(),
      date: new Date(0),
      reg: new RegExp('/我是一个正则/ig'),
      err: new Error('我是一个错误'),
      [sym]: 'key是个symbol',
      symbol: sym
    }
    ob.self = ob
    this.ob = ob
  }

  tarObk.prototype.test = 'TAROBK'
  let oldObj = new tarObk()
  console.log(oldObj)

  function deepCopy(obj) {
    let typeMap = new WeakSet() // 处理循环引用的问题
    let walk = (tar) => {
      if(typeof tar !== 'object') { // 如果是基本类型，直接返回
        return tar
      }
      if(typeMap.has(tar)) { // 循环引用的对象
        return tar
      }
      typeMap.add(tar)
      let tem = {} // 默认copy对象，所以初始化一个对象
      let type = Object.prototype.toString.call(tar)
      const Constructor = tar.constructor
      if(Constructor === RegExp) {
        return new Constructor(tar)
      } else if(Constructor === Date) {
        return new Constructor(tar.getTime())
      } else if(Constructor === Error) {
        return new Constructor(tar)
      }
      if(type === '[object Function]') { // 函数的就不用完成copy了
        return tar
      } else if(type === '[object Array]') { // 如果是数组的话，初始一个数组
        tem = []
      }
      Object.keys(tar).forEach(key => { // 无法遍历 Symbol 类型
        tem[key] = walk(tar[key])
      })
      let getSymbol = Object.getOwnPropertySymbols(tar) || [] // 对于Symbol 额外做处理
      getSymbol.forEach(item => {
        tem[item] = walk(tar[item])
      })
      return tem
    }
    return walk(obj)
  }

  let newObj = deepCopy(oldObj)
  newObj.__proto__ = oldObj.__proto__
  console.log('new', newObj)
</script>
</html>