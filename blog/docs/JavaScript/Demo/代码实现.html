<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>

</body>
<script>
  /*防抖*/

  function de(fn, delay) {
    let time = null
    return () => {
      clearTimeout(time)
      time = setTimeout(fn.bind(null, ...arguments), delay)
    }
  }

  /*劫流*/
  function de(fn, delay) {
    let run = false
    return () => {
      if(run) return
      run = true
      fn.call(null, ...arguments)
      setTimeout(() => {
        run = false
      }, delay)
    }
  }

  /*new 实现*/
  function _new(fn, ...arg) {
    let obj = Object.create(fn.prototype)
    fn.call(obj, ...arguments)
    return fn
  }

  /*LazyMan*/
  function LazyMan(name) {
    this.stack = []
    Promise.resolve().then(() => {
      this.run()
    })
    console.log(' Hi I am ' + name)
  }

  LazyMan.prototype.eat = function (data) {
    this.stack.push(() => {
      console.log(`I am eating ${data}`)
    })
    return this
  }
  LazyMan.prototype.sleep = function (time) {
    this.stack.push(() => {
      setTimeout(() => {
        console.log(`等待了${time}秒...`)
      }, time * 1000)
    })
    return this
  }
  LazyMan.prototype.sleepFirst = function (time) {
    this.stack.unshift(() => {
      setTimeout(() => {
        console.log(`等待了${time}秒...`)
      }, time * 1000)
    })
    return this
  }
  LazyMan.prototype.run = async function (time) {
    let shift = this.stack.shift()
    while (shift) {
      await shift()
      shift = this.stack.shift()
    }
  }

  function LM() {
    return new LazyMan(...arguments)
  }

  LM('Tony').eat('lunch').eat('dinner').sleepFirst(5).sleep(10).eat('junk food');

  /*深铐贝*/
  function tarObk() {
    let sym = Symbol('我是一个Symbol')
    const ob = {
      // number: 123,
      // string: '深铐贝',
      // boolean: true,
      // undefined: undefined,
      // null: null,
      obj: {
        name: '我是一个对象',
        id: 1
      },
      arr: [0, 1, 2],
      func: (() => {
        let i = 1
        return () => {
          i = i + 1
          console.log('当前i的值：' + i)
        }

      })(),
      date: new Date(0),
      reg: new RegExp('/我是一个正则/ig'),
      err: new Error('我是一个错误'),
      [sym]: 'key是个symbol',
      symbol: sym
    }
    // ob.self = ob
    this.ob = ob
  }

  tarObk.prototype.test = 'TAROBK'
  let oldObj = new tarObk()
  console.log(oldObj)

  function deepCopy(obj) {
    let typeMap = new WeakSet() // 处理循环引用的问题
    let walk = (tar) => {
      if(typeof tar !== 'object') { // 如果是基本类型，直接返回
        return tar
      }
      if(typeMap.has(tar)) { // 循环引用的对象
        return tar
      }
      typeMap.add(tar)
      let tem = {} // 默认copy对象，所以初始化一个对象
      let type = Object.prototype.toString.call(tar)
      const Constructor = tar.constructor
      if(Constructor === RegExp) {
        return new Constructor(tar)
      } else if(Constructor === Date) {
        return new Constructor(tar.getTime())
      } else if(Constructor === Error) {
        return new Constructor(tar)
      }
      if(type === '[object Function]') { // 函数的就不用完成copy了
        return tar
      } else if(type === '[object Array]') { // 如果是数组的话，初始一个数组
        tem = []
      }
      Object.keys(tar).forEach(key => { // 无法遍历 Symbol 类型
        tem[key] = walk(tar[key])
      })
      let getSymbol = Object.getOwnPropertySymbols(tar) || [] // 对于Symbol 额外做处理
      getSymbol.forEach(item => {
        tem[item] = walk(tar[item])
      })
      return tem
    }
    return walk(obj)
  }

  let newObj = deepCopy(oldObj)
  newObj.__proto__ = oldObj.__proto__
  console.log('new', newObj)
  /*实现instanceOf*/
  console.log('----------------------实现instanceOf------------------------')

  function isInstanceOf(obj, parent) {
    while (obj.__proto__) {
      if(obj.__proto__ === parent.prototype) {
        return true
      }
      obj = obj.__proto__
    }
    return false
  }

  console.log(isInstanceOf)
  /*实现call、apply、bind*/
  console.log('---------------实现call、apply、bind------------------------')

  function myCall(fn, obj, ...arg) {
    obj.fn = fn
    return obj.fn(...arg)
  }

  function showAge(name) {
    console.log(arguments)
    console.log(name + this.age)
  }

  function myBind(fn, obj, ...arg1) {

    return (...arg2) => {
      obj.doFn = fn
      return obj.doFn(...arg1, ...arg2)
    }
  }

  var my = myBind(showAge, {age: 100}, 1, 2, 3)
  my('aaa')

  /*实现JSON.stringify()*/
  console.log('...........实现JSON.stringify()............')

  function myStringify(obj) {
    let weak = new WeakSet()
    let walk = (data) => {
      if(typeof data !== 'object') {
        return data
      }
      // 实现特性 5
      if(weak.has(data)) {
        throw new Error('出现了循环了')
        return
      }
      weak.add(data)
      let type = Object.prototype.toString.call(data)
      if(type !== '[object Array]' && type !== '[object Object]') { // 简单实现特性 2
        return data.toString()
      }
      let tem = []
      // Object.keys 会自动过滤的 symbol 的key，实现特性5
      Object.keys(data).forEach(item => {
        let getTypeOf = typeof data[item]
        if(getTypeOf === 'symbol' || getTypeOf === 'function' || getTypeOf === undefined) return // 实现特性 4
        if(type === '[object Array]') {
          tem.push(walk(data[item]))
        } else if(type === '[object Object]') {
          tem.push(`${item}:` + walk(data[item]))
        }
      })
      if(type === '[object Array]') {
        return `[${tem.join()}]`
      } else if(type === '[object Object]') {
        return `{${tem.join()}}`
      }

    }
    return walk(obj)
  }

  let testMyStringify = {
    a: new Number(1234),
    b: 'ac',
    arr: [1, 2, 3, 4],
  }
  // testMyStringify.self = testMyStringify
  console.log('myStringify({})', myStringify(testMyStringify))
  console.log('myStringify({})', JSON.stringify(testMyStringify))

  /*实现Promise*/
  function _promise(fn) {
    this.doResolve = null
    this.doReject = null
    this.sonResolve = null // then 返回的 promise
    let _this = this
    setTimeout(() => {
      fn(this._resolve.bind(_this), this._reject.bind(_this))
    })
  }

  _promise.prototype._resolve = function (data) {
    if(!this.doResolve) return
    let res = this.doResolve(data)
    this.sonResolve(res)
  }
  _promise.prototype._reject = function (data) {
    if(!this.doReject) return
    let res = this.doReject(data)
  }
  _promise.prototype.then = function (data) {
    this.doResolve = data
    return new _promise(resolve => {
      this.sonResolve = resolve
    })
  }
  _promise.prototype.catch = function (data) {
    this.doReject = data
  }
  let pro = new _promise((resolve, reject) => {
    setTimeout(() => {
      resolve('哈哈')
    }, 2000)
  })
  pro.then(res => {
    console.log('第一个then', res)
    return '自定义Promise', res
  })
    .then(res => {
      console.log('第二个then', res)
    })
  /*模板引擎实现*/
  console.log('----------模板引擎实现 TODO-------------')

  function render(template, data) {
    let left = 0
    let right = 0
    let tem = ''
    let result = ''
    for (let i of template) {
      if(i === '{') {
        if(left === 2){
          result += '{'
        } else {
          left++
        }
      } else if(i === '}') {
        right++
        if(left === 2&&right === 2 && tem){
          result+=(data[tem]||undefined)
          left = 0
          right = 0
          tem = ''
        } else if(left !==2){
          while (left){
            result+='{'
            left--
          }
          if(tem){
            result +=tem
            tem=''
          }
          while (right){
            result+='}'
            right--
          }
        }
      } else if(left === 2){
        tem+=i
      } else {
        result += i
      }
    }
    return result; // 如果模板没有模板字符串直接返回
  }
  let temp = '<div>}}{}{{{name}}}dfkjlksfjlsf{}}{{age}}</div>'
  let obj = {
    name: 'lanjz',
    age: 19
  }
  console.log(render(temp, obj))
</script>
</html>