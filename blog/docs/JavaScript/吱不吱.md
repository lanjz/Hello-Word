# 问答

## for...of

## 如果团队间复用组件

## (fn)立即执行函数

## Foo.prototype.constructor === Foo

## 判断输出

**Q**

```js
if (!("a" in window)) {
    var a = 1;
}
alert(a) // undefined
```

注意点：

- 所有的变量声明都在范围作用域的顶部

  ```js
  alert("a" in window);
  var a
  // 等价于
  var a
  alert("a" in window);
  ```

- 变量声明被提前了，但变量赋值没有，因为这行代码包括了变量声明和变量赋值，进入执行上下文会声明这些变量（除了函数声明），运行执行上下文才会对变量赋值

- 所有的全局变量都是 `window` 的属性，语句` var a = 1` ;等价于 `window.a = 1`

**Q**

```js
var a = 1,
    b = function a(x) {
        x && a(--x);
    };
alert(a) // 1
```

题目注意点：

- 变量提升中，函数声明会覆盖，同名的变量

- 变量提升中，声明及函数表达式不会覆盖之前的同名变量

题目中的函数表达式 `a` 不会覆盖之前 `var a` ，代码等价于下面的代码：

```js
var a = 1,
    b = function(x) {
        x && b(--x);
    };
alert(a)
```

**Q**

```js
function value(){
    return 1;
}
var value;
alert(typeof value); //"function"
```

注意点：

- 变量提升中，函数声明会覆盖，同名的变量

- 变量提升中，声明及函数表达式不会覆盖之前的同名变量

```js
function value(){
    return 1;
}
var value = 1;
alert(typeof value);    //"number"
```

注意点：

- 变量提升中，函数声明会覆盖，同名的变量

- 变量提升中，声明及函数表达式不会覆盖之前的同名变量

当进入变量赋值阶段 `value` 被生新定义，上面代码等价于：

```js
function value(){
    return 1;
}
value = 1;
```

下面这个代码运行结果是一样的

```js
var value = 1;
function value(){
    return 1;
}
alert(typeof value) // //"number"
```