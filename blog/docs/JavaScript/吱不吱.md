# 问答

## for...of

## 如果团队间复用组件

## (fn)立即执行函数

## Foo.prototype.constructor === Foo

## 判断输出

**Q**

```js
if (!("a" in window)) {
    var a = 1;
}
alert(a) // undefined
```

注意点：

- 所有的变量声明都在范围作用域的顶部

  ```js
  alert("a" in window);
  var a
  // 等价于
  var a
  alert("a" in window);
  ```

- 变量声明被提前了，但变量赋值没有，因为这行代码包括了变量声明和变量赋值，进入执行上下文会声明这些变量（除了函数声明），运行执行上下文才会对变量赋值

- 所有的全局变量都是 `window` 的属性，语句` var a = 1` ;等价于 `window.a = 1`

**Q**

```js
var a = 1,
    b = function a(x) {
        x && a(--x);
    };
alert(a) // 1
```

题目注意点：

- 变量提升中，函数声明会覆盖同名的变量

- 变量提升中，声明及函数表达式不会覆盖之前的同名变量

- 命名表达式的名字只在新定义的函数作用域内有效，因为规范规定了标示符不能在外围的作用域内有效

题目中的函数表达式 `a` 不存在于全局上下文的，也就不会覆盖之前 `var a` ，代码等价于下面的代码：

```js
var a = 1,
    b = function(x) {
        x && b(--x);
    };
alert(a)
```

**Q**

```js
function value(){
    return 1;
}
var value;
alert(typeof value); //"function"
```

注意点：

- 变量提升中，函数声明会覆盖，同名的变量

- 变量提升中，声明及函数表达式不会覆盖之前的同名变量

```js
function value(){
    return 1;
}
var value = 1;
alert(typeof value);    //"number"
```

注意点：

- 变量提升中，函数声明会覆盖，同名的变量

- 变量提升中，声明及函数表达式不会覆盖之前的同名变量

当进入变量赋值阶段 `value` 被生新定义，上面代码等价于：

```js
function value(){
    return 1;
}
value = 1;
```

下面这个代码运行结果是一样的

```js
var value = 1;
function value(){
    return 1;
}
alert(typeof value) // //"number"
```

**Q**

```js
function a(x) {
    return x * 2;
}
var a;
alert(a); // function a ()
```

注意点：

- 变量声明不会影响同名的变量

**Q**

```js
function b(x, y, a) {
    arguments[2] = 10;
    alert(a);
}
b(1, 2, 3)
```

活动对象是在进入函数上下文时刻被创建的，它通过函数的 `arguments` 属性初始化。`arguments` 属性的值是`Arguments` 对象：

```js
AO = {
  arguments: <ArgO>
}
```

`Arguments` 对象是活动对象的一个属性，它包括如下属性：

- `callee` — 指向当前函数的引用

- `length` — 真正传递的参数个数

- `properties-indexes` (字符串类型的整数) 属性的值就是函数的参数值(按参数列表从左到右排列).`properties-indexes` 内部元素的个数等于 `arguments.length` . `properties-indexes` 的值和实际传递进来的参数之间是共享的

这个共享其实不是真正的共享一个内存地址，而是2个不同的内存地址，使用 JavaScript 引擎来保证2个值是随时一样的，当然这也有一个前提，那就是这个索引值要小于你传入的参数个数，也就是说如果你只传入2个参数，而还继续使用 `arguments[2]` 赋值的话，就会不一致，例如：

```js
function b(x, y, a) {
    arguments[2] = 10;
    alert(a); // undefined
}
b(1, 2)
```

此时 `arguments.length` 其实是 2 个， `arguments[2]` 与参数 `a` 不是一个东西，所以赋值 `10` 以后， `alert(a)` 的结果依然是 `undefined` ，而不是 `10` ， 但如下代码弹出的结果依然是 `10`，因为和 `a` 没有关系

```js
function b(x, y, a) {
    arguments[2] = 10;
    alert(arguments[2]); // 10
}
b(1, 2)
```

**Q**

```js
function a() {
    alert(this); // [object Windo
}
a.call(null)
```

如果 `call` 第一个参数传入的对象调用者是 `null` 或者 `undefined` 的话，`call` 方法将把全局对象（也就是 `window` ）作为 `this` 的值。所以，不管你什么时候传入 `null` ，其 `this` 都是全局对象 `window` ，所以该题目可以理解成如下代码：

```js
function a() {
    alert(this);
}
a.call(window);
```