# 预渲染

[`PrerenderSPAPlugin`](https://github.com/chrisvfritz/prerender-spa-plugin) 插件的使用

```js
// 首先，这是插件的入口
const path = require('path')
const PrerenderSPAPlugin = require('prerender-spa-plugin')
const Renderer = PrerenderSPAPlugin.PuppeteerRenderer

module.exports = {
  plugins: [
      new PrerenderSPAPlugin({
        // 必需 - webpack 打包输出路径
        staticDir: path.join(__dirname, 'dist'),
        
        // 可选 - 渲染后输出的目录位置，默认就是 staticDir 目录
        outputDir: path.join(__dirname, 'prerendered'),
        
        // 可选 - 启动的主页
        // 默认就是 打包输入路径里的 `index.html`
        indexPath: path.join(__dirname, 'dist', 'index.html'),
        
        // 必需 - 要预渲染哪些页面
        routes: [ '/', '/about', '/some/deep/nested/route' ],
        
        // 可选 - 允许在内容在最终写入到文件之前进行定义的修改，postProcess 提供一个参数 renderedRoute
        // renderedRoute 应该是与当前渲染内容相关的信息，通过修改它还修改最终输出的内容
        // renderedRoute 包含的属性:
        // {
        //   route: String, // Where the output file will end up (relative to outputDir)？
        //   originalRoute: String, // The route that was passed into the renderer, before redirects.
        //   html: String, // 当前路径下的 HTML
        //   outputPath: String // 当路由页面的输出路径
        // }
        postProcess (renderedRoute) {
          // 忽略任何重定向
          renderedRoute.route = renderedRoute.originalRoute
          // 删除空格. (Don't use this in production)
          renderedRoute.html = renderedRoute.html.split(/>[\s]+</gmi).join('><')
          // 如果目录名以.html文件扩展名结尾，则从输出路径中删除/index.html.
          // 例如: /dist/dir/special.html/index.html -> /dist/dir/special.html
          if (renderedRoute.route.endsWith('.html')) {
            renderedRoute.outputPath = path.join(__dirname, 'dist', renderedRoute.route)
          }
          return renderedRoute
        },
        
        // 可选 - Uses html-minifier (https://github.com/kangax/html-minifier)
        // 输出渲染结果的优化配置.
        // Option reference: https://github.com/kangax/html-minifier#options-quick-reference
        minify: {
          collapseBooleanAttributes: true,
          collapseWhitespace: true,
          decodeEntities: true,
          keepClosingSlash: true,
          sortAttributes: true
        },
        
        // Server configuration options.
        // server 属性在最终输出的纯静态的页面中是不起作用的，他的作用仅限于你项目中有数据请求是从接口哪里拿到的
        // 防止插件运行过程中因为数据拿不到导致报错，渲染失败情况
        server: {
          // Normally a free port is autodetected, but feel free to set this if needed.
          port: 8001,
          // proxy 接口代理，与vue的devServer相同
          proxy:{
            '/api': {
              target:'http://www.lanjz.com',
              changeOrigin:true, //是否跨域
            },
          }
        },
        
        // 实际使用的渲染器
        // Available renderers: https://github.com/Tribex/prerenderer/tree/master/renderers
        renderer: new Renderer({
          // 可选 - 要注入到全局环境的中变量名，这个变量名的值为下面 inject 配置内容
          injectProperty: '__PRERENDER_INJECTED',
          // 可选 - __PRERENDER_INJECTED 的值.
          inject: {
            foo: 'bar'
          },
          
          // 可选 - 默认为0，没有限制
          // 异步渲染路由.
          // 使用它来限制并行渲染的路由数量
          maxConcurrentRoutes: 4,
          
          // 可选 - 在特定的事件触发后再显示内容
          // 如：当前配置表示执行 document.dispatchEvent(new Event('custom-render-trigger')) 事件后再显示内容
          renderAfterDocumentEvent: 'custom-render-trigger',
          
          // 可选 - 检测到特别元素时再呈现内容。 使用 `document.querySelector`
          renderAfterElementExists: 'my-app-element',
          
          // 可选 - 等待多久时间后再渲染
          // 不推荐使用
          renderAfterTime: 5000, // Wait 5 seconds.
          
          // Other puppeteer options.
          // (See here: https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#puppeteerlaunchoptions)
          headless: false // Display the browser window when rendering. Useful for debugging.
        })
      })
  ]
}


```

## 工作方式

插件另启动一个 `webpack-dev-server` 服务，将完整的项目运行在无头浏览器中，再使用 `puppeteer` 把对应路由的页面爬取下来

> [vue预渲染插件prerender-spa-plugin配置](https://bbs.qyyt.com/post/97/)