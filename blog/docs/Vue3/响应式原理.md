# 响应式原理

回顾下 2.0 响应式原理实现过程：

1. Vue 在初始化的时候会遍历 `data` 数据，对于每个属性执行 `defineReactive` 方法，这里方法主要做以下两个事情：

  - 实例化一个事件器 `Dep`
  
  - 使用 `Obejct.definedPropery()` 方法代理属性并添加 `set` 和 `get` 方法， `get` 中添加了收集 `Watcher` 的逻辑，而 `set` 则是包含了执行 `Watcher` 的逻辑

2. 在组件渲染的时候，会实例化一个 `Watcher` 实例，并将当前 `Watcher` 实例到全局属性 `Dep.target`中，之后在执行渲染操作的时候会读取 `data` 的属性， 并被 `get` 劫持，`get` 方法中将保存在全局的 `Watcher` 收集到 `dep` 中

3. 之后当 `data` 属性被更改时，会被 `set` 劫持，然后执行 `Watcher` 中的更新方法

3.0 中改用了 Proxy 方法，以 `data` 属性来品一下怎么玩的

源码追踪： `mountComponent(n2, container) => setupComponent(instance) => setupStatefulComponent() => finishComponentSetup(instance) => applyOptions(instance, Component) => resolveData(instance, dataOptions, publicThis)`

`resolveData` 就是处理 `data` 属性的地方

```js
  function resolveData(instance, dataFn, publicThis) {
    // 现在data属性是函数 
    if ( !isFunction(dataFn)) {
      warn(`The data option must be a function. ` +
        `Plain object usage is no longer supported.`);
    }
    // 获取 data 的值
    const data = dataFn.call(publicThis, publicThis);
    // data函数返回值不能是函数
    if ( isPromise(data)) {
      warn(`data() returned a Promise - note data() cannot be async; If you ` +
        `intend to perform data fetching before component renders, use ` +
        `async setup() + <Suspense>.`);
    }
    // data函数返回值必需是对象
    if (!isObject(data)) {
      warn(`data() should return an object.`);
    }
    else if (instance.data === EMPTY_OBJ) {
      // 设置代理
      instance.data = reactive(data);
    }
    else {
      // existing data: this is a mixin or extends.
      extend(instance.data, data);
    }
  }
```

```js
  function reactive(target) {
    // if trying to observe a readonly proxy, return the readonly version.
    if (target && target["__v_isReadonly" /* IS_READONLY */]) {
      return target;
    }
    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers);
  }

  function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers) {
    if (!isObject(target)) {
      {
        console.warn(`value cannot be made reactive: ${String(target)}`);
      }
      return target;
    }
    // target is already a Proxy, return it.
    // exception: calling readonly() on a reactive object
    if (target["__v_raw" /* RAW */] &&
      !(isReadonly && target["__v_isReactive" /* IS_REACTIVE */])) {
      return target;
    }
    // target already has corresponding Proxy
   // 使用 new WeakMap() 保存当前代理
    const proxyMap = isReadonly ? readonlyMap : reactiveMap;
    
    const existingProxy = proxyMap.get(target);
    // 如果已经存在则是直接返回
    if (existingProxy) {
      return existingProxy;
    }
    // only a whitelist of value types can be observed.
    const targetType = getTargetType(target);
    if (targetType === 0 /* INVALID */) {
      return target;
    }
    const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);
    proxyMap.set(target, proxy);
    return proxy;
  }
```

当前例子执行的代理 `const proxy = new Proxy(target, baseHandlers)`, `baseHandlers` 就是Proxy的处理器对象，根据上下文找到 `baseHandlers` 的定义：

```js
  const mutableHandlers = {
    get,
    set,
    deleteProperty,
    has,
    ownKeys
  }
  const get = /*#__PURE__*/ createGetter();

  function createGetter(isReadonly = false, shallow = false) {
    return function get(target, key, receiver) {
      // 如果当前访问 __v_isReactive 返回 true
      if (key === "__v_isReactive" /* IS_REACTIVE */) {
        return !isReadonly;
      }
      // 如果当前访问 __v_isReadonly 返回 false
      else if (key === "__v_isReadonly" /* IS_READONLY */) {
        return isReadonly;
      }
      // 如果当前访问 __v_raw  从缓存中找对应的值，先不关心这个上
      else if (key === "__v_raw" /* RAW */ &&
        receiver === (isReadonly ? readonlyMap : reactiveMap).get(target)) {
        return target;
      }
      // 如果当前访问的数组中的属性，且是 ['includes', 'indexOf', 'lastIndexOf'] 中的一种,则调用重写的方法
      const targetIsArray = isArray(target);
      if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      const res = Reflect.get(target, key, receiver);
      if (isSymbol(key)
        ? builtInSymbols.has(key)
        : key === `__proto__` || key === `__v_isRef`) {
        return res;
      }
      if (!isReadonly) {
        track(target, "get" /* GET */, key);
      }
      if (shallow) {
        return res;
      }
      if (isRef(res)) {
        // ref unwrapping - does not apply for Array + integer key.
        const shouldUnwrap = !targetIsArray || !isIntegerKey(key);
        return shouldUnwrap ? res.value : res;
      }
      if (isObject(res)) {
        // Convert returned value into a proxy as well. we do the isObject check
        // here to avoid invalid value warning. Also need to lazy access readonly
        // and reactive here to avoid circular dependency.
        return isReadonly ? readonly(res) : reactive(res);
      }
      return res;
    };
  }
 const set = /*#__PURE__*/ createSetter()
  function createSetter(shallow = false) {
    return function set(target, key, value, receiver) {
      const oldValue = target[key];
      if (!shallow) {
        value = toRaw(value);
        if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        }
      }
      const hadKey = isArray(target) && isIntegerKey(key)
        ? Number(key) < target.length
        : hasOwn(target, key);
      const result = Reflect.set(target, key, value, receiver);
      // don't trigger if target is something up in the prototype chain of original
      if (target === toRaw(receiver)) {
        if (!hadKey) {
          trigger(target, "add" /* ADD */, key, value);
        }
        else if (hasChanged(value, oldValue)) {
          trigger(target, "set" /* SET */, key, value, oldValue);
        }
      }
      return result;
    };
  }
  function deleteProperty(target, key) {
    const hadKey = hasOwn(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete" /* DELETE */, key, undefined, oldValue);
    }
    return result;
  }
  function has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
      track(target, "has" /* HAS */, key);
    }
    return result;
  }
  function ownKeys(target) {
    track(target, "iterate" /* ITERATE */, isArray(target) ? 'length' : ITERATE_KEY);
    return Reflect.ownKeys(target);
  }
```