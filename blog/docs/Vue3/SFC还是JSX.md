# SCF还是JSX

之所以会有这样的思考，是因为长期使用vue开发，从一开始”很香“到后面觉得越来越无力，由于是随着项目的不断迭代越是有这方面的感觉

Vue 组件就是很明显的SFC 即 Single File Component，也即单文件组件

一个vue组件包含了 模板和Vue api和样式，非常得完整用起来也非常得简单，这也是一直都觉得使用 vue 非常舒服的原因，但是一但一个组件开发变得复杂的时候，就变味了，比如下面这些场景：

**组件扩展节点**

vue中在一组件如果希望能显示外部自定义的节点时，需要使用 slot， slot 这个东西每次用都觉得便扭，便扭的原因是其绕来绕去的作用域

同样的功能在 react 中实现就比较直观

```jsx
const Comp = () => <Layout header={<MyHeader />} footer={<MyFooter />} />
```

或者将函数组件当作参数往别个函数组件中传，这种写法更符合咱们的常规思维

**组件要注册才能用**

vue 要使用组件，必需先注册该组件，如果想绕过注册这一步，只能使用渲染函数

**minxin**

这个就是自己用得爽，看别人就是不爽的东西

## 模板的优点 

Vue 3.0通过对模板的分析，可以做一些前期优化，而JSX语法是难以做到的

例如“静态树提升”优化：

如下一段模板(这是模板，并非JSX)：

```html
<template>
 <div>
   <span>static</span>
   <span>{{ dynamic }}</span>
 </div>
</template>
```

如果不做任何优化，那么编译后得到的代码应该是这样子：

```js
render() {
 return h('div', [
   h('span', 'static'),
   h('span', this.dynamic)
 ]);
} 
```

那么每次重新渲染时，都会执行3次 h 方法，虽然未必会触发真正的DOM更新，但这也是一部分开销。

通过观察，我们知道 h('span', 'static') 这段代码传入的参数始终都不会有变化，它是静态的，而只有 h('span', this.dynamic) 这段才会根据 dynamic 的值变化。

在Vue 3.0中，编译器会自动分析出这种区别，对于静态的节点，会自动提升到 render 方法外部，避免重复执行。

Vue 3.0编译后的代码：

```js
const __static1 = h('span', 'static');

render() {
   return h('div', [
       __static1,
       h('span', this.dynamic)
    ])     
}
```

这样每次渲染时就只会执行两次 h 。换言之，经过静态树提升后，Vue 3.0渲染成本将只会和动态节点的规模相关，静态节点将会被复用。

除了静态树提升，还有很多别的编译阶段的优化，这些都是JSX语法难以做到的，因为JSX语法本质上还是在写JS，它没有任何限制，强行提升它会破坏JS执行的上下文，所以很难做出这种优化(也许配合 prepack 可以做到)。

考虑到这一点，如果你是在实现一个对性能要求较高的基础组件库，那模板语法仍然是首选。

另外JSX也没办法做 ref 自动展开，使得 ref 和 reactive 在使用上没有太大区别。
