<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<div style="height: 100px; background: red" id="id"></div>
</body>
<script>
    function delay(){
        return new Promise(resolve => {
            setTimeout(resolve, 2000)
        })
    }
    document.getElementById('id').addEventListener('click', function (e){
        console.log('div', e)
        delay().then(res => {
            console.log('resssssssssssssssssssssssssss')
        })
        e.stopPropagation()
    })


    // 计算出当前帧 结束时间点
    let deadlineTime = null
    // 保存任务
    let callback = null
    // 建立通信
    let channel = new MessageChannel()
    let port1 = channel.port1;
    let port2 = channel.port2;

    // 接收并执行宏任务
    port2.onmessage = () => {
        // 判断当前帧是否还有空闲，即返回的是剩下的时间
        const timeRemaining = () => deadlineTime - performance.now();
        const _timeRemain = timeRemaining();
        // 有空闲时间 且 有回调任务
        if (_timeRemain > 0 && callback) {
            const deadline = {
                timeRemaining, // 计算剩余时间
                didTimeout: _timeRemain < 0 // 当前帧是否完成
            }
            // 执行回调
            callback(deadline)
        } else {
            window._requestIdleCallback(callback)
        }
    }

    // 兼容性要处理一下
    window._requestIdleCallback = function (cb) {
        requestAnimationFrame(rafTime => {
            // 下一帧结束时间点 = 开始时间点 + 一帧用时16.667ms
            deadlineTime = rafTime + 16.667
            // 保存任务
            callback = cb
            // 发送个宏任务
            port1.postMessage(null);
        })
    }

    function beginBatchRenderData(callback, start, max = 10000){

        let myNonEssentialWork = async function (deadline) {
            if (deadline.timeRemaining() > 0){
                let newStart = await callback(start, 1)
                start = newStart
            }
            if(start < max){
                window._requestIdleCallback(myNonEssentialWork)
            }
        }
        window._requestIdleCallback(myNonEssentialWork)
    }
    async function ttt(a){
/*        for(let i =0; i<100; i++){
            console.log('iiiii', i)
        }*/
        await delay()
        console.log(a)
        return a + 1
    }
    beginBatchRenderData(ttt, 0)
</script>
</html>