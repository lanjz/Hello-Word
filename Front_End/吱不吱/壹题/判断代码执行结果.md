# 第 38 题：下面代码中 a 在什么情况下会打印 1

```
var a = ?;
if(a == 1 && a == 2 && a == 3){
 	conso.log(1);
}
```

```
var a = {
  i: 1,
  toString() {
    return a.i++;
  }
}

if( a == 1 && a == 2 && a == 3 ) {
  console.log(1);
}
```

# 第 53 题：输出以下代码的执行结果并解释为什么

```
var a = {n: 1};
var b = a;
a.x = a =   ;

console.log(a.x) // undefined
console.log(b.x) // {n: 2}
```

- a和b同时引用了{n:2}对象

- 接着执行到`a.x = a = {n：2}`语句，尽管赋值是从右到左的没错，但是`.`的优先级比`=`要高，所以这里首先执行`a.x`，相当于为`a`（或者`b`）所指向的`{n:1}`对象新增了一个属性`x`，即此时对象将变为{n:1;x:undefined}

- 之后按正常情况，从右到左进行赋值，此时执行`a ={n:2}`的时候，`a`的引用改变，指向了新对象{n：2},而b依然指向的是旧对象

# 第 56 题：要求设计 LazyMan 类，实现以下功能。

```
LazyMan('Tony');
// Hi I am Tony

LazyMan('Tony').sleep(10).eat('lunch');
// Hi I am Tony
// 等待了10秒...
// I am eating lunch

LazyMan('Tony').eat('lunch').sleep(10).eat('dinner');
// Hi I am Tony
// I am eating lunch
// 等待了10秒...
// I am eating diner

LazyMan('Tony').eat('lunch').eat('dinner').sleepFirst(5).sleep(10).eat('junk food');
// Hi I am Tony
// 等待了5秒...
// I am eating lunch
// I am eating dinner
// 等待了10秒...
// I am eating junk food

```
function LazyManClass(name){
            console.log(`Hi I am ${name}`)
            this.stack = []
            setTimeout(() => {
                this.next()
            })
            return this
        }
        LazyManClass.prototype.next = async function(time){
            let fn = this.stack.shift()
            while(fn) {
                await fn()
                fn = this.stack.shift()
            }
            
            return this
        }
        LazyManClass.prototype.sleep = function(time){
            this.stack.push(async function(){
                await new Promise((resolve) => {
                setTimeout(resolve, time*1000)
            })
            })
            return this
        }
        LazyManClass.prototype.sleepFirst = function(time){
            this.stack.unshift(async function(){
                await new Promise((resolve) => {
                setTimeout(() => {
                    resolve()
                }, time*1000)
            })
            })
            return this
        }
        LazyManClass.prototype.eat = function(foot){
            this.stack.push(function(){
                console.log(`I am eating ${foot}`)
            })
            return this
        }
        function LazyMan(name) {
            return new LazyManClass(name)
        }
        LazyMan('Tony').eat('lunch').eat('dinner').sleepFirst(5).sleep(10).eat('junk food')
```

注意上面`next`函数对`this.stack`遍历的时候，不能使用`forEacth`，因为这种特环方式不能正常执行异步函数

方式二：

```
class LazyManClass {
    constructor(name) {
        this.taskList = [];
        this.name = name;
        console.log(`Hi I am ${this.name}`);
        setTimeout(() => {
            this.next();
        }, 0);
    }
    eat (name) {
        var that = this;
        var fn = (function (n) {
            return function () {
                console.log(`I am eating ${n}`)
                that.next();
            }
        })(name);
        this.taskList.push(fn);
        return this;
    }
    sleepFirst (time) {
        var that = this;
        var fn = (function (t) {
            return function () {
                setTimeout(() => {
                    console.log(`等待了${t}秒...`)
                    that.next();
                }, t * 1000);  
            }
        })(time);
        this.taskList.unshift(fn);
        return this;
    }
    sleep (time) {
        var that = this
        var fn = (function (t) {
            return function () {
                setTimeout(() => {
                    console.log(`等待了${t}秒...`)
                    that.next();
                }, t * 1000); 
            }
        })(time);
        this.taskList.push(fn);
        return this;
    }
    next () {
        var fn = this.taskList.shift();
        fn && fn();
    }
}
function LazyMan(name) {
    return new LazyManClass(name);
}
LazyMan('Tony').eat('lunch').eat('dinner').sleepFirst(5).sleep(4).eat('junk food');
```