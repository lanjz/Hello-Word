# 为什么0.1 + 0.2 != 0.3，请详述理由

因为JS使用的浮点运行标准是IEEE754（64位），并且只要采用IEEE754的语言都有该问题 

## 原因

计算机在计算的时候是没办法直接按十进制计算的。所以计算机在计算的时候分成的两个部分

- 选择按照IEEE754转成相应的二进制

- 对阶运算后，再转回十进制

**1.进制转换**

0.1的二进制表示为0.0001100110011001100110011001100110011001100110011001101（无限循环）

0.2的二进制表示为0.001100110011001100110011001100110011001100110011001101（无限循环）

但是由于IEEE754尾数位限制，需要将后面多余的位截掉，那么尾数部分就会发生进位，所以精度就发生了损失

**2.对阶运算**

对阶运算这部分也可能产生精度损加上之前转二进制时精度就发生了变化，所以对阶运算后结果得到的结果是

`0.0100110011001100110011001100110011001100110011001100 `

这个二进制转换成十进制之后就是`0.30000000000000004`

## 怎么解决精度问题

如果对计算结果的小数点位数精度不是特别高的话，可以使用`toFixed()`方法截取位数

`parserFloat(0.1+0.2).toFixed(2) // 0.30`

如果精度要求高，那就使用第三个库[Math.js](https://github.com/josdejong/mathjs)、[big.js](https://github.com/MikeMcl/big.js/)

# 其它思考

**为什么`x=0.1`能等到`0.1`**

标准中规定尾数f的固定长度是52位，再加上省略的一位，这53位是JS精度范围。它最大可以表示2^53(9007199254740992), 长度是 16，
所以可以使用 toPrecision(16) 来做精度运算，超过的精度会自动做凑整处理

```
(0.1).toPrecision(16) // 0.1000000000000000

(0.1).toPrecision(21) // 0.100000000000000005551
```

**js最大安全数是 Number.MAX_SAFE_INTEGER == Math.pow(2,53) - 1, 而不是Math.pow(2,52) - 1, why？**

这是因为二进制表示有效数字总是1.xx…xx的形式，尾数部分f在规约形式下第一位默认为1（省略不写，xx..xx为尾数部分f，最长52位）。
因此，JavaScript提供的有效数字最长为53个二进制位（64位浮点的后52位+被省略的1位）

# 总结

精度损失可能出现在进制转化和对阶运算过程中，只要这两步产生了精度损失，计算结果就会出现偏差。

平时工作如果有涉及到浮点数的计算时，一定要注意一下了呐
