`src/index.js`：

## 构建函数：

```
constructor (options: RouterOptions = {}) {
    this.app = null
    this.apps = []
    this.options = options
    this.beforeHooks = []
    this.resolveHooks = []
    this.afterHooks = []
    this.matcher = createMatcher(options.routes || [], this)

    let mode = options.mode || 'hash'
    this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false
    if (this.fallback) {
      mode = 'hash'
    }
    if (!inBrowser) {
      mode = 'abstract'
    }
    this.mode = mode

    switch (mode) {
      case 'history':
        this.history = new HTML5History(this, options.base)
        break
      case 'hash':
        this.history = new HashHistory(this, options.base, this.fallback)
        break
      case 'abstract':
        this.history = new AbstractHistory(this, options.base)
        break
      default:
        if (process.env.NODE_ENV !== 'production') {
          assert(false, `invalid mode: ${mode}`)
        }
    }
  }
```

可以看到构建函数就是初始化一些属性值，他们表示如下：

- `this.app`表示根`Vue`实例

- `this.apps`保存着含有`$options.router`属性的`Vue`实例

    - (这里有个习怪的点，`this.apps`里保存的含有`router`属性的Vue实例讲道理只有一个啊，那`this.app`不就等于`this.apps[0]`了么)?

- `this.options` 保存传入的路由配置

- `this.beforeHooks`、`this.resolveHooks`、`this.afterHooks`表示一些钩子函数

- `this.matcher`表示路由匹配器

- `this.fallback`表示如果用户选择的路由模式是History模式然而当前浏览器又不支持`history.pushState`的情况下，根据传入的`fallback`配置参数，决定是否回退到hash模式

- `this.mode`表示路由模式，如果不是浏览器环境则为`abstract`，默认是`hash`

- `this.hisotry`表示路由历史的具体实现实例，它根据`this.mode`的不同实现不同

除了构建函数，还定义了一些方法，最后判断是浏览器下则执行`window.Vue.use(VueRouter)`，这里是用在非构建模式直接引用`Vue.js`和`vue-router.js`时，将会执行这条语句

## init方法做了啥

回到`install`方法定义的`beforeCreate`钩子函数中，将会执行`this._router.init(this)`，传入一个`this`参数指向`Vue`实例

```
init (app: any /* Vue component instance */) {
    process.env.NODE_ENV !== 'production' && assert(
      install.installed,
      `not installed. Make sure to call \`Vue.use(VueRouter)\` ` +
      `before creating root instance.`
    )

    this.apps.push(app)

    // set up app destroyed handler
    // https://github.com/vuejs/vue-router/issues/2639
    app.$once('hook:destroyed', () => {
      // clean out app from this.apps array once destroyed
      const index = this.apps.indexOf(app)
      if (index > -1) this.apps.splice(index, 1)
      // ensure we still have a main app or null if no apps
      // we do not release the router so it can be reused
      if (this.app === app) this.app = this.apps[0] || null
    })

    // main app previously initialized
    // return as we don't need to set up new history listener
    if (this.app) {
      return
    }

    this.app = app

    const history = this.history

    if (history instanceof HTML5History) {
      history.transitionTo(history.getCurrentLocation())
    } else if (history instanceof HashHistory) {
      const setupHashListener = () => {
        history.setupListeners()
      }
      history.transitionTo(
        history.getCurrentLocation(),
        setupHashListener,
        setupHashListener
      )
    }

    history.listen(route => {
      this.apps.forEach((app) => {
        app._route = route
      })
    })
  }
```

- 首先将参数带有`VueRouter`实例的`vue实例`传入`this.apps`中

- (之后添加一次侦听器，当组件销毁的时候，从`this.apps`和`this.app`中将当前销毁的实例移除)?(app.$once('hook:destroyed')得再了解一下 )

- 如果已经存在`this.app`则返回（因为`this.app`存的根Vue实例），否则将当前Vue实例保存到`this.app`中

- 根据当前路由模式执行不同的方法，具体执行方法的作用之后再看

- 最后监听`route`的变化，将参数`route`保存到`this.apps`每个实例中

## `history`做了啥

`init()`中有一段代码：

```
 if (history instanceof HTML5History) {
      history.transitionTo(history.getCurrentLocation())
    } else if (history instanceof HashHistory) {
      const setupHashListener = () => {
        history.setupListeners()
      }
      history.transitionTo(
        history.getCurrentLocation(),
        setupHashListener,
        setupHashListener
      )
    }
```

`VuerRouter`默认的路由模式是Hash，所以先看下Hash模式下执行的` history.transitionTo`及`history`是做什么用的

`history.transitionTo`中传入了三个参数：`history.getCurrentLocation()`、`setupHashListener`、`setupHashListener`

- `history.getCurrentLocation()`是`src/history/hash.js`中HashHistory类的方法，返回的`getHash`方法：

  ```
export function getHash (): string {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  let href = window.location.href
  const index = href.indexOf('#')
  // empty path
  if (index < 0) return ''

  href = href.slice(index + 1)
  // decode the hash but not the search or hash
  // as search(query) is already decoded
  // https://github.com/vuejs/vue-router/issues/2708
  const searchIndex = href.indexOf('?')
  if (searchIndex < 0) {
    const hashIndex = href.indexOf('#')
    if (hashIndex > -1) href = decodeURI(href.slice(0, hashIndex)) + href.slice(hashIndex)
    else href = decodeURI(href)
  } else {
    if (searchIndex > -1) href = decodeURI(href.slice(0, searchIndex)) + href.slice(searchIndex)
  }

  return href
}

  ``

  这个函数的作用是返回url地址中hash后面的字符串

  比如：`http://blackhook/#abc` = `abc`

  `http://blackhook/#abc?df` = `abc?df`

  `http://blackhook/#abc#df` = `abc#df`

- `setupHashListener`返回是一个函数，内部执行`history.setupListeners()` 这个用到了再看

- 第三个参数同第二个参数

回到`transitionTo`方法，这个方法是定义在文件`src/history/base.js`里定义基类`History`中

```
  transitionTo (
    location: RawLocation,
    onComplete?: Function,
    onAbort?: Function
  ) {
    const route = this.router.match(location, this.current)
    this.confirmTransition(
      route,
      () => {
        this.updateRoute(route)
        onComplete && onComplete(route)
        this.ensureURL()

        // fire ready cbs once
        if (!this.ready) {
          this.ready = true
          this.readyCbs.forEach(cb => {
            cb(route)
          })
        }
      },
      err => {
        if (onAbort) {
          onAbort(err)
        }
        if (err && !this.ready) {
          this.ready = true
          this.readyErrorCbs.forEach(cb => {
            cb(err)
          })
        }
      }
    )
  }
```

这个方法首先执行`const route = this.router.match(location, this.current)`

给`match`方法传入了两个参数： 一个我们上文得到的Hash值，一个是符号`/`

`match`方法是在`src/index`中`VueRouter`类中的方法，这个内部执行`this.matcher.match(raw, current, redirectedFrom)`

`this.match`是通过`createMatcher(options.routes || [], this)`创建来的


在构建函数中Hash模式下`this.history = new HashHistory(this, options.base, this.fallback)`，这里给`HashHistory`函数传入了三个参数：

  - this：当前的`VerRouter`实例

  - options：路由配置项

  - this.fallback：(是否在不支持History路由模式时转为Hash路由模式)?(都已经是Hash模式了，怎么还需要传这个参数呢？)

`HashHistory`定义在`./history/hash`中：

```
export class HashHistory extends History {
 ...
```

`HashHistory`继承至基类`History`，先下`History`的定义，在文件`src/history/base`中，首先






