import { isDef, isPrimitive, isTrue, isFalse, isUndef } from '../utils/index.js'
import VNode, { createEmptyVNode, createTextVNode } from '../vdom/vnode.js'

const SIMPLE_NORMALIZE = 1
const ALWAYS_NORMALIZE = 2

function isTextNode (node) {
	return isDef(node) && isDef(node.text) && isFalse(node.isComment)
}


function normalizeArrayChildren (children, nestedIndex) {
	const res = []
	let i, c, lastIndex, last
	for (i = 0; i < children.length; i++) {
	c = children[i]
	if (isUndef(c) || typeof c === 'boolean') continue
	lastIndex = res.length - 1
	last = res[lastIndex]
	//  nested
	if (Array.isArray(c)) {
		if (c.length > 0) {
			c = normalizeArrayChildren(c, `${nestedIndex || ''}_${i}`)
			// merge adjacent text nodes
			if (isTextNode(c[0]) && isTextNode(last)) {
				res[lastIndex] = createTextVNode(last.text + (c[0]).text)
				c.shift()
			}
			res.push.apply(res, c)
		}
	} else if (isPrimitive(c)) {
		if (isTextNode(last)) {
			// merge adjacent text nodes
			// this is necessary for SSR hydration because text nodes are
			// essentially merged when rendered to HTML strings
			res[lastIndex] = createTextVNode(last.text + c)
		} else if (c !== '') {
			// convert primitive to vnode
			res.push(createTextVNode(c))
		}
	} else {
		if (isTextNode(c) && isTextNode(last)) {
			// merge adjacent text nodes
			res[lastIndex] = createTextVNode(last.text + c.text)
		} else {
			// default key for nested array children (likely generated by v-for)
			if (isTrue(children._isVList) &&
				isDef(c.tag) &&
				isUndef(c.key) &&
				isDef(nestedIndex)) {
				c.key = `__vlist${nestedIndex}_${i}__`
			}
			res.push(c)
		}
	}
}
return res
}

export function normalizeChildren (children) {
	return isPrimitive(children)
		? [createTextVNode(children)]
		: Array.isArray(children)
			? normalizeArrayChildren(children)
			: undefined
}

/**
 * @param <object> context : 表示 VNode 的上下文环境
 * @param <object> tag : 是一个字符串，也可以是一个 Component
 * @param <object> data : 表示 VNode 的数据，它是一个 VNodeData 类型
 * @param <object> children : 表示当前 VNode 的子节点
 * @param <object> normalizationType : 表示子节点规范的类型，类型不同规范的方法也就不一样
 * */
export function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
	if (Array.isArray(data) || isPrimitive(data)) {
		normalizationType = children
		children = data
		data = undefined
	}
	if (isTrue(alwaysNormalize)) {
		normalizationType = ALWAYS_NORMALIZE
	}
	if(isDef(data) && isDef(data.__ob__)) {
		return createEmptyVNode()
	}
	if (isDef(data) && isDef(data.is)) {
		tag = data.is
	}
	if (!tag) {
		// in case of component :is set to falsy value
		return createEmptyVNode()
	}
	if(Array.isArray(children) && typeof children[0] === 'function') {
		data = data || {}
		data.scopedSlots = { default: children[0] }
		children.length = 0
	}
	if (normalizationType === ALWAYS_NORMALIZE) {
		children = normalizeChildren(children)
	} else if (normalizationType === SIMPLE_NORMALIZE) {
		children = simpleNormalizeChildren(children)
	}
	
	let vnode, ns
	vnode = new VNode(
		tag, data, children,
		undefined, undefined, context
	)
	return vnode
}
