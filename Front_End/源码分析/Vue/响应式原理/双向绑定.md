> [深入响应式原理](https://ustbhuangyi.github.io/vue-analysis/v2/reactive/)

**实现双向绑定的几个要素：Observer、Watcher、Dep、Compile**

# Observer-监听器

监听器的作用就是监听属性的变化，Vue使用了`Object.defineProperty`方法

## 实现思路

遍历对初始化的属性，对每个属性用`Object.defineProperty`重新定义一遍

```javascript
class Observer {
	constructor(value) {
		this.walk(value)
	}
	walk(obj) {
		const keys = Object.keys(obj)
		for (let i = 0; i < keys.length; i++) {
			defineReactive(obj, keys[i])
		}
	}
}

function defineReactive(obj, key, val) {
	Object.defineProperty(obj, key, {
		enumerable: true,
		configurable: true,
		get: function () {
			// 读取值了，可以做些事情
			return val
		},
		set: function (newVal) {
			// 值发生变化了，可以做些事情
			if(newVal === val) {
				return
			}
			val = newVal;
		}
	})
	
}
```

# Dep-事件收集（依赖收集）

大部分资料这里叫依赖收集，为了更好理解这里暂时改名叫事件收集，收集当属性发生变化的时候要执行的事件。

## 实现思路

观察者模型（发布者-观察者模式）

```javascript
class Dep {
	constructor() {
		this.id = uid ++
		this.subs = []
	}
	addSub(sub) {
		this.subs.push(sub)
	}
	removeSub(sub) {
		if(this.subs.length) {
			const index = this.subs.indexOf(sub)
			if(index > -1) {
				this.subs.splice(index, 1)
			}
		}
	}
	depend() {
		// Dep.target是一个全局变量
		if(Dep.target) {
			Dep.target.addDep(this)
		}
	}
	notify() {
		console.log('属性变化通知 Watcher 执行更新视图函数');
		const subs = this.subs.slice()
		for (let i = 0, l = subs.length; i < l; i++) {
			subs[i].update()
		}
	}
}

// 这些代码的作用后面再介绍
Dep.target = null
const targetStack = []
function pushTarget(target) {
	targetStack.push(target)
	Dep.target = target
}
function popTarget () {
	targetStack.pop()
	Dep.target = targetStack[targetStack.length - 1]
}

```

## 什么时候执行事件

结合上文的监听器，当属性发生变化时，即`Object.defineProperty`的`set`
属性执行，就是属性发生变化的时候，所以在`set`中执行这些依赖

## 什么时候添加依赖

结合Vue中源码可知，添加依赖是在`Object.defineProperty`的`get`方法中做的，从这里我们可以知道
在Vue初始化的时候的某一步中对属性进行的获取，从而触发了`get`方法收集这些事件，这一步就是发生了渲染页面的时候，
初始页面的时候，页面渲染的时候需要用到这些初始化的数据

完善Observer代码

```javascript
function defineReactive(obj, key, val) {
	const dep = new Dep()
	Object.defineProperty(obj, key, {
		enumerable: true,
		configurable: true,
		get: function () {
			if(Dep.target) {
				dep.depend() // 收集事件
			}
			return val
		},
		set: function (newVal) {
			if(newVal === val) {
				return
			}
			val = newVal;
			dep.notify() // 执行事件
		}
	})
	
}

class Observer {
	constructor(value) {
		this.value = value
		// this.dep = new Dep()
		this.walk(value)
	}
	walk(obj) {
		const keys = Object.keys(obj)
		for (let i = 0; i < keys.length; i++) {
			defineReactive(obj, keys[i])
		}
	}
}
```

# Watcher-事件

Watcher就是`Dep`具体收集的事件，将Vue的Watcher进行简化

```javascript
function Watcher(vm, prop, callback) {
	this.vm = vm
	this.prop = prop
	this.getter = callback
	this.value = this.get()
}
Watcher.prototype = {
	update: function () {
		const value = this.vm.$data[this.prop];
		const oldVal = this.value;
		if (value !== oldVal) {
			this.value = value;
			this.callback(value);
		}
	},
	get: function () {
		Dep.target = this; //储存订阅器
		this.getter()
		Dep.target = null;
		return value;
	},
	addDep: function(dep) {
		dep.addSub(this)
	}
}
```

在Watcher中首先执行`this.get()`方法,将当前的Watcher实例赋值给`Dep.target`，`Dep.target`
在上文讲的`Dep`的`depend`有出现过，然后执行`this.getter()`方法，我们暂且理解为渲染页面的方法，然后在渲染页面的过程收集依赖。

这里先整理一下代码执行步骤

1. 先实例化一个`Watcher`，并将这个实例赋值给全局属性`Dep.target`

2. 然后实现渲染页面方法，访问属性触发`Object.defineProperty`中的`get`的方法

3. `Object.defineProperty`中的`get`的方法中执行`dep.depend()`

4. `dep.depend()`中再执行`Dep.target.addDep(this)`，也就是执行Watcher中的`addDep`,这里的参数`this`就是当前的收集依赖`Dep`实例，

5. Watcher中的`addDep`中将参数(`Dep`实例)，取出执行`dep.addSub(this)`方法，将当前的`this`（Watcher）保存到`Dep`中

这块的过程有点不易理解，因为常归的思路步骤如下

1. 实例一个`Watcher`

2. 将这个`Watcher`作为参数执行`Dep`的上`depend`方法，直接完成收集

而Vue中则是通过一个全局属性`Dep.target`做了类似中转的作用，将`Dep`反传到`Watcher`的`addDep`方法中做了收集这么一个动作

这里为什么要这么做有待探究

# Compiler
