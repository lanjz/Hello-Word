# 响应式原理

VUE中实现响应式原理，主要有几个要素：Observer、Watcher、Dep

## Observer-监听器

在VUE中是使用`Object.defineProperty`方法实现数据的监听，主要流程：

先分析下如何给`data`上的属性添加响应

`initState(vm: Component)` => `initData(vm: Component)`=>`observe(data)`=>`new Observer(value)`

`Observer`类中会遍历`data`上的属性，并为每个属性执行`defineReactive`的方法:

```
walk (obj: Object) {
    const keys = Object.keys(obj)
    for (let i = 0; i < keys.length; i++) {
      defineReactive(obj, keys[i])
    }
  }
```

在`defineReactive`的功能就是定义一个响应式对象，给对象动态添加 `getter` 和 `setter`

下面是`defineReactive`方法的精简版：

```
/**
 * Define a reactive property on an Object.
 */
export function defineReactive (
  obj: Object,
  key: string,
  val: any,
  customSetter?: ?Function,
  shallow?: boolean
) {
  const dep = new Dep()

  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      if (Dep.target) {
        dep.depend()
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      dep.notify()
    }
  })
}
```

## Dep-事件收集（依赖收集）

`Dep`是`getter`收集事件的核心，本质是一个观察者模式

```
import type Watcher from './watcher'
import { remove } from '../util/index'

let uid = 0

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
export default class Dep {
  static target: ?Watcher;
  id: number;
  subs: Array<Watcher>;

  constructor () {
    this.id = uid++
    this.subs = []
  }

  addSub (sub: Watcher) {
    this.subs.push(sub)
  }

  removeSub (sub: Watcher) {
    remove(this.subs, sub)
  }

  depend () {
    if (Dep.target) {
      Dep.target.addDep(this)
    }
  }

  notify () {
    // stabilize the subscriber list first
    const subs = this.subs.slice()
    for (let i = 0, l = subs.length; i < l; i++) {
      subs[i].update()
    }
  }
}

// the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.
Dep.target = null
const targetStack = []

export function pushTarget (_target: ?Watcher) {
  if (Dep.target) targetStack.push(Dep.target)
  Dep.target = _target
}

export function popTarget () {
  Dep.target = targetStack.pop()
}
```


## Watcher-事件（渲染方法）

`Watcher`是Dep具体收集的事件，其中包念了渲染组件的方法

将Vue的Watcher进行简化：

```javascript
class Watcher {
	constructor(vm, prop, callback) {
		this.vm = vm
		this.getter = callback
		this.newDeps = null
		this.oldDep = null
		this.prop = prop
		this.value = this.get()
	}
	
	get() {
		Dep.target = this; //储存订阅器
		const value = this.getter.call(this.vm); //因为属性被监听，这一步会执行监听器里的 get方法
		Dep.target = null;
		this.cleanupDeps()
		return value
	}
	
	update() {
		this.getter.call(this.vm)
		// this.get()
	}
	
	addDep(dep) {
		this.newDeps = dep
		dep.addSub(this)
	}
	cleanupDeps() {
		if(this.oldDep)  {
			this.oldDep.removeSub(this)
		}
		this.oldDep = this.newDeps
	}
}

```

当我们去实例化一个渲染 watcher 的时候，首先进入 watcher 的构造函数逻辑,主要会做两件事情：

1. 将当前Watcher实例赋值到全局`Dep.target`

2. 触发当前vue实例的`_render`方法

# 依赖收集的过程

Vue 的 mount 过程有一段比较重要的逻辑，大致如下：

```
  updateComponent = () => {
  vm._update(vm._render(), hydrating)
}
new Watcher(vm, updateComponent, noop, {
  before () {
    if (vm._isMounted) {
      callHook(vm, 'beforeUpdate')
    }
  }
}, true /* isRenderWatcher */)
```

在渲染当前组件的时候，会实例一个`Watcher`的实例，执行`Watcher`中以下代码：

`this.get()` => `pushTarget(this)` => `Dep.target = _target`

上面这一步会把当前`Watcher`实例赋值给全局`Dep.target`

然后会执行`this.getter.call(vm, vm)` => `vm._update(vm._render(), hydrating)`,这一步就会执行`vm._render()`方法，这个方法是生成`VNode`的

在生成`VNode`的过程中会访问`vm`上的数据，这个时候就触发对象的`getter`方法，并执行`getter`方法中下面语句：

```
if (Dep.target) {
        dep.depend()
      }
```

然后执行`dep.depend()`的以下语句:

```
depend () {
    if (Dep.target) {
      Dep.target.addDep(this)
    }
  }
```

这里的`Dep.target`就是`mounted`中的`Watcher`实例，然后执行`Watcher`中的`addDep(this)`:

```
 addDep (dep: Dep) {
    const id = dep.id
    if (!this.newDepIds.has(id)) {
      this.newDepIds.add(id)
      this.newDeps.push(dep)
      if (!this.depIds.has(id)) {
        dep.addSub(this)
      }
    }
  }
```

通过`dep.addSub(this)`，将当前的`Watcher`实例订阅到这个数据持有的 `dep`的 `subs` 中,
这个目的是为后续数据变化时候能通知到哪些 `subs` 做准备。


# Q&A

- Observer类中的`this.dep = new Dep()`的作用

- 为什么使用全局的`Dep.target`保存`Watcher`实例

  因为在同一时间只能有一个全局的 Watcher 被计算

- 为什么依赖收集完后还有一个清空依赖的步骤

  考虑到 Vue 是数据驱动的，所以每次数据变化都会重新`render`，那么 `vm._render()` 方法又会再次执行，
  并再次触发数据的 `getters`，所以 `Wathcer` 在构造函数中会初始化2个`Dep`实例数组，`newDeps`表示新添加的
  `Dep`实例数组，而`deps`表示上一次添加的`Dep`实例数组。

  在执行`cleanupDeps`函数的时候，会首先遍历`deps`，移除对`dep.subs`数组中`Wathcer`的订阅，然后把`newDepIds`和`depIds`交换，`newDeps`和`deps`交换，并把`newDepIds`和`newDeps`清空。

- 那么为什么需要做`deps`订阅的移除呢，在添加`deps`的订阅过程，已经能通过`id`去重避免重复订阅了。

  考虑到一种场景，我们的模板会根据`v-if`去渲染不同子模板`a`和`b`，当我们满足某种条件的时候渲染`a`的时候，
  会访问到`a`中的数据，这时候我们对`a`使用的数据添加了`getter`，做了依赖收集，那么当我们去修改`a`的数据的
  时候，理应通知到这些订阅者。那么如果我们一旦改变了条件渲染了`b`模板，又会对`b`使用的数据添加了`getter`，
  如果我们没有依赖移除的过程，那么这时候我去修改`a`模板的数据，会通知`a`数据的订阅的回调，这显然是有浪费的。
  因此 Vue 设计了在每次添加完新的订阅，会移除掉旧的订阅，这样就保证了在我们刚才的场景中，
  如果渲染`b`模板的时候去修改`a`模板的数据，`a`数据订阅回调已经被移除了，所以不会有任何浪费，真的是非常赞叹 Vue 对一些细节上的处理。
