> [继承与原型链](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)

## 原型链

JavaScript中的每个对象都有一个私有属性（__proto__），这个属性指向这个对象的原型对象（prototype）。同样的，这个原型对象（prototype）也有同一个私有属性（__proto__），也指向这个原型对象的原型对象，以此类推层层递进，层层`__proto__`，就形成了原型链，
原型链的最后一个对象为`null`，`null`没有原型，所以此时就是原型链中的最后一环

**几天所有的JavaScript中的对象都是原型链项端`Object`的实例**

##  继承属性

当我们获取一个对象中的属性时，先尝试在当前对象中寻找这个属性，如果这个属性不存在，则尝试在当前对象的原型对象中寻找，以及继续在原型对象中的原型对象中寻找，直到找到这个属性或者到达原型链的项端才停止。

> 遵循ECMAScript标准，`someObject.[[prototype]]`表示`someObject`的原型。

> 请多浏览器实现了用属性`__proto__`来指向对象的原型。

> ES6开始，可以通过`Object.getPrototypeOf(someObject)`方法来获取`someObject`的原型

> 它不应该与构造函数的`prototype`属性相混淆。通过构建函数(`func`)生成的实例对象的[[prototype]]指向`func`的`prototype`属性。

### 理解`someObje[[prototype]]`指向`someObje`构造函数的`prototype`

```
var a = new Array()
a.__proto__ === a.constructor.prototype // true
Object.getPrototypeOf(a) === a.constructor.prototype // true
```

`a`的构造函数是`Array`

`a`是`Array`构建出来一个实例

1. `a.constructor`指向`Array`,`Array`的原型属性为`Array.prototype`

2. `a.__proto__`指向`Array.prototype`，即`a.constructor.prototype`

```
// 让我们从一个自身拥有属性a和b的函数里创建一个对象o：
let f = function () {
   this.a = 1;
   this.b = 2;
}
/* 你要这么写也没区别
function f(){
  this.a = 1;
  this.b = 2;
}
*/
let o = new f(); // {a: 1, b: 2}
// 在f函数的原型上定义属性
f.prototype.b = 3;
f.prototype.c = 4;

// 不要在f函数的原型上直接定义 f.prototype = {b:3,c:4};这样会直接打破原型链
// o.[[Prototype]] 有属性 b 和 c   (其实就是o.__proto__或者o.constructor.prototype)

// o.[[Prototype]].[[Prototype]] 是 Object.prototype.
// 最后o.[[Prototype]].[[Prototype]].[[Prototype]]是null
// 这就是原型链的末尾，即 null，
// 根据定义，null 没有[[Prototype]].
// 综上，整个原型链如下: 
// {a:1, b:2} ---> {b:3, c:4} ---> Object.prototype---> null

console.log(o.a); // 1
// a是o的自身属性吗？是的，该属性的值为1

console.log(o.b); // 2
// b是o的自身属性吗？是的，该属性的值为2
// 原型上也有一个'b'属性,但是它不会被访问到.这种情况称为"属性遮蔽 (property shadowing)"

console.log(o.c); // 4
// c是o的自身属性吗？不是，那看看原型上有没有
// c是o.[[Prototype]]的属性吗？是的，该属性的值为4

console.log(o.d); // undefined
// d是o的自身属性吗？不是,那看看原型上有没有
// d是o.[[Prototype]]的属性吗？不是，那看看它的原型上有没有
// o.[[Prototype]].[[Prototype]] 为 null，停止搜索
// 没有d属性，返回undefined
```

## 继承方法

属性也可以是个方法，跟属性一样

当继承的函数被调用时，`this`指向的是当前继承的对象，而不是继承的函数所在的原型对象

```
var o = {
  a: 2,
  m: function(){
    return this.a + 1;
  }
};

console.log(o.m()); // 3
// 当调用 o.m 时,'this'指向了o.

var p = Object.create(o);
// p是一个继承自 o 的对象

p.a = 4; // 创建 p 的自身属性 a
console.log(p.m()); // 5
// 调用 p.m 时, 'this'指向 p. 
// 又因为 p 继承 o 的 m 函数
// 此时的'this.a' 即 p.a，即 p 的自身属性 'a' 
```
