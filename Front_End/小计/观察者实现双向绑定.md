> [观察者模式](http://67.209.187.128:3001/lanjz/Hello-Word/Front_End/%E5%B0%8F%E8%AE%A1/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F)

> [发布订阅模式实现数据双向绑定](https://github.com/colinrds/CNotes/wiki/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A)

# 实现思路

实现双向绑定的几个角色：

- `input`、`textarea`等表单元素，

- Model模型，要双向绑定的数据

- 显示model的视图

## 订阅的内容

双向绑定时，当数据更新了，视图也会跟着更新，这个视图也包括表单中的值，在使用`Vue`时，我们并不关心视图是怎么更新的，我们只需要改变数据就可以了，
所以如果根据数据更新视图就是订阅的内容

## 谁来发布

更新视图的条件是当数据发生变化时，所以当数据改变时就是发布订阅的时候，这里我们定义下这个`Modal`

```javascript
const user = {
	data: {},
	set: function(key, value) {
		binder.public(dataKey, key, value); // 发布订阅
	    this.data[key] = value
	},
	get: function(key) {
	  return this.data[key]
	}
}
```

这里声明了一个`user`模型,其中定义了`set`方法设置值，在设置值的同时就可以发布订阅

## 什么时候订阅

定义modal的值时我们就应该开始订阅内容了，所以这里定义一个创建`user`模型的函数`ModalUser`，这个函数的作用有两个：

1. 返回一个`user`模型

2. 订阅`user`模型内容

```javascript
function ModalUser(dataKey) {
		const binder = new DataBinder(dataKey)
        const user = {
			attrs: {},
			set: function (key, value) {
				this.attrs[key] = value;
				// 当前发生变化后，通过订阅者
				binder.public(dataKey, key, value);
			},
			get: function (key) {
				return this.attrs[key];
			}
        }
		return user;
	}
```

`DataBinder`函数的作用就是实例一个观察者，并添加订阅内容，参数`key`作为存储订阅内容的标识

```javascript
	function DataBinder(dataId) {
		// 添加订阅者，查找所有绑定这个dataId的元素，并改变值
        const newObj = new Observer()
		newObj.listen(dataId, function (key, newVal) {
			const elements = document.querySelectorAll(`[data-bind-${dataId}=${key}]`)
            elements.forEach(item => {
            	let tagName = item.tagName.toLowerCase();
				if (tagName === 'input' || tagName === 'textarea' || tagName === 'select') {
					item.value = newVal;
				} else {
					item.innerHTML = newVal;
				}
            })
		})
		function changeHandler(e) {
			const target = e.target
			const attrName = target.getAttribute("data-bind-"+dataId);
			newObj.public(dataId, attrName, target.value);
		}
		document.addEventListener('input', changeHandler, false);
        return newObj
	}
```

# 完整实现代码

```javascript
const Observer = function () {
        this.obs = {}
        this.listen = function (key, fn) {
        	if(!this.obs[key]) {
				this.obs[key] = []
            }
			this.obs[key].push(fn)
			console.log(`${key}成功添加订阅消息${fn}`)
		}
		this.public = function () {
			// 取第一个参数
			const key = Array.prototype.shift.call(arguments)
			const listObs = this.obs[key]
			if(listObs) {
				listObs.forEach((fn) => {
					fn(...arguments)
				})
			}
		}
	}
	function DataBinder(dataId) {
		// 添加订阅者，查找所有绑定这个dataId的元素，并改变值
        const newObj = new Observer()
		newObj.listen(dataId, function (key, newVal) {
			const elements = document.querySelectorAll(`[data-bind-${dataId}=${key}]`)
            elements.forEach(item => {
            	let tagName = item.tagName.toLowerCase();
				if (tagName === 'input' || tagName === 'textarea' || tagName === 'select') {
					item.value = newVal;
				} else {
					item.innerHTML = newVal;
				}
            })
		})
		function changeHandler(e) {
			const target = e.target
			const attrName = target.getAttribute("data-bind-"+dataId);
			newObj.public(dataId, attrName, target.value);
		}
		document.addEventListener('input', changeHandler, false);
        return newObj
	}

	function ModelData(dataKey) {
		const binder = new DataBinder(dataKey)
        const user = {
			attrs: {},
			set: function (key, value) {
				this.attrs[key] = value;
				// 当前发生变化后，通过订阅者
				binder.public(dataKey, key, value);
			},
			get: function (key) {
				return this.attrs[key];
			}
        }
		return user;
	}
	// 测试demo
	const user = new ModelData("objId");
	user.set("number", 1);
	// 测试模型的变化到视图层的变化
	const btn = document.getElementById("btn");
	const inputId = document.getElementById("inputId");
	btn.onclick = function () {
		const value = inputId.value;
		user.set("number", parseInt(value) + 1);
	};
	console.log('user', user)
```
