> 第一次循环，第一个位置开始，找出最小元素的位置，然后与第一个位置进行交换

> 第二次循环，第二个位置开始，在剩余的元素中打出最小元素的元素，然后与第二个位置进行交换

> 以此类推，遍历到倒数第二个元素

![](http://upload-images.jianshu.io/upload_images/5797628-687f9990aa69251a?imageMogr2/auto-orient/strip)

```
    let count = 0;
	const arr = [1, 20, 10, 30, 22, 11, 55, 24, 31, 88, 12, 40, 50];
	let a = 0
    for(let i = 0; i< arr.length - 1; i++) {
		a = i
		for(let j = i+1; j<arr.length; j ++) {
			if(arr[j] < arr[a]) {
				a = j
            }
			count++
        }
        const tem = arr[i]
        arr[i] = arr[a]
        arr[a] = tem
    }
    console.log('resultArr', arr, count)
   // [1, 10, 11, 12, 20, 22, 24, 30, 31, 40, 50, 55, 88] 78
```

### 性能

- 时间复杂度：平均时间复杂度是O(n^2)，这是一个不稳定的算法，因为每次交换之后，它都改变了后续数组的顺序。

- 空间复杂度：辅助空间是常数，空间复杂度为O(1);
