[排序参考1](https://segmentfault.com/a/1190000011294349)

[排序面试题](https://www.jianshu.com/p/e7d8a3bd39f4)

> 从第一个元素开始与下一个元素相比较，如果大于下一个元素，则交换两个元素的位置。如此步骤循环整个元素

!['示例图'](http://upload-images.jianshu.io/upload_images/5797628-83e9ddf537665a54?imageMogr2/auto-orient/strip)

```
    let count = 0
    const arr = [1, 20, 10, 30, 22, 11, 55, 24, 31, 88, 12, 40, 50]
    for(let i = 0; i< arr.length - 1; i++) {
		for(let j = 0; j<arr.length - 1 - i; j ++) {
			if(arr[j] > arr[j+1]) {
				const temp = arr[j]
                arr[j] = arr[j+1]
                arr[j+1] = temp
            }
			count++
        }
    }
    console.log('resultArr', arr, count)
   //  [1, 10, 11, 12, 20, 22, 24, 30, 31, 40, 50, 55, 88] 78
```

使得冒泡排序，共循环了78次

### 性能

- 时间复杂度：平均时间复杂度是O(n^2)

- 空间复杂度：由于辅助空间为常数，所以空间复杂度是O(1)

### 优化一

以上代码有个缺点就是，无论是排序的数组原来的数据是乱序还是正序，都会执行78次才能结束，
但实际上，只要有某一次的循环未进行数据交换，那么这组数据其实已经是正序的状态，我们就可以结束排序了

```
  let count = 0;
  const arr = [1, 20, 10, 30, 22, 11, 55, 24, 31, 88, 12, 40, 50]
    for(let i = 0; i< arr.length - 1; i++) {
		let flag = false
		for(let j = 0; j<arr.length - 1 - i; j ++) {
			if(arr[j] > arr[j+1]) {
				const temp = arr[j]
                arr[j] = arr[j+1]
                arr[j+1] = temp
				flag = true
            }
			count++
        }
        if(!flag) {
			break
        }
    }
    console.log('resultArr', arr, count)
   //  [1, 10, 11, 12, 20, 22, 24, 30, 31, 40, 50, 55, 88] 68
```

循环次数减少了10次，如果本来就是正序的话，循环次数就只有数组的个数

### 优化二

记录最后一次交换的位置，因为之后的数都是可以不用排序的，可以不遍历这些数

```
    let count = 0;
    let last = arr.length
    for(let i = last - 1; i >= 0; i--) {
        let flag = true;
        for(let j =0; j<i; j++) {
            if(arr[j] > arr[j+1]) {
                const tem = arr[j]
                arr[j] = arr[j+1]
                arr[j+1] = tem
                last = j + 1
                flag = false
            }
            count += 1

        }
        if(flag) {
            break
        }
    }
    console.log('arr', arr, count)
  //  [1, 10, 11, 20, 12, 22, 24, 30, 31, 40, 50, 55, 88] 57
```
