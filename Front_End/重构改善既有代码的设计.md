# 重构改善既有代码的设计

程序难维护的几个特征

- 难以阅读的程序，难以修改

- 逻辑重复的程序，难以维护

- 添加新行为时需要修改已有代码的程序，难以修改

- 带复杂条件逻辑的程序，难以修改

因此我们希望程序：

- 容易阅读

- 所有逻辑都只在唯一地点指定

- 新的改动不会危及现有行为

- 尽可能简单表达条件逻辑

## 什么是重构

重构（refactoring）：对软件内部结构的一种调整，目的是在不改变代码外在行为的前提下，对代码做出修改，以改进程序的内部结构，
提高其可理解性，降低其修改成本

# 为何重构

## 重构改进软件设计

代码结构的流失是累积性的，程序的设计在不断的迭代，更新，当人们只为短期目的，或是在完全理解整体设计之前，就贸然修改代码，程序将逐渐失去自己的结构，程序员
越难通过阅读源码而理解原来的设计。重构很像是整理代码，你所做的就是让所有东西回到应处的位置上。

完成同样一样事情，设计不良的程序往往需要更多代码，这常常是因为代码在不同的地方使用完全相同的语句做同样的事。因此改进设计的一个重要方向就是消除重复代码。
这个动作的重要性在于方便未来的修改。

重构：重构是**在不改变软件可观察行为的前提下改善其内部结构**

重构手法：用绝对安全的手法从**焦油坑**中整理出可测试的接口，给它添加测试，以此作为继续重构的立足点

## 重构使软件更容易理解

我们在努力完成程序的功能的过程中，往往注意力全在完成功能上，不会为未来的接盘侠做考虑，换句话说就是不考虑代码的易理解性。
为了改善代码，让代码更好地表达自己的用途，那就需要花一点点时间进行重构

## 重构帮助找到bug

对代码的理解，可以帮助我们更快定位bug

## 重构提高编程速度

如果有更简单更易理解的代码，开发者就能将更多精力集中在功能上，不需要花额外的时间去理解系统，调试问题，寻找重复代码

# 何时重构

## 添加功能时重构

代码的设计无法帮助我们轻松添加我们需要的特性时，重构原有设计，吏新特性的添加更快速，更流畅

## 修补错误时重构

当发生bug时，回想代码没有清晰到让你马上定位bug位置，那么说明代码需要重构

## 复审代码时重构



## 重构的风险

在挖掘代码的过程中，会发现一些值得修改的地方，于是你挖得更深。挖得越深，找到的重构机会机会就越多。。。最后就给自己挖了一个大坑

## 什么时候需要重构

如果需要给程序添加某个特性，而当前代码无法很方便地达成目的

## 重构步骤

### 为即将修改的代码建立一组可靠的测试环境

好的测试是重构的根本，它能告诉我们是否引入bug，花时间建立一个优良的测试机制是完全值得的

## 重构时机

- 过长的函数，代码块越小，代码的功能就愈容易管理，代码的处理和移动也就越轻松

- 遇到不合适的变量。好的代码应该清楚表达自己的功能和目的，变量名称是代码清晰的关键。变量名包含了我们对当前代码的理解，
随着我们对代码和程序理解的深入，我们会不断的修改的变量，这是正常的

> 不用过多的担心修改变量，会引发其它的错误，因为我们现在使用的编辑器都很强大，可以通过查找或者全局搜索等功能变量被使用的地方

# 代码坏味道（何时重构）

- 重复代码

- 过长函数或过大的类
  
  毕竟代码越长越难以理解，至于如何确定哪段代码该进行分解。书中列了几个技巧：1. 寻找注释。2. 条件表达示和循环

  解决策略：拆解函数

- 发散式变化

  一个函数经常因为不同的原因在不同的方向上发生变化，这里我的理解是这个函数的职责不明确（墙头草）

  解决策略：拆解函数，提炼内容

- 霰弹式修改

  每遇到某种变化，你都必须在许多不同的类内做出许多小修改，

  解决策略：应该把这些有相关的代码尽量放在一起

- switch惊悚现身

  `switch`的问题在于重复。你常会发现同样的`switch`语句散布于不同地点。如果要为它添加一个新的case语句，就必须找到所有`switch`语句并修改它们

- 平行继承体系
  
  为某个类添加一个子类，必须也为另一个类相应增加一个子类

  解决策略：让一个继承体系的实例引用另一个继承体系的实例

- 冗赘类
  
  如果一个类的所得不值其身价，它就应该消失。

- 夸夸其谈未来性

  企图以各式各样的钩子和特殊情况来处理一些非必要的事情，这么往往造成系统更难理解和维护

  解决策略：该搬就搬吧

- 令人迷惑的暂时字段

  某个函数内部需要因为一特殊情况而加一些额外处理的代码

  解决策略：将这些孤儿放进单独的函数中

- 过多的注释

  不是说不该写注释，但当看到某个函数需要很多注释来说明的时候，往往说明这的功能或流程是复杂的，我们关注的是这么复杂的部分而不是注释本身

  

- 长参数列，依恋情结，数据泥团，基本类型偏执，过度耦合的消息链,不完美的库类，纯稚的数据类，被拒绝的遗赠

  


任何一个傻瓜都能写出计算机可以理解的代码。唯有写出人类容易理解的代码，才是优秀的程序员