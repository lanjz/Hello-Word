# 重构改善既有代码的设计

重构（refactoring）：对软件内部结构的一种调整，目的是在不改变代码外在行为的前提下，对代码做出修改，以改进程序的内部结构， 提高其可理解性，降低其修改成本

所以重构是可大可小的，不是只给项目大修大补（更换语言、更换框架等）才叫重构，日常修复bug、缺陷也是对代码进行了重构

# 为何重构&重构好处

程序难维护的几个特征

- 难以阅读的程序，难以修改

- 逻辑重复的程序，难以维护

- 添加新行为时需要修改已有代码的程序，难以修改

- 带复杂条件逻辑的程序，难以修改

## 改进软件设计

代码结构的流失是累积性的，程序的设计在不断的迭代，更新，当人们只为短期目的，或是在完全理解整体设计之前，就贸然修改代码，程序将逐渐失去自己的结构，程序员
越难通过阅读源码而理解原来的设计。重构很像是整理代码，你所做的就是让所有东西回到应处的位置上。

完成同样一样事情，设计不良的程序往往需要更多代码，这常常是因为代码在不同的地方使用完全相同的语句做同样的事。因此改进设计的一个重要方向就是消除重复代码。
这个动作的重要性在于方便未来的修改。

重构手法：用绝对安全的手法从**焦油坑**中整理出可测试的接口，给它添加测试，以此作为继续重构的立足点

## 使软件更容易理解

我们在努力完成程序的功能的过程中，往往注意力全在完成功能上，不会为未来的接盘侠做考虑，换句话说就是不考虑代码的易理解性。
为了改善代码，让代码更好地表达自己的用途，那就需要花一点点时间进行重构

## 帮助找到bug

对代码的理解，可以帮助我们更快定位bug

## 提高编程速度

如果有更简单更易理解的代码，开发者就能将更多精力集中在功能上，不需要花额外的时间去理解系统，调试问题，寻找重复代码

**总体而言希望重构达到目的：**

- 容易阅读

- 所有逻辑都只在唯一地点指定

- 新的改动不会危及现有行为

- 尽可能简单表达条件逻辑


# 何时需要重构

识别什么样的代码是需要通过重构优化的

## 添加功能时重构

代码的设计无法帮助我们轻松添加我们需要的特性时，重构原有设计，吏新特性的添加更快速，更流畅

## 修补错误时重构

当发生bug时，回想代码没有清晰到让你马上定位bug位置，那么说明代码需要重构

## 复审代码时重构



## 重构的风险

在挖掘代码的过程中，会发现一些值得修改的地方，于是你挖得更深。挖得越深，找到的重构机会机会就越多。。。最后就给自己挖了一个大坑

## 什么时候需要重构

如果需要给程序添加某个特性，而当前代码无法很方便地达成目的

## 重构步骤

### 为即将修改的代码建立一组可靠的测试环境

好的测试是重构的根本，它能告诉我们是否引入bug，花时间建立一个优良的测试机制是完全值得的

## 重构时机

- 过长的函数，代码块越小，代码的功能就愈容易管理，代码的处理和移动也就越轻松

- 遇到不合适的变量。好的代码应该清楚表达自己的功能和目的，变量名称是代码清晰的关键。变量名包含了我们对当前代码的理解，
随着我们对代码和程序理解的深入，我们会不断的修改的变量，这是正常的

> 不用过多的担心修改变量，会引发其它的错误，因为我们现在使用的编辑器都很强大，可以通过查找或者全局搜索等功能变量被使用的地方

# 代码坏味道

识别哪些代码是需要我们优化及重构的

- 重复代码

  一个以上的地点看到相同的程序结构

  解决策略：设法将它们合而为一

- 过长函数或过大的类
  
  毕竟代码越长越难以理解，至于如何确定哪段代码该进行分解。书中列了几个技巧：1. 寻找注释。2. 条件表达示和循环

  解决策略：拆解函数

- 发散式变化

  一个函数经常因为不同的原因在不同的方向上发生变化，这里我的理解是这个函数的职责不明确（墙头草）

  解决策略：拆解函数，提炼内容

- 霰弹式修改

  每遇到某种变化，你都必须在许多不同的类内做出许多小修改，

  解决策略：应该把这些有相关的代码尽量放在一起

- switch惊悚现身

  `switch`的问题在于重复。你常会发现同样的`switch`语句散布于不同地点。如果要为它添加一个新的case语句，就必须找到所有`switch`语句并修改它们

- 平行继承体系
  
  为某个类添加一个子类，必须也为另一个类相应增加一个子类

  解决策略：让一个继承体系的实例引用另一个继承体系的实例

- 冗赘类
  
  如果一个类的所得不值其身价，它就应该消失。

- 夸夸其谈未来性

  企图以各式各样的钩子和特殊情况来处理一些非必要的事情，这么往往造成系统更难理解和维护

  解决策略：该搬就搬吧

- 令人迷惑的暂时字段

  某个函数内部需要因为一特殊情况而加一些额外处理的代码

  解决策略：将这些孤儿放进单独的函数中

- 过多的注释

  不是说不该写注释，但当看到某个函数需要很多注释来说明的时候，往往说明这的功能或流程是复杂的，我们关注的是这么复杂的部分而不是注释本身

  

- 长参数列，依恋情结，数据泥团，基本类型偏执，过度耦合的消息链,不完美的库类，纯稚的数据类，被拒绝的遗赠

# 如何重构

就跟项目开始前要先做好理论规划一样的道理，可以让重构事半功倍

每个重构手法有如下五个部分

- 名称

- 概要：简单介绍重构手法的适用情景，以及它所做的事情。这部分可以帮助你更快找到你所需要的重构手段

- 动机：即“为什么需要这个重构”和“什么情况下不该使用这个重构”

- 做法：简明扼要地一步一步介绍如何进行此一重构
  


任何一个傻瓜都能写出计算机可以理解的代码。唯有写出人类容易理解的代码，才是优秀的程序员

# 重构手段

## 重新组织函数

- 提炼函数

  动机：过长的函数难让人难以理解和维护

  对于过长函数可以通过提炼的手段，将部分代码片段放进一个独立的函数中，并让函数名称解释该函数的用途

  好处：
    -  增加函数可读性

    - 函数复用的可能性更大

- 合并内联函数

  这个跟提炼函数相反，是把内部调用的函数代码直接写入主函数中

  动机：提炼出来的函数可能带来帮助，但非必要的间接性有时会显得多此一举。当内部代码和函数名称同样清晰易懂且内部函数没有被复用时，则可将代码合并至调用函数中

  ```
function getRating() {
    return  (moreThanFiveLateDeliveries()) ? 2 : 1
}
function moreThanFiveLateDeliveries() {
    return _numberOfLateDeleveries > 5
}
  ```

  => 

  ```
function getRating() {
    return  (_numberOfLateDeleveries > 5()) ? 2 : 1
}
   ```

> 日常开发中组织函数需要把握得恰到好处，不可过渡提炼函数，也不可将所有代码集中在一个函数中

- 用变量代替复杂函数

  动机：表达式有可能非常复杂而且难以阅读。这种情况下，临时变量可以帮助你将表达式分解为比较容易管理的形式

  ```
  if((platform.toUpperCase().indexOf('mac')>-1) &&
  (browser.toUpperCase().indexOf("IE") > -1) &&
  resize >0) {
    // do somethine
  }
  ```

  =>

  ```
const isMacOs = platform.toUpperCase().indexOf('mac')>-1
  const isIEBrowser = browser.toUpperCase().indexOf("IE") > -1
  const wasResized = resize >0

  if(isMacOs && isIEBrowser && wasResized) {
    // do something
  }
  ```