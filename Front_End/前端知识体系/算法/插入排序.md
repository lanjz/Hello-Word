> 第一次遍历，取第二个元素，那么第1个元素就是已经排好的数组，将这个元素插入到已排好的数组中

> 第二次遍历，取第三个元素，那么第1个元素到第二个元素就是已经排好的数组，将这个元素插入到已排好的数组中

> 以此类推，直到最后一元素插入完成

![](http://upload-images.jianshu.io/upload_images/5797628-2be1cebe71ae4897?imageMogr2/auto-orient/strip)

```
const arr = [1, 20, 10, 30, 22, 11, 55, 24, 31, 88, 12, 40, 50];
let count = 0;
    for(let i = 0; i < arr.length; i++) {
        let temp = arr[i];
        for (let j = 0; j < i; j++) {
            count += 1
            if (temp < arr[j] && j === 0) {
                arr.splice(i, 1);
                arr.unshift(temp);
                break;
            } else if (temp > arr[j] && temp < arr[j + 1] && j < i - 1) {
                arr.splice(i, 1);
                arr.splice(j + 1, 0, temp);
                break;
            }

        }
    }
    console.log('arr', arr, count)
   // [1, 10, 11, 12, 20, 22, 24, 30, 31, 40, 50, 55, 88] 59
```

### 性能

- 时间复杂度：平均算法复杂度为O(n^2)

- 空间复杂度：辅助空间为常数，空间复杂度是O(1)
