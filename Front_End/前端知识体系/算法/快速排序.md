> 选择一个数作为参照数，遍历剩余数据，比参数照小的放在参照数的左边，反之后在右边。
> 然后用同样的方式递归那两个分出来的数据，直接分出来的数组数量为1时，停止循环

![](http://upload-images.jianshu.io/upload_images/5797628-fddd744cb94ff9ea?imageMogr2/auto-orient/strip)

```
	let count = 0;
	const data =  [1, 20, 10, 30, 22, 11, 55, 24, 31, 88, 12, 40, 50];
	function quickSort(arr) {
		if(arr.length <= 1) {
			return arr
        }
		const flag = arr[0]
		const left = []
		const right = []
		for(let i = 1; i< arr.length; i++) {
			if(arr[i] > flag) {
				right.push(arr[i])
			} else {
				left.push(arr[i])
			}
			count += 1
		}
		return quickSort(left).concat([flag], quickSort(right))
	}
	const result = quickSort(data)
	console.log('resultArr', result, count)
   // [1, 10, 11, 12, 20, 22, 24, 30, 31, 40, 50, 55, 88] 41
```

### 性能

- 时间复杂度：平均时间复杂度O(nlogn)，只有在特殊情况下会是O(n^2)，不过这种情况非常少

- 空间复杂度：辅助空间是logn，所以空间复杂度为O(logn)
