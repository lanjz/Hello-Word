## 模板方法模式(Template Method Pattern)

模板方法模式是一种利用继承实现的非常简单的设计模式。模板方法模式由两部分构成，一部分是抽象父类，一部分是具体实现的子类。
父类用来实现算法级的架构和子类方法的实现顺序，而子类用来实现具体的步骤逻辑。这样子类就能在不改变算法架构的情况下，重新定义算法中的某些步骤。

举一个最经典的咖啡与茶的例子，假设我们泡一杯咖啡的步骤是:

- 把水煮沸

- 沸水冲泡咖啡

- 把咖啡倒进杯子

- 加糖和牛奶

而泡一壶茶的步骤是:

- 把水煮沸

- 沸水冲泡茶叶

- 把茶倒进杯子

- 加柠檬

我们可以发现，泡一杯咖啡喝泡一杯茶的过程是大同小异的，经过抽象我们可以整理为以下四个步骤:

- 煮沸水

- 沸水冲泡特定材料

- 将饮料倒进杯子

- 加调料

因此从代码的角度而言，具体的步骤实现的逻辑可能有所不同，但实际的执行顺序确实相同的。因此我们可以在父类中提取出对应的模板方法:

```
var Beverage = function( param ){

    var boilWater = function(){
        console.log("煮沸水");
    };

    var brew = param.brew || function(){
        throw new Error("子类必须重写")
    };

    var pourInCup = param.pourInCup || function(){
        throw new Error("子类必须重写")
    };

    var addCondiments = param.addCondiments || function(){
        throw new Error("子类必须重写")
    };

    var F = function(){};

    F.prototype.init = function(){
        boilWater();
        brew();
        pourInCup();
        addCondiments();
    };

    return F;
};

var Coffee = Beverage({
    brew: function(){
        console.log("沸水冲泡咖啡");
    },
    pourInCup: function(){
        console.log("把咖啡倒进杯子");
     },
     addCondiments: function(){
        console.log("加入糖和牛奶");
     }
});

var Tea = Beverage({
    brew: function(){
        console.log("沸水冲泡茶叶");
    },
    pourInCup: function(){
        console.log("把茶倒进杯子");
     },
     addCondiments: function(){
        console.log("加柠檬");
     }
});

var coffee = new Coffee();
coffee.init();

var tea = new Tea();
tea.init();

```

模板方式模式在前端开发中，尤其是框架层面的设计中非常常见，例如React中，各个组件生命周期函数执行顺序总是不变的，
是由React内部封装了模板方法，而各个组件的生命周期函数内部实现细节是不相同的。不仅如此，在模板方法模式中，某些方法足够特殊，
可能需要跳过执行某些方法，这个时候我们就可以采用钩子函数(hook)，是否需要挂钩，这是由子类自行决定的，
钩子函数的返回决定了模板方法后面部分的执行步骤。例如，React就提供了shouldComponentUpdate这个方法，
让子类自行决定是否需要执行接下来重新渲染的步骤。

模板方法模式能很好的将变化的逻辑封装在子类，而将不变的逻辑抽象到父类，我们通过增加新的子类，就能不断的为系统扩展新的功能，符合开发-闭合原则。

## 迭代器模式(Iterator Pattern)

迭代器模式指的是提供一种方法顺序访问聚合对象中的元素并且不暴露对象内部的表示。大部分语言都内置了迭代器实现，JavaScript从ES5就对数组提供了forEach的迭代器。

```
var arr = [1,2,3,4];
arr.forEach((value, index) => 
    console.log("index: ", index, " value: ", value)
)

```

迭代器分为内部迭代器和外部迭代器，内部迭代器是指内部已经定义好迭代规则，完全接手整个迭代调用。例如上面提到的forEach函数。

## 观察者模式(Observer Pattern)

观察者模式又称为发布-订阅者模式，用于定义对象间一对多的关系，当发布者改变时，所有的订阅者都会得到通知。观察者模式在前端开发中使用十分广泛，最常见的就是事件模型

```
class Event {
    clientList = {};

    listen(key, fn){
        if ( !this.clientList[ key ] ){
            this.clientList[ key ] = [];
        }
        this.clientList[ key ].push(fn);
    }

    trigger(key, ...args){
        let fns = this.clientList[ key ];

        if ( !fns || fns.length === 0 ){
            return false;
        }

        for( var i = 0, fn; fn = fns[ i++ ]; ){
            fn.apply( this, args );
        }
    }
}

let event = new Event();
event.listen("click",  () => {
    console.log("click");
})

event.trigger("click");
```

## 中介者模式

中介者模式主要用来解除对象与对象之间N:N复杂的耦合关系，通过引入中介者，所有的对象都只与中介者对象关联，将复杂的N:N网状关系变为相对简单的1:N关联

```
<body>
  选择颜色: 
  <select id="colorSelect">
    <option value="">请选择</option>
    <option value="red">红色</option>
    <option value="blue">蓝色</option>
  </select>
  选择内存: 
  <select id="memorySelect">
    <option value="">请选择</option>
    <option value="32G">32G</option>
    <option value="16G">16G</option>
  </select>
  输入购买数量: <input type="text" id="numberInput"/><br/>
  <!--输入部分结束-->
  
  您选择了颜色: <div id="colorInfo"></div><br/>
  您选择了内存: <div id="memoryInfo"></div><br/>
  您输入了数量: <div id="numberInfo"></div><br/>
  <button id="nextBtn" disabled="true">请选择手机颜色和购买数量</button>
<body>

```

```
// 各种手机库存（通常来自于后端，这里前端进行模拟）
var goods = { 
  "red|32G": 3,
  "red|16G": 0,
  "blue|32G": 1,
  "blue|16G": 6
};
// 中介者
var mediator = (function(){
  // 获得所有节点的引用，以便对其进行操作（中介者必许获得对其他对象的引用）
  var colorSelect = document.getElementById( 'colorSelect' ),
    memorySelect = document.getElementById( 'memorySelect' ),
    numberInput = document.getElementById( 'numberInput' ),
    colorInfo = document.getElementById( 'colorInfo' ),
    memoryInfo = document.getElementById( 'memoryInfo' ),
    numberInfo = document.getElementById( 'numberInfo' ),
    nextBtn = document.getElementById( 'nextBtn' );
  return {
    changed( obj ){
      var color = colorSelect.value, // 颜色
        memory = memorySelect.value,// 内存
        number = numberInput.value, // 数量
        stock = goods[ color + '|' + memory ]; // 颜色和内存对应的手机库存数量
      if ( obj === colorSelect ){ // 如果改变的是选择颜色下拉框
        colorInfo.innerHTML = color;
      }else if ( obj === memorySelect ){
        memoryInfo.innerHTML = memory;
      }else if ( obj === numberInput ){
        numberInfo.innerHTML = number;
      }
      if ( !color ){
        nextBtn.disabled = true;
        nextBtn.innerHTML = '请选择手机颜色';
        return;
      }
      if ( !memory ){
        nextBtn.disabled = true;
        nextBtn.innerHTML = '请选择内存大小';
        return;
      }
      if ( ( ( number - 0 ) | 0 ) !== number - 0 ){ // 输入购买数量是否为正整数
        nextBtn.disabled = true;
        nextBtn.innerHTML = '请输入正确的购买数量';
        return;
      }
      nextBtn.disabled = false;
      nextBtn.innerHTML = '放入购物车';
    }
  }
})();
// 与中介者联系起来，事件函数
colorSelect.onchange = function(){
  mediator.changed( this );
};
memorySelect.onchange = function(){
  mediator.changed( this );
};
numberInput.oninput = function(){
  mediator.changed( this );
};
```

通过引入中介者对象，所有的节点对象只跟中介者通信。当下拉选择框colorSelect、memorySelect和文本输入框numberInput发生了事件行为时，它们仅仅通知中介者它们被改变了，同时把自身当作参数传入中介者，以便中介者辨别是谁发生了改变。剩下的所有事情都交给中介者对象来完成，这样一来，无论是修改还是新增节点，都只需要改动中介者对象里的代码。

中介者模式使各个对象之间得以解耦，以中介者和对象之间的一对多关系取代了对象之间的网状多对多关系。各个对象只需关注自身功能的实现，对象之间的交互关系交给了中介者对象来实现和维护。中介者模式也存在一些缺点。其中，最大的缺点是系统中会新增一个中介者对象，因为对象之间交互的复杂性，转移成了中介者对象的复杂性，使得中介者对象经常是巨大的。中介者对象自身往往就是一个难以维护的对象。

## 工厂模式

```
// 某个需要创建的具体对象
    class Product {
        constructor (name) {
            this.name = name;
        }
        init () {}
    }
    // 工厂对象
    class Creator {
        create (name) {
            return new Product(name);
        }
    }
    const creator = new Creator();
    const p = creator.create(); // 通过工厂对象创建出来的具体对象
```

应用场景：JQuery中的$、Vue.component异步组件、React.createElement等



