假设有几个DOM节点

![](https://user-images.githubusercontent.com/27856388/52606290-118a3180-2ead-11e9-86b7-d0feae6f8030.png)

## 深度优先遍历

深度优先遍历DFS 与树的先序遍历比较类似。
假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。

深度遍历一：

```
    var deepTraversal1 = (note, nodeList = []) => {
        if(node) {
            nodeList.push(node)
        }
        const child = node.children
        child.forEach(item => {
            deepTraversal1(item, nodeList)
        })
        return nodeList
    }
```

深度遍历二：

```
let deepTraversal2 = (node) => {
    let nodes = []
    if (node !== null) {
      nodes.push(node)
      let children = node.children
      for (let i = 0; i < children.length; i++) {
        nodes = nodes.concat(deepTraversal2(children[i]))
      }
    }
    return nodes
  }
```

非递归的非深度遍历三：

```
 var deepTraversal1 = (node) => {
        let nodeList = []
        let stack = []
        if(node) {
            stack.push(node)
        }
        while (node.length){
            let curNode = node.pop()
            nodeList.push(curNode)
            let child =  nodeList.children
            // 考虑到往curNode添加节点时，是优先添加节点的节点，所以这里倒着循环
            for(let i = child.length - 1; i >= 0; i--) {
                stack.push(child[i])
            }
        }
        return nodeList
    }
```

![](https://user-images.githubusercontent.com/27856388/52606984-88282e80-2eaf-11e9-8640-5220d1d2dc74.png)

## 广度优先遍历

广度优先遍历 BFS
从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。 如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。

执行方式：

```
let widthTraversal2 = (node) => {
  let nodes = []
  let stack = []
  if (node) {
    stack.push(node)
    while (stack.length) {
      let item = stack.shift()
      let children = item.children
      nodes.push(item)
        // 队列，先进先出
        // nodes = [] stack = [parent]
        // nodes = [parent] stack = [child1,child2,child3]
        // nodes = [parent, child1] stack = [child2,child3,child1-1,child1-2]
        // nodes = [parent,child1,child2]
      for (let i = 0; i < children.length; i++) {
        stack.push(children[i])
      }
    }
  }
  return nodes
}
```

![](https://user-images.githubusercontent.com/27856388/52607770-63818600-2eb2-11e9-9f5e-fc3e87950cd2.png)