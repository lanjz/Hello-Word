> [实现深拷贝](https://github.com/lanjz/Hello-Word/blob/master/Front_End/%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0/%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D.md)

> [第5题：介绍下深度优先遍历和广度优先遍历，如何实现？](https://github.com/lanjz/Hello-Word/blob/master/Front_End/%E5%A3%B9%E9%A2%98/%E7%AC%AC5%E9%A2%98%EF%BC%9A%E4%BB%8B%E7%BB%8D%E4%B8%8B%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F.md)

# 深度优先拷贝函数

一般遍历写出来的拷贝函数就是深度优先的

```javascript
   function deepCopy(data) {
		const type = getType(data)
        let obj
        if(type === 'Array' || type === 'Object') {
			obj = type === 'Array' ? [] : {}
			for(let i in data) {
				obj[i] = deepCopy(data[i])
            }
            return obj
        }
        return obj
	}
```

# 广度优先拷贝函数 

```javascript
	function broadCopy(data = {}) {
		let el = getType(data) === 'Array' ? [] : {}
		const oldArr = [data]
		const newArr = [el]
		let curOldNode = oldArr.shift()
		let curNewNode = newArr.shift()
		while (curOldNode) {
			for(let i in curOldNode) {
                if(getType(curOldNode[i]) === 'Array' || getType(curOldNode[i]) === 'Object'){
					const inEl = getType(curOldNode[i]) === 'Array' ? [] : {}
					curNewNode[i] = inEl
					oldArr.push(curOldNode[i])
					newArr.push(inEl)
                } else {
					curNewNode[i] = curOldNode[i]
                }
            }
			curOldNode = oldArr.shift()
			curNewNode = newArr.shift()

		}
		return el
	}
```



