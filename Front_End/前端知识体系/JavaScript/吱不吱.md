## forEach和map的区别

- `forEach`: 更改原始数组的元素

- `map`: 会分配内存空间存储新数组并返回，forEach()不会返回数据

```
var a = [1,3]
a.map(item => item = item+1) // [2,4]
console.log(a) // [1,3]
```

## for,foreach，map的性能

`for > forEach > map `

- `for` 循环是最简单的，因为它没有任何额外的函数调用栈和上下文

- `forEach` 其次，因为它其实比我们想象得要复杂一些，它的函数签名实际上是

  `array.forEach(function(currentValue, index, arr), thisValue)`
  
  它不是普通的 `for` 循环的语法糖，还有诸多参数和上下文需要在执行的时候考虑进来，这里可能拖慢性能

- `map` 最慢，因为它的返回值是一个等长的全新的数组，数组创建和赋值产生的性能开销很大

## for...of可以用在对象中么

答案是不行

`for...of`语句只用在可迭代对象，即实现了`[Symbol.iterator]`方法的对象，比如`Array`，`Map`，`Set`，`String`，`TypedArray`，`arguments`对象等等）

现可迭代协议的对象：

```
var iterable = {
  [Symbol.iterator]() {
    return {
      i: 0,
      next() {
        if (this.i < 3) {
          return { value: this.i++, done: false };
        }
        return { value: undefined, done: true };
      }
    };
  }
};

for (var value of iterable) {
  console.log(value);
}
```

## indexof和includes

- `indexof`:

  - 可返回某个指定的字符串值在字符串中首次出现的位置。是额、ES5的方法，也可以对字符串使用
  
  - 对大小写敏感。
  
  - 它内部使用相等运算符（===）进行判断，这会导致对NaN的误判
  
- `includes`:

  - 检查是否数组包含某些元素，返回true或false，是ES6的方法，也可以对字符串使用
  
`indexof`和`includes`的性能？

## ES6新增数组遍历方法

- `some()`

- `findIndex()`

- `find()`

- `filter()`

- `map()`

- `every()`

- `forEach()` ? 

- `reduce()` ?


## 高阶函数

一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。

## 柯里化

>> [大佬，JavaScript 柯里化，了解一下?](https://juejin.im/post/5af13664f265da0ba266efcf)

柯里化, 即 Currying 的音译。 Currying 是编译原理层面实现多参函数的一个技术

Currying 为实现多参函数提供了一个递归降解的实现思路——把接受多个参数的函数变换成接受一
个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数，
在某些编程语言中（如 Haskell），是通过 Currying 技术支持多参函数这一语言特性的。

如下例子：
```
function add(x, y) {
  return x+y
}
// 柯里化函数
function curringAdd(x){
  return function(y) {
     return x+y 
  }
}
function addd(x, y, z) {
  return x+y+z
}
// 柯里化函数
function curringAddd(x){
    return function(y) {
      return function (z) {
        return x+y+z
      }
    }
}
```

对 `curriedAdd` 进行抽象，可能会得到如下函数 `currying`

```
function currying(fn, ...arg1) {
    if(arg1.length >= fn.length){
        return fn(...arg1)
    }
    return (...arg2) => {
        return currying(fn, ...arg1, ...arg2)
    }
}
// 对add进行转换
currying(add, 1)(2)
// 对addd进行转换
currying(add, 1)(2)(3)
// 或者
currying(add, 1)(2, 3)
```

### currying的使用场景

**参数复用**

固定不变的参数，实现参数复用是 `Currying` 的主要用途之一,如下：

```
const base = currying(add, 10)
// 复用第一个参数10
base(10) // 20
base(15) // 25
```
  
## 为什么0.1 + 0.2 != 0.3，请详述理由

因为JS使用的浮点运行标准是IEEE754（64位），并且只要采用IEEE754的语言都有该问题 

### 原因

计算机在计算的时候是没办法直接按十进制计算的。所以计算机在计算的时候分成的两个部分

- 选择按照IEEE754转成相应的二进制

- 对阶运算后，再转回十进制

**1.进制转换**

0.1的二进制表示为0.0001100110011001100110011001100110011001100110011001101（无限循环）

0.2的二进制表示为0.001100110011001100110011001100110011001100110011001101（无限循环）

但是由于IEEE754尾数位限制，需要将后面多余的位截掉，那么尾数部分就会发生进位，所以精度就发生了损失

**2.对阶运算**

对阶运算这部分也可能产生精度损加上之前转二进制时精度就发生了变化，所以对阶运算后结果得到的结果是

`0.0100110011001100110011001100110011001100110011001100 `

这个二进制转换成十进制之后就是`0.30000000000000004`

### 怎么解决精度问题

如果对计算结果的小数点位数精度不是特别高的话，可以使用`toFixed()`方法截取位数

`parserFloat(0.1+0.2).toFixed(2) // 0.30`

如果精度要求高，那就使用第三个库[Math.js](https://github.com/josdejong/mathjs)、[big.js](https://github.com/MikeMcl/big.js/)

### 其它思考

**为什么`x=0.1`能等到`0.1`**

标准中规定尾数f的固定长度是52位，再加上省略的一位，这53位是JS精度范围。它最大可以表示2^53(9007199254740992), 长度是 16，
所以可以使用 toPrecision(16) 来做精度运算，超过的精度会自动做凑整处理

```
(0.1).toPrecision(16) // 0.1000000000000000

(0.1).toPrecision(21) // 0.100000000000000005551
```

**js最大安全数是 Number.MAX_SAFE_INTEGER == Math.pow(2,53) - 1, 而不是Math.pow(2,52) - 1, why？**

这是因为二进制表示有效数字总是1.xx…xx的形式，尾数部分f在规约形式下第一位默认为1（省略不写，xx..xx为尾数部分f，最长52位）。
因此，JavaScript提供的有效数字最长为53个二进制位（64位浮点的后52位+被省略的1位）

### 总结

精度损失可能出现在进制转化和对阶运算过程中，只要这两步产生了精度损失，计算结果就会出现偏差。

平时工作如果有涉及到浮点数的计算时，一定要注意一下了呐

## super的作用

`super`表示父类的构造函数，用来新建父类的`this对象`.
 
子类必须在`constructor`方法中调用`super`方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，
得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用`super`方法，子类就得不到`this对象`


## ES6中的calls的静态属性和方法

- 只能通过类来访问

- 不能被实例继承

- 可以被子类继承

- 可以从`super`对象上调用

## 前端可能出现的代码泄漏

- 意外的全局变量

  js对未声明变量会在全局最高对象上创建它的引用，（是以属性存在的，而不是变量），如果在浏览器上就是window对象，
  如果在node环境下就是global;如果未声明的变量缓存大量的数据，它可能只有在页面被刷新或者被关闭的时候才会释放内存，
  这样就造成了内存意外泄漏
  
- console.log

  作为前端平时使用console.log在控制台打出相对应的信息可以说是非常常见。但如果没有去掉console.log可能会存在内存泄漏。因为在代码运行之后需要在开发工具能查看对象信息，所以传递给console.log的对象是不能被垃圾回收。
  
- 闭包

  首先闭包是一个函数A返回一个内联的函数B，即使A函数执行完，函数B也可以访问函数A里面的变量，这就是一个简单的闭包。本质上闭包是将函数内部和外部连接起来的一座桥梁
  
- DOM泄漏

  浏览器中DOM和js采用的是不一样的引擎，DOM采用的是渲染引擎，而js采用的是v8引擎，所以在用js操作DOM时会比较耗费性能，因为他们需要桥来链接他们。为了减少DOM的操作，我们一般将常用的DOM采用变量引用的方式会将其缓存在当前环境。如果在进行一些删除、更新操作之后，可能会忘记释放已经缓存的DOM
  
- 被遗忘的timers

  js中常用的定时器setInterval()、setTimeout()，他们都是规定延迟一定的时间执行某个代码，而其中setInterval()和链式setTimeout()在使用完之后如果没有手动关闭，会一直存在执行占用内存，所以在不用的时候我们可以通过clearInterval()、clearTimeout() 来关闭其对应的定时器，释放内存
  
## 如何在 ES5 环境下实现一个cons

由于ES5环境没有block的概念，所以是无法百分百实现const，只能是挂载到某个对象下，要么是全局的window，要么就是自定义一个object来当容器

```
      var __const = function __const (data, value) {
        window.data = value // 把要定义的data挂载到window下，并赋值value
        Object.defineProperty(window, data, { // 利用Object.defineProperty的能力劫持当前对象，并修改其属性描述符
          enumerable: false,
          configurable: false,
          get: function () {
            return value
          },
          set: function (data) {
            if (data !== value) { // 当要对当前属性进行赋值时，则抛出错误！
              throw new TypeError('Assignment to constant variable.')
            } else {
              return value
            }
          }
        })
      }
      __const('a', 10)
      console.log(a)
      delete a
      console.log(a)
      for (let item in window) { // 因为const定义的属性在global下也是不存在的，所以用到了enumerable: false来模拟这一功能
        if (item === 'a') { // 因为不可枚举，所以不执行
          console.log(window[item])
        }
      }
      a = 20 // 报错

```

## 属性描述符

**对象里目前的属性描述符有两种：**

- 数据描述符：具有值的属性

- 存取描述符：由getter与setter函数对描述的属性

### 描述符功能

数据描述符与存取描述符皆可修改:

- configurable：当前对象元素的属性描述符是否可改，是否可删除

- enumerable：当前对象元素是否可枚举

唯有数据描述符可以修改：

- value: 当前对象元素的值

- writable：当前对象元素的值是否可修改

唯有存取描述符可以修改：:

- get：读取元素属性值时的操作

- set：修改元素属性值时的操作

## 图片base64压缩后变大还是变小，如何提高性能的

BASE64 搞出来的图片通常尺寸会大上 30% 左右

优化的话：

- 小图片才用base64

- 如果 base64 是被编码到 css/js 中，是可以缓存的，因为 css/js 文件可以缓存