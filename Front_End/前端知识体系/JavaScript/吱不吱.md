## forEach和map的区别

- `forEach`: 更改原始数组的元素

- `map`: 会分配内存空间存储新数组并返回，forEach()不会返回数据

```
var a = [1,3]
a.map(item => item = item+1) // [2,4]
console.log(a) // [1,3]
```

## for,foreach，map的性能

`for > forEach > map `

- `for` 循环是最简单的，因为它没有任何额外的函数调用栈和上下文

- `forEach` 其次，因为它其实比我们想象得要复杂一些，它的函数签名实际上是

  `array.forEach(function(currentValue, index, arr), thisValue)`
  
  它不是普通的 `for` 循环的语法糖，还有诸多参数和上下文需要在执行的时候考虑进来，这里可能拖慢性能

- `map` 最慢，因为它的返回值是一个等长的全新的数组，数组创建和赋值产生的性能开销很大

## for...of可以用在对象中么

答案是不行

`for...of`语句只用在可迭代对象，即实现了`[Symbol.iterator]`方法的对象，比如`Array`，`Map`，`Set`，`String`，`TypedArray`，`arguments`对象等等）

现可迭代协议的对象：

```
var iterable = {
  [Symbol.iterator]() {
    return {
      i: 0,
      next() {
        if (this.i < 3) {
          return { value: this.i++, done: false };
        }
        return { value: undefined, done: true };
      }
    };
  }
};

for (var value of iterable) {
  console.log(value);
}
```

## indexof和includes

- `indexof`:

  - 可返回某个指定的字符串值在字符串中首次出现的位置。是额、ES5的方法，也可以对字符串使用
  
  - 对大小写敏感。
  
  - 它内部使用相等运算符（===）进行判断，这会导致对NaN的误判
  
- `includes`:

  - 检查是否数组包含某些元素，返回true或false，是ES6的方法，也可以对字符串使用
  
`indexof`和`includes`的性能？

## ES6新增数组遍历方法

- `some()`

- `findIndex()`

- `find()`

- `filter()`

- `map()`

- `every()`

- `forEach()` ? 

- `reduce()` ?


## 高阶函数

一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。

## 柯里化

>> [大佬，JavaScript 柯里化，了解一下?](https://juejin.im/post/5af13664f265da0ba266efcf)

柯里化, 即 Currying 的音译。 Currying 是编译原理层面实现多参函数的一个技术

Currying 为实现多参函数提供了一个递归降解的实现思路——把接受多个参数的函数变换成接受一
个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数，
在某些编程语言中（如 Haskell），是通过 Currying 技术支持多参函数这一语言特性的。

如下例子：
```
function add(x, y) {
  return x+y
}
// 柯里化函数
function curringAdd(x){
  return function(y) {
     return x+y 
  }
}
function addd(x, y, z) {
  return x+y+z
}
// 柯里化函数
function curringAddd(x){
    return function(y) {
      return function (z) {
        return x+y+z
      }
    }
}
```

对 `curriedAdd` 进行抽象，可能会得到如下函数 `currying`

```
function currying(fn, ...arg1) {
    if(arg1.length >= fn.length){
        return fn(...arg1)
    }
    return (...arg2) => {
        return currying(fn, ...arg1, ...arg2)
    }
}
// 对add进行转换
currying(add, 1)(2)
// 对addd进行转换
currying(add, 1)(2)(3)
// 或者
currying(add, 1)(2, 3)
```

### currying的使用场景

**参数复用**

固定不变的参数，实现参数复用是 `Currying` 的主要用途之一,如下：

```
const base = currying(add, 10)
// 复用第一个参数10
base(10) // 20
base(15) // 25
```
  
## 为什么0.1 + 0.2 != 0.3，请详述理由

因为JS使用的浮点运行标准是IEEE754（64位），并且只要采用IEEE754的语言都有该问题 

### 原因

计算机在计算的时候是没办法直接按十进制计算的。所以计算机在计算的时候分成的两个部分

- 选择按照IEEE754转成相应的二进制

- 对阶运算后，再转回十进制

**1.进制转换**

0.1的二进制表示为0.0001100110011001100110011001100110011001100110011001101（无限循环）

0.2的二进制表示为0.001100110011001100110011001100110011001100110011001101（无限循环）

但是由于IEEE754尾数位限制，需要将后面多余的位截掉，那么尾数部分就会发生进位，所以精度就发生了损失

**2.对阶运算**

对阶运算这部分也可能产生精度损加上之前转二进制时精度就发生了变化，所以对阶运算后结果得到的结果是

`0.0100110011001100110011001100110011001100110011001100 `

这个二进制转换成十进制之后就是`0.30000000000000004`

### 怎么解决精度问题

如果对计算结果的小数点位数精度不是特别高的话，可以使用`toFixed()`方法截取位数

`parserFloat(0.1+0.2).toFixed(2) // 0.30`

如果精度要求高，那就使用第三个库[Math.js](https://github.com/josdejong/mathjs)、[big.js](https://github.com/MikeMcl/big.js/)

### 其它思考

**为什么`x=0.1`能等到`0.1`**

标准中规定尾数f的固定长度是52位，再加上省略的一位，这53位是JS精度范围。它最大可以表示2^53(9007199254740992), 长度是 16，
所以可以使用 toPrecision(16) 来做精度运算，超过的精度会自动做凑整处理

```
(0.1).toPrecision(16) // 0.1000000000000000

(0.1).toPrecision(21) // 0.100000000000000005551
```

**js最大安全数是 Number.MAX_SAFE_INTEGER == Math.pow(2,53) - 1, 而不是Math.pow(2,52) - 1, why？**

这是因为二进制表示有效数字总是1.xx…xx的形式，尾数部分f在规约形式下第一位默认为1（省略不写，xx..xx为尾数部分f，最长52位）。
因此，JavaScript提供的有效数字最长为53个二进制位（64位浮点的后52位+被省略的1位）

### 总结

精度损失可能出现在进制转化和对阶运算过程中，只要这两步产生了精度损失，计算结果就会出现偏差。

平时工作如果有涉及到浮点数的计算时，一定要注意一下了呐
