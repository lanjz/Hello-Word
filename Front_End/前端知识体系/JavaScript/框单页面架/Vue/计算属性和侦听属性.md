# 计算属性

以一下例子为例：

```
var vm = new Vue({
  data: {
    firstName: 'Foo',
    lastName: 'Bar'
  },
  computed: {
    fullName: function () {
      return this.firstName + ' ' + this.lastName
    }
  }
})
```

然后当我们的 `render` 函数执行访问到 `this.fullName` 的时候，就触发了计算属性的 `getter`，此时的`getter`执行的代码为：

```

function createComputedGetter (key) {
  return function computedGetter () {
    const watcher = this._computedWatchers && this._computedWatchers[key]
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate()
      }
      if (Dep.target) {
        watcher.depend()
      }
      return watcher.value
    }
  }
}

```

它会拿到计算属性对应的 `watcher`，然后执行 `watcher.depend()`，来看一下它的定义：

```
depend () {
  if (this.dep && Dep.target) {
    this.dep.depend()
  }
}
```

`this.dep.depend()`，这个`this`是当前`computed watcher`, `this.dep.depend()`执行以下代码：

```
depend () {
    if (Dep.target) {
      Dep.target.addDep(this)
    }
  }

```

** 注意，这时候的 `Dep.target` 是渲染 watcher，所以 `this.dep.depend()` 相当于渲染 watcher 订阅了这个 `computed watcher` 的变化。 **

然后再执行 `watcher.evaluate()` 去求值，来看一下它的定义:

```
evaluate () {
  if (this.dirty) {
    this.value = this.get()
    this.dirty = false
  }
  return this.value
}
```

在求值过程中，会执行 `value = this.getter.call(vm, vm)`，这实际上就是执行了计算属性定义的 `getter` 函数，在我们这个例子就是执行了 `return this.firstName + ' ' + this.lastName`。

** 这里需要特别注意的是，由于 `this.firstName` 和 `this.lastName` 都是响应式对象，这里会触发它们的 `getter`，根据我们之前的分析，它们会把自身持有的 `dep` 添加到当前正在计算的 `watche` 中，这个时候 `Dep.target` 就是这个 `computed watcher`。**

最后通过 `return this.value` 拿到计算属性对应的值。我们知道了计算属性的求值过程，那么接下来看一下它依赖的数据变化后的逻辑。

一旦我们对计算属性依赖的数据做修改，则会触发 `setter` 过程，通知所有订阅它变化的 `watcher` 更新，执行 `watcher.update()` 方法，实质上执行`run`方法：

```
 run () {
    if (this.active) {
      const value = this.get()
      if (
        value !== this.value ||
        // Deep watchers and watchers on Object/Arrays should fire even
        // when the value is the same, because the value may
        // have mutated.
        isObject(value) ||
        this.deep
      ) {
        // set new value
        const oldValue = this.value
        this.value = value
        if (this.user) {
          try {
            this.cb.call(this.vm, value, oldValue)
          } catch (e) {
            handleError(e, this.vm, `callback for watcher "${this.expression}"`)
          }
        } else {
          this.cb.call(this.vm, value, oldValue)
        }
      }
    }
```

`run`方法中会重新计算，然后对比新旧值，如果变化了则执行回调函数，那么这里这个回调函数是 `this.dep.notify()`，在我们这个场景下就是触发了渲染 watcher 重新渲染。

VUE处理`data`属性与处理`computed`属性的不同点：

- `data`属性中的 Watcher 的`getter`方法，是一个渲染组件的方法, `computed`属性中的 Watcher 的`getter`方法，是对应的`computed`属性对应的`get`方法

- 在`Object.defineProperty`阶段，`data`属性中的`getter`方法如下：

  ```
    get: function reactiveGetter () {
      const value = getter ? getter.call(obj) : val
      if (Dep.target) {
        dep.depend()
        if (childOb) {
          childOb.dep.depend()
          if (Array.isArray(value)) {
            dependArray(value)
          }
        }
      }
      return value
    },
  ```

  `computed`属性中的`getter`方法如下：

  ```
function createComputedGetter (key) {
  return function computedGetter () {
    const watcher = this._computedWatchers && this._computedWatchers[key] // {key: Watcher}
    if (watcher) {
      watcher.depend()
      return watcher.evaluate()
    }
  }
}
  ```