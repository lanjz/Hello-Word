> [深入响应式原理](https://ustbhuangyi.github.io/vue-analysis/v2/reactive/)

本文主要是结合Vue双向绑定部分的代码，通过简化源代码来理解Vue双向绑定的原理

**实现双向绑定的几个要素：Observer、Watcher、Dep、Compile**

# Observer-监听器

监听器的作用就是监听属性的变化，Vue使用了`Object.defineProperty`方法

## 实现思路

遍历初始化的属性，通过使用`Object.defineProperty`对每个属性进行重新定义

```javascript
class Observer {
	constructor(value) {
		this.walk(value)
	}
	walk(obj) {
		const keys = Object.keys(obj)
		for (let i = 0; i < keys.length; i++) {
			defineReactive(obj, keys[i])
		}
	}
}

function defineReactive(obj, key, val) {
	Object.defineProperty(obj, key, {
		enumerable: true,
		configurable: true,
		get: function () {
			// 读取值了，可以做些事情
			return val
		},
		set: function (newVal) {
			// 值发生变化了，可以做些事情
			if(newVal === val) {
				return
			}
			val = newVal;
		}
	})
	
}
```

# Dep-事件收集（依赖收集）

大部分资料这里叫依赖收集，为了更好理解这里暂时改名叫事件收集，收集当属性发生变化的时候要执行的事件。

## 实现思路

使用观察者模型（发布者-观察者模型）

```javascript
let uid = 0
class Dep {
	constructor() {
		this.id = uid ++
		this.subs = []
	}
	addSub(sub) {
		this.subs.push(sub)
	}
	removeSub(sub) {
		if(this.subs.length) {
			const index = this.subs.indexOf(sub)
			if(index > -1) {
				this.subs.splice(index, 1)
			}
		}
	}
	depend() {
		// Dep.target是一个全局变量
		if(Dep.target) {
			Dep.target.addDep(this)
		}
	}
	notify() {
		console.log('属性变化通知 Watcher 执行更新视图函数');
		const subs = this.subs.slice()
		for (let i = 0, l = subs.length; i < l; i++) {
			subs[i].update()
		}
	}
}

// 这个属性的作用后面再介绍
Dep.target = null

```

## 什么时候执行事件

结合上文的监听器，当属性发生变化时，即`Object.defineProperty`的`set`
属性执行，就是属性发生变化的时候，所以在`set`中执行这些依赖

## 什么时候添加依赖

结合Vue中源码可知，添加依赖是在`Object.defineProperty`的`get`方法中做的，从这里我们可以知道
在Vue初始化渲染页面时候会对属性进行的获取，从而触发了`get`方法添加依赖

完善Observer代码

```javascript
function defineReactive(obj, key, val) {
	const dep = new Dep()
	Object.defineProperty(obj, key, {
		enumerable: true,
		configurable: true,
		get: function () {
			if(Dep.target) {
				dep.depend() // 收集事件
			}
			return val
		},
		set: function (newVal) {
			if(newVal === val) {
				return
			}
			val = newVal;
			dep.notify() // 执行事件
		}
	})
	
}

class Observer {
	constructor(value) {
		this.value = value
		this.walk(value)
	}
	walk(obj) {
		const keys = Object.keys(obj)
		for (let i = 0; i < keys.length; i++) {
			defineReactive(obj, keys[i])
		}
	}
}
```

`get`方法中当存在`Dep.target`时，再执行添加依赖的操作，这里的`Dep.target`是一个`Watcher`实例，接下会介绍

# Watcher-事件

Watcher就是`Dep`具体收集的事件，将Vue的Watcher进行简化：

```javascript
class Watcher {
	constructor(vm, prop, callback) {
		this.vm = vm
		this.getter = callback
		this.newDeps = null
		this.oldDep = null
		this.prop = prop
		this.value = this.get()
	}
	
	get() {
		Dep.target = this; //储存订阅器
		const value = this.getter.call(this.vm); //因为属性被监听，这一步会执行监听器里的 get方法
		Dep.target = null;
		this.cleanupDeps()
		return value
	}
	
	update() {
		this.getter.call(this.vm)
		// this.get()
	}
	
	addDep(dep) {
		this.newDeps = dep
		dep.addSub(this)
	}
	cleanupDeps() {
		if(this.oldDep)  {
			this.oldDep.removeSub(this)
		}
		this.oldDep = this.newDeps
	}
}

```

在Watcher中首先执行`this.get()`方法,`this.get()`中将当前的Watcher实例赋值给`Dep.target`，`Dep.target`
在上文讲的类`Dep`的`depend`有出现过，然后执行`this.getter()`方法，我们简单理解为渲染页面的方法，然后在渲染页面的过程读取属性并收集依赖。

这里先整理一下依赖收集执行步骤

1. 先实例化一个`Watcher`，并将这个实例赋值给全局属性`Dep.target`，并执行一个参数函数`getter`(这个回调函数中会访问数据属性)

2. 访问属性触发`Object.defineProperty`中的`get`的方法

3. `Object.defineProperty`中的`get`的方法中执行`dep.depend()`

4. `dep.depend()`中再执行`Dep.target.addDep(this)`，也就是执行Watcher中的`addDep`,这里的参数`this`就是当前的收集依赖`Dep`实例，

5. Watcher中的`addDep(dep)`中将参数(`Dep`实例)，取出执行`dep.addSub(this)`方法，将当前的`this`（Watcher）保存到`Dep`中

这块的过程有点不易理解，说白了就是绕!!因为常归的思路步骤应该像下面这样：

1. 实例一个`Watcher`

2. 将这个`Watcher`作为参数执行`Dep`的上`depend`方法，直接完成收集

而Vue中则是通过一个全局属性`Dep.target`做了类似中转的作用，将`Dep`反传到`Watcher`的`addDep`方法中做了收集这么一个动作

## 什么时候实现化一个`Watcher`

在上文有提到在初始渲染页面的时候，具体过程继续往下走

# Compiler

即模板解析，Vue的模板编译太过复杂，这里主要是理解了双向绑定，所以先简单实现一个模板解析的功能

实现思路如下：

1. 遍历当前根节点

2. 对所有的子节点进行遍历，查找有特定占位符的符号

3. 当找到有点位符的元素时，实例化`Watcher`，并将模块解析方法作为参数传入

4. 哒哒哒~执行上文提到的步骤

5. 模块解析完后再输出到页面中

```javascript
function Compile(vm) {
	this.vm = vm;
	this.el = vm.$el;
	this.fragment = null;
	this.init();
}

Compile.prototype = {
	init: function () {
		this.fragment = this.nodeFragment(this.el);
		this.compileNode(this.fragment);
		this.el.appendChild(this.fragment); //解析完成添加到元素中
	},
	nodeFragment: function (el) {
		const fragment = document.createDocumentFragment();
		let child = el.firstChild;
		//将子节点，全部移动文档片段里
		while (child) {
			fragment.appendChild(child);
			child = el.firstChild;
		}
		return fragment;
	},
	compileNode: function (fragment) {
		let childNodes = fragment.childNodes;
		[...childNodes].forEach(node => {
			let nodeAttrs = node.attributes; // 获取所有属性
			let nodeType = node.nodeType; // 获取标签类型
			let nodeName = node.nodeName; // 获取标签名
			const findVModel = nodeAttrs ? [ ...nodeAttrs ].find(item => item.name === 'v-model') : false
			// input且有v-model
			if(nodeName.toUpperCase() === 'INPUT' && findVModel) {
				this.compileModel(node, findVModel.value);
			}
			if(nodeType === 3) {
				let reg = /\{\{(.*)\}\}/;
				let text = node.textContent;
				if (reg.test(text)) {
					let prop = reg.exec(text)[1];
					this.compileText(node, prop); //替换模板
				}
			}
			//编译子节点
			if (node.childNodes && node.childNodes.length) {
				this.compileNode(node);
			}
		});
	},
	compileModel: function (node, prop) {
		new Watcher(this.vm, prop, (value) => {
			let val = this.vm._data[prop];
			this.updateModel(node, val);
		});
		
		node.addEventListener('input', e => {
			let newValue = e.target.value;
			this.vm._data[prop] = newValue;
		});
	},
	compileText: function (node, prop) {
		// this.updateView(node, text);
		new Watcher(this.vm, prop, (value) => {
			let text = this.vm._data[prop];
			this.updateView(node, text);
		});
	},
	
	updateModel: function(node, value) {
		node.value = typeof value == 'undefined' ? '' : value;
	},
	updateView: function (node, value) {
		node.textContent = typeof value === 'undefined' ? '' : value;
	},
	isDirective: function (attr) {
		return attr.indexOf('v-') !== -1;
	},
	
	isElementNode: function (node) {
		return node.nodeType === 1;
	},
	isTextNode: function (node) {
		return node.nodeType === 3;
	}
}

```

