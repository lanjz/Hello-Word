# HTTP

> [MDN-HTTP](https://developer.mozilla.org/zh-CN/docs/Web/HTTP)

什么是 HTTP ？ 

- **超文本传输协议**（HTTP）用于传输诸如HTML这样的的网络资源的 protocol(通讯协议)。它通用用于浏览器与Web服务器之间通信。

- HTTP遵循经典的客户端-服务端模型。通常基于TCP/IP层，但可以在任何可靠的传输层上使用，比如UDP

- HTTP 属于应用层协议

## HTTP的性质 

- HTTP协议是构建于TCP/IP协议之上，是一个应用层协议，默认端口是80

- HTTP是简单

  下一代HTTP/2协议将HTTP消息封装到了帧(iframe)中，但大体上还是设计简单易懂（废话）

- HTTP是可扩展的

  通过HTTP中的Headers属性，我们可以方便进行一些扩展

- HTTP是无状态的，有会话的

  在同一个连接中，两个执行成功的请求之间没有任何关系。这就带来一个问题，用户没有办法在同一网站中进行连续的交互，如果在电商网站中，用户把某个商品加入购物车，切换一个而后再添加了商品，这两次添加的商品的请求之间没有关联，浏览器无法知道用户最终选择了哪些商品。而使用HTTP的头部扩展，HTTP Cookies就可以解决这些问题。把Cookies添加到头部，创建一个会话让每个请求都能共享相同的上下文信息，达成相同的状态

  **HTTP是无状态的，但使用Cookies可以创建有状态的会话**

## HTTP报文

**请求报文**

![](https://mdn.mozillademos.org/files/13687/HTTP_Request.png)

一个请求由下以下元素组成：

- Method：请求方法，例如`GET`、`POST`等

- Path：获取资源的路径

- HTTP协议版本号

- 为服务端表达其他信息的可选头部headers

- 对于一些像POST这样的方法，报文的body就包含了发送的资源，这与响应报文的body类似

**响应报文**

![](https://mdn.mozillademos.org/files/13691/HTTP_Response.png)

响应报头包含以下元素：

- HTTP协议版本号

- 一个状态码，来告知对应请求执行成功或失败，以及失败的原因

- HTTP headers，与语法头部类似

- 可选项，比起请求报文，响应报文中多得包含获取资源的body

## HTTP能控制什么

- 缓存：

  文档如何缓存能通过HTTP来控制。服务端能告诉代理和客户端哪些文档需要被缓存，缓存多久，而客户端也能够命令中间的缓存代理来忽略存储的文档。

- 开放同源限制

  为了防止网络窥听和其它隐私泄漏，浏览器强制对Web网站做了分割限制。只有来自于相同来源的网页才能够获取网站的全部信息。这样的限制有时反而成了负担，HTTP可以通过修改头部来开放这样的限制，因此Web文档可以是由不同域下的信息拼接成的（某些情况下，这样做还有安全因素考虑）。

- 认证

  一些页面能够被保护起来，仅让特定的用户进行访问。基本的认证功能可以直接通过HTTP提供，使用Authenticate相似的头部即可，或用HTTP Cookies来设置指定的会话。

- 代理和隧道

  通常情况下，服务器和/或客户端是处于内网的，对外网隐藏真实 IP 地址。因此 HTTP 请求就要通过代理越过这个网络屏障。但并非所有的代理都是 HTTP 代理。例如，SOCKS协议的代理就运作在更底层，一些像 FTP 这样的协议也能够被它们处理。

- 会话

  使用HTTP Cookies允许你用一个服务端的状态发起请求，这就创建了会话。虽然基本的HTTP是无状态协议。这很有用，不仅是因为这能应用到像购物车这样的电商业务上，更是因为这使得任何网站都能轻松为用户定制展示内容了。

## HTTP瓶颈

- 一个连接只能发送一个请求

- 请求只能客户端发起，客户端不可以接收除了响应以外的指令

- 请求/响应未练压缩就发送，首部信息越多延迟越大

- 发送冗余的首部。每次互相发送相同的首部造成的浪费较多

- 可任意选择数据压缩方式。非强制压缩发送

# HTTP 的演变历史

HTTP的演变主有`HTTP/0.9`, `HTTP/1.0`, `HTTP/1.1`, `HTTP/2.0`阶段

## HTTP/0.9

HTTP/0.9 极其简单：请求由单行指令构成，以唯一可用方法GET开头，其后跟目标资源的路径（一旦连接到服务器，协议、服务器、端口号这些都不是必须的）。

## HTTP/1.0

- 默认是短连接, 如需开启长连接, 需要增加 header `Connection: Keep-alive`

- 协议版本信息现在会随着每个请求发送（HTTP/1.0被追加到了GET行）

- 状态码会在响应开始时发送，使浏览器能了解请求执行成功或失败，并相应调整行为（如更新或使用本地缓存）。

- 引入了HTTP头的概念，无论是对于请求还是响应，允许传输元数据，使协议变得非常灵活，更具扩展性。

- 可以使用 `cookie`

**HPPT/1.0 缺点**：

- 每次连接都需要建立一次 TCP 连接

- 队头阻塞（head of line blocking）：由于 HTTP1.0 规定下一个请求必须在前一个请求响应到达之前才能发送。假设前一个请求响应一直不到达，
那么下一个请求就不发送，同样的后面的请求也给阻塞了

## HTTP/1.1

- HTTP1.1 默认开启长连接, `Connection: Keep-alive`

  HTTP1.1增加了一个 `Connection`字段，通过设置`Keep-Alive`可以保持 HTTP 连接不断开，避免了每次客户端与服务器请求都要重复建立释放建立TCP连接，
  提高了网络的利用率。如果客户端想关闭HTTP连接，可以在请求头中携带`Connection: false`来告知服务器关闭请求

- 支持响应分块。

- 引入额外的缓存控制机制。

- 引入内容协商机制，包括语言，编码，类型等，并允许客户端和服务器之间约定以最合适的内容进行交换。

- Host头，能够使不同域名配置在同一个IP地址的服务器上,使得一个服务器能够用来创建多个Web站点

- 是 HTTP1.1 支持请求管道化

  基于HTTP1.1的长连接，使得请求管线化成为可能。管线化使得请求能够“并行”传输。举个例子来说，假如响应的主体是一个html页面，
  页面中包含了很多img，这个时候`keep-alive`就起了很大的作用，能够进行“并行”发送多个请求。（注意这里的“并行”并不是真正意义上的并行传输，具体解释如下。）

  **需要注意的是，服务器必须按照客户端请求的先后顺序依次回送相应的结果，以保证客户端能够区分出每次请求的响应内容**

  假设客户端同时发了两个请求分别来获取 html 和 css ，html请求先到达服务器，即使说服务器的css资源先准备就绪，服务器也会先发送html再发送css

  换句话来说，只有等到html响应的资源完全传输完毕后，css响应的资源才能开始传输。也就是说，不允许同时存在两个并行的响应

  可见，HTTP1.1还是无法解决队头阻塞（head of line blocking）的问题。同时“管道化”技术存在各种各样的问题，所以很多浏览器要么根本不支持它，
  要么就直接默认关闭，并且开启的条件很苛刻...而且实际上好像并没有什么用处。

  那么平时我们所说有浏览器可以并行发送请求是怎么回事呢？

  **实际上，现阶段的浏览器厂商采取了另外一种做法，它允许我们打开多个TCP的会话**， 这才是为什么可以并行发送请求的原因

## HTTP/2

- 由二进制分帧代替文本协议

- 多路复用

- Header压缩

- 服务器Push

- 更安全

# HTTP2

HTTP/2（超文本传输协议第2版，最初命名为HTTP2.0），是HTTP协议的第二个主要版本。HTTP/2是HTTP协议自1999年HTTP1.1发布后的首个更新，主要基于SPDY协议。

## SPDY协议

SPDY是Speedy的昵音，意为“更快”。它是Google开发的基于TCP协议的应用层协议。目标是优化HTTP协议的性能，通过压缩、多路复用和优先级等技术，
缩短网页的加载时间并提高安全性。SPDY协议的核心思想是尽量减少TCP连接数。SPDY并不是一种用于替代HTTP的协议，而是对HTTP协议的增强

## HTTP2.0特点

- 由二进制分帧代替文本协议
  
  HTTP2.0 通过在应用层和传输层之间增加一个二进制分帧层，突破了HTTP1.1的性能限制、改进传输性能
    
  虽然 `HTTP2.0` 的协议和 `HTTP1.x` 协议之间的规范完全不同了，但是实际上 HTTP2.0 并没有改变 HTTP1.x 的语义。
  简单来说，HTTP2.0 只是把原来 HTTP1.x的 `header` 和 `body` 部分用 `frame` 重新封装了一层而已

- 多路复用
  
  下面是几个概念:
    
  - 流（stream）：已建立连接上的双向字节流
    
  - 消息：与逻辑消息对应的完整的一系列数据帧
    
  - 帧（frame）：HTTP2.0通信的最小单位，每个帧包含帧头部，至少也会标识出当前帧所属的流（`stream id`）。
    
  ![](https://segmentfault.com/img/remote/1460000013028805?w=479&h=391)
    
  从图中可见，所有的HTTP2.0通信都在一个TCP连接上完成，这个连接可以承载任意数量的双向数据流
  
  每个数据流以消息的形式发送，而消息由一或多个帧组成。这些帧可以乱序发送，然后再根据每个帧头部的流标识符（stream id）重新组装。
  
  举个例子，每个请求是一个数据流，数据流以消息的方式发送，而消息又分为多个帧，帧头部记录着  `stream id`用来标识所属的数据流，
  不同属的帧可以在连接中随机混杂在一起。接收方可以根据`stream id`将帧再归属到各自不同的请求当中去。
  
  另外，多路复用（连接共享）可能会导致关键请求被阻塞。HTTP2.0里每个数据流都可以设置优先级和依赖，优先级高的数据流会被服务器优先处理和返回给客户端，数据流还可以依赖其他的子数据流。
  
  可见，HTTP2.0实现了真正的并行传输，它能够在一个TCP上进行任意数量HTTP请求。而这个强大的功能则是基于“二进制分帧”的特性。
    
- 压缩Headers

  在HTTP1.x中，我们使用文本的形式传输header，在header中携带cookie的话，每次都需要重复传输几百到几千的字节，这着实是一笔不小的开销。

  在HTTP2.0中，我们使用了`HPACK技术`（HTTP2头部压缩算法）压缩格式对传输的header进行编码，减少了header的大小。并在两端维护了索引表，用于记录出现过的header，后面在传输过程中就可以传输已经记录过的header的键名，对端收到数据后就可以通过键名找到对应的值

- 服务器推送

  在HTTP2.0中，服务端可以在客户端某个请求后，主动推送消息给客户端

- 更安全

  HTTP2.0使用了 TLS 的拓展ALPN做为协议升级，除此之外，HTTP2.0对 TLS 的安全性做了近一步加强，通过黑名单机制禁用了几百种不再安全的加密算法。

## 后HTTP/2

- 对`Alt-Svc`的支持允许了给定资源的位置和资源鉴定，允许了更智能的CDN缓冲机制。

- `Client-Hints` 的引入允许浏览器或者客户端来主动交流它的需求，或者是硬件约束的信息给服务端。

- 在Cookie头中引入安全相关的的前缀，现在帮助保证一个安全的cookie没被更改过

# Q&A

## HTTP Head压缩算法

HTTP1.x的`header`中的字段很多时候都是重复的，例如`method:get`、`status:200`等等，随着网页增长到需要数十到数百个请求，这些请求中的冗余标头字段不必要地消耗带宽，从而显著增加了延迟，因此，`Hpack`技术应时而生

### Hpack思想简介

Hpack的主要思想说明：

- 将`header`里的字段列表视为可包括重复对的`name-value`键值对的有序集合，分别使用8位字节表示`name和value`

- 当字段被编码/解码时，对应的字典会不断扩充

- 在编码形式中，`header`字段可以直接表示，也可以使用`header field tables `中对应的引用。因此，可以使用引用和文字值的混合来`header`字段列表

- 文字值要么直接编码，要么使用静态`huffman`代码

- 编码器负责决定在标题字段表中插入哪些标题字段作为新条目。解码器执行对编码器规定的报头字段表的修改，重建处理中的报头字段列表

> [详解http-2头部压缩算法](https://segmentfault.com/a/1190000017011816)


## HTTP1.1的合并请求是否适用于HTTP2.0

首先，答案是“没有必要”。之所以没有必要，是因为这跟HTTP2.0的头部压缩有很大的关系

在头部压缩技术中，客户端和服务器均会维护两份相同的静态字典和动态字典

在静态字典中，包含了常见的头部名称以及头部名称与值的组合。静态字典在首次请求时就可以使用。那么现在头部的字段就可以被简写成静态字典中相应字段对应的index

可以动态地添加内容。动态字典可以在连接中不听的进行更新

也就是说，原本完整的HTTP报文头部的键值对或字段，由于字典的存在，现在可以转换成索引index，在相应的端再进行查找还原，也就起到了压缩的作用

所以，同一个连接上产生的请求和响应越多，动态字典累积得越全，头部压缩的效果也就越好，所以针对HTTP/2网站，最佳实践是不要合并资源。

另外，HTTP2.0多路复用使得请求可以并行传输，而HTTP1.1合并请求的一个原因也是为了防止过多的HTTP请求带来的阻塞问题。而现在HTTP2.0已经能够并行传输了，所以合并请求也就没有必要了

## 关于服务器push

假如现在需要请求一个页面`index.html`

```
<!DOCTYPE html>
<html>
<head>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <h1>hello world</h1>
  <img src="example.png">
</body>
</html>
```

这个网页包含一张样式表`style.css`和一个图片文件`example.png`。为了渲染这个网页，浏览器会发出三个请求。

1. 第一个请求是`index.html`

  `GET /index.html HTTP/1.1`
  
  服务器收到这个请求，就把index.html发送给浏览器。浏览器发现里面包含了样式表和图片，于是再发出两个请求

2. `GET /style.css HTTP/1.1`

3. `GET /example.png HTTP/1.1`

这就是传统的网页请求方式,每个网络资源都要发起一个请求

### HTTP2 Push

服务器推送（server push）指的是，还没有收到浏览器的请求，服务器就把各种资源推送给浏览器

比如，浏览器只请求了`index.html`，但是服务器把`index.html`、`style.css`、`example.png`全部发送给浏览器。
这样的话，只需要一轮 HTTP 通信，浏览器就得到了全部资源，提高了性能

Nginx 实现

```
server {
    listen 443 ssl http2;
    server_name  localhost;

    ssl                      on;
    ssl_certificate          /etc/nginx/certs/example.crt;
    ssl_certificate_key      /etc/nginx/certs/example.key;

    ssl_session_timeout  5m;

    ssl_ciphers HIGH:!aNULL:!MD5;
    ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;
    ssl_prefer_server_ciphers   on;

    location / {
      root   /usr/share/nginx/html;
      index  index.html index.htm;
      http2_push /style.css;
      http2_push /example.png;
    }
}
```

其实就是最后多了两行`http2_push`命令。它的意思是，如果用户请求`根路径/`，就推送`style.css`和`example.png`


[快速入门系列】一篇文章让你入门HTTP2.0](https://segmentfault.com/a/1190000016656529?utm_source=tag-newest)