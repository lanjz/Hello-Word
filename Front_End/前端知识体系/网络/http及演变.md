# HTTP

> [MDN-HTTP](https://developer.mozilla.org/zh-CN/docs/Web/HTTP)

什么是 HTTP ？ 

- **超文本传输协议**（HTTP）用于传输诸如HTML这样的的网络资源的protocol(通讯协议)。它通用用于浏览器与Web服务器之间通信。

- HTTP遵循经典的客户端-服务端模型。通常基于TCP/IP层，但可以在任何可靠的传输层上使用，比如UDP

- HTTP 属于应用层协议

# HTTP 的演变历史

## HTTP/0.9

HTTP/0.9 极其简单：请求由单行指令构成，以唯一可用方法GET开头，其后跟目标资源的路径（一旦连接到服务器，协议、服务器、端口号这些都不是必须的）。

## HTTP/1.0

- 协议版本信息现在会随着每个请求发送（HTTP/1.0被追加到了GET行）

- 状态码会在响应开始时发送，使浏览器能了解请求执行成功或失败，并相应调整行为（如更新或使用本地缓存）。

- 引入了HTTP头的概念，无论是对于请求还是响应，允许传输元数据，使协议变得非常灵活，更具扩展性。

- 可以使用 `cookie/session`

**HPPT/1.0** 缺点：

- 每次连接都需要建立一次 TCP 连接

- 队头阻塞（head of line blocking）：由于 HTTP1.0 规定下一个请求必须在前一个请求响应到达之前才能发送。假设前一个请求响应一直不到达，
那么下一个请求就不发送，同样的后面的请求也给阻塞了

## HTTP/1.1

- 连接可利用，节省TCP连接的连接， `keep-alive`

  HTTP1.1增加了一个 `Connection`字段，通过设置`Keep-Alive`可以保持 HTTP 连接不断开，避免了每次客户端与服务器请求都要重复建立释放建立TCP连接，
  提高了网络的利用率。如果客户端想关闭HTTP连接，可以在请求头中携带`Connection: false`来告知服务器关闭请求

- 支持响应分块。

- 引入额外的缓存控制机制。

- 引入内容协商机制，包括语言，编码，类型等，并允许客户端和服务器之间约定以最合适的内容进行交换。

- Host头，能够使不同域名配置在同一个IP地址的服务器上,使得一个服务器能够用来创建多个Web站点

- 是 HTTP1.1 支持请求管道化

  基于HTTP1.1的长连接，使得请求管线化成为可能。管线化使得请求能够“并行”传输。举个例子来说，假如响应的主体是一个html页面，
  页面中包含了很多img，这个时候`keep-alive`就起了很大的作用，能够进行“并行”发送多个请求。（注意这里的“并行”并不是真正意义上的并行传输，具体解释如下。）

  **需要注意的是，服务器必须按照客户端请求的先后顺序依次回送相应的结果，以保证客户端能够区分出每次请求的响应内容**

  假设客户端同时发了两个请求分别来获取 html 和 css ，html请求先到达服务器，即使说服务器的css资源先准备就绪，服务器也会先发送html再发送css

  换句话来说，只有等到html响应的资源完全传输完毕后，css响应的资源才能开始传输。也就是说，不允许同时存在两个并行的响应

  可见，HTTP1.1还是无法解决队头阻塞（head of line blocking）的问题。同时“管道化”技术存在各种各样的问题，所以很多浏览器要么根本不支持它，
  要么就直接默认关闭，并且开启的条件很苛刻...而且实际上好像并没有什么用处。

  那么平时我们所说有浏览器可以并行发送请求是怎么回事呢？

  **实际上，现阶段的浏览器厂商采取了另外一种做法，它允许我们打开多个TCP的会话**， 这才是为什么可以并行发送请求的原因

## HTTP/2

- 由二进制分帧代替文本协议
  
  HTTP2.0 通过在应用层和传输层之间增加一个二进制分帧层，突破了HTTP1.1的性能限制、改进传输性能
    
  虽然 `HTTP2.0` 的协议和 `HTTP1.x` 协议之间的规范完全不同了，但是实际上 HTTP2.0 并没有改变 HTTP1.x 的语义。
  简单来说，HTTP2.0 只是把原来 HTTP1.x的 `header` 和 `body` 部分用 `frame` 重新封装了一层而已

- 多路复用
  
  下面是几个概念:
    
  - 流（stream）：已建立连接上的双向字节流
    
  - 消息：与逻辑消息对应的完整的一系列数据帧
    
  - 帧（frame）：HTTP2.0通信的最小单位，每个帧包含帧头部，至少也会标识出当前帧所属的流（`stream id`）。
    
  ![](https://segmentfault.com/img/remote/1460000013028805?w=479&h=391)
    
  从图中可见，所有的HTTP2.0通信都在一个TCP连接上完成，这个连接可以承载任意数量的双向数据流
  
  每个数据流以消息的形式发送，而消息由一或多个帧组成。这些帧可以乱序发送，然后再根据每个帧头部的流标识符（stream id）重新组装。
  
  举个例子，每个请求是一个数据流，数据流以消息的方式发送，而消息又分为多个帧，帧头部记录着stream id用来标识所属的数据流，
  不同属的帧可以在连接中随机混杂在一起。接收方可以根据stream id将帧再归属到各自不同的请求当中去。
  
  另外，多路复用（连接共享）可能会导致关键请求被阻塞。HTTP2.0里每个数据流都可以设置优先级和依赖，优先级高的数据流会被服务器优先处理和返回给客户端，数据流还可以依赖其他的子数据流。
  
  可见，HTTP2.0实现了真正的并行传输，它能够在一个TCP上进行任意数量HTTP请求。而这个强大的功能则是基于“二进制分帧”的特性。
    
- 压缩Headers

  HTTP2.0使用`encoder`来减少需要传输的`header`大小，通讯双方各自`cache`一份`header fields`表，既避免了重复`header`的传输，
  又减小了需要传输的大小。高效的压缩算法可以很大的压缩``header，减少发送包的数量从而降低延迟

- 服务器推送

  服务器除了对最初请求的响应外，服务器还可以额外的向客户端推送资源，而无需客户端明确的请求

## 后HTTP/2

- 对`Alt-Svc`的支持允许了给定资源的位置和资源鉴定，允许了更智能的CDN缓冲机制。

- `Client-Hints` 的引入允许浏览器或者客户端来主动交流它的需求，或者是硬件约束的信息给服务端。

- 在Cookie头中引入安全相关的的前缀，现在帮助保证一个安全的cookie没被更改过

## HTTP1.1的合并请求是否适用于HTTP2.0

首先，答案是“没有必要”。之所以没有必要，是因为这跟HTTP2.0的头部压缩有很大的关系

在头部压缩技术中，客户端和服务器均会维护两份相同的静态字典和动态字典

在静态字典中，包含了常见的头部名称以及头部名称与值的组合。静态字典在首次请求时就可以使用。那么现在头部的字段就可以被简写成静态字典中相应字段对应的index

可以动态地添加内容。动态字典可以在连接中不听的进行更新

也就是说，原本完整的HTTP报文头部的键值对或字段，由于字典的存在，现在可以转换成索引index，在相应的端再进行查找还原，也就起到了压缩的作用

所以，同一个连接上产生的请求和响应越多，动态字典累积得越全，头部压缩的效果也就越好，所以针对HTTP/2网站，最佳实践是不要合并资源。

另外，HTTP2.0多路复用使得请求可以并行传输，而HTTP1.1合并请求的一个原因也是为了防止过多的HTTP请求带来的阻塞问题。而现在HTTP2.0已经能够并行传输了，所以合并请求也就没有必要了


## HTTP的性质 

- HTTP协议是构建于TCP/IP协议之上，是一个应用层协议，默认端口是80

- HTTP是简单

  下一代HTTP/2协议将HTTP消息封装到了帧(iframe)中，但大体上还是设计简单易懂（废话）

- HTTP是可扩展的

  通过HTTP中的Headers属性，我们可以方便进行一些扩展

- HTTP是无状态的，有会话的

  在同一个连接中，两个执行成功的请求之间没有任何关系。这就带来一个问题，用户没有办法在同一网站中进行连续的交互，如果在电商网站中，用户把某个商品加入购物车，切换一个而后再添加了商品，这两次添加的商品的请求之间没有关联，浏览器无法知道用户最终选择了哪些商品。而使用HTTP的头部扩展，HTTP Cookies就可以解决这些问题。把Cookies添加到头部，创建一个会话让每个请求都能共享相同的上下文信息，达成相同的状态

  **HTTP是无状态的，但使用Cookies可以创建有状态的会话**


# HTTP报文

## 请求报文

![](https://mdn.mozillademos.org/files/13687/HTTP_Request.png)

一个请求由下以下元素组成：

- Method：请求方法，例如`GET`、`POST`等

- Path：获取资源的路径

- HTTP协议版本号

- 为服务端表达其他信息的可选头部headers

- 对于一些像POST这样的方法，报文的body就包含了发送的资源，这与响应报文的body类似

## 响应报文

![](https://mdn.mozillademos.org/files/13691/HTTP_Response.png)

响应报头包含以下元素：

- HTTP协议版本号

- 一个状态码，来告知对应请求执行成功或失败，以及失败的原因

- HTTP headers，与语法头部类似

- 可选项，比起请求报文，响应报文中多得包含获取资源的body

## HTTP能控制什么

- 缓存：

  文档如何缓存能通过HTTP来控制。服务端能告诉代理和客户端哪些文档需要被缓存，缓存多久，而客户端也能够命令中间的缓存代理来忽略存储的文档。

- 开放同源限制

  为了防止网络窥听和其它隐私泄漏，浏览器强制对Web网站做了分割限制。只有来自于相同来源的网页才能够获取网站的全部信息。这样的限制有时反而成了负担，HTTP可以通过修改头部来开放这样的限制，因此Web文档可以是由不同域下的信息拼接成的（某些情况下，这样做还有安全因素考虑）。

- 认证

  一些页面能够被保护起来，仅让特定的用户进行访问。基本的认证功能可以直接通过HTTP提供，使用Authenticate相似的头部即可，或用HTTP Cookies来设置指定的会话。

- 代理和隧道

  通常情况下，服务器和/或客户端是处于内网的，对外网隐藏真实 IP 地址。因此 HTTP 请求就要通过代理越过这个网络屏障。但并非所有的代理都是 HTTP 代理。例如，SOCKS协议的代理就运作在更底层，一些像 FTP 这样的协议也能够被它们处理。

- 会话

  使用HTTP Cookies允许你用一个服务端的状态发起请求，这就创建了会话。虽然基本的HTTP是无状态协议。这很有用，不仅是因为这能应用到像购物车这样的电商业务上，更是因为这使得任何网站都能轻松为用户定制展示内容了。




## HTTP瓶颈

- 一个连接只能发送一个请求

- 请求只能客户端发起，客户端不可以接收除了响应以外的指令

- 请求/响应未练压缩就发送，首部信息越多延迟越大

- 发送冗余的首部。每次互相发送相同的首部造成的浪费较多

- 可任意选择数据压缩方式。非强制压缩发送

[四个全新维度，优化你的 HTTP 性能到极致](https://yq.aliyun.com/articles/742698?spm=a2c4e.11155472.0.0.21af23e9yuziFN)