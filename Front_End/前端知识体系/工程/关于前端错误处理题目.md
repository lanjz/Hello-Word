# 关于前端错误处理

> [一道不一样的前端架构师最终面试题](https://mp.weixin.qq.com/s/BX0kb9HgPABi9LD9Q27Bbw)

先看一段代码：

```javascript
<body>
<h1>前端错误处理</h1>
</body>
<script>
    xxxx
    window.onerror = function () {
        console.error('生成了错误')
	}
</script>
</html>

//Uncaught ReferenceError: xxxx is not defined
```

因为在捕获错误之前就报错了,所以没有捕获到错误


第二段代码：

```javascript
 window.onerror = function () {
        console.log('生成了错误')
	}
	try{
    	console.log('try')
    } catch (e) {
    	console.log('e', e)
    } finally {
    	throw new Error('抛出错误')
        console.log('finally')
    }
    
// try
// 生成了错误
// 抛出错误
```

- 先执行`try`里的代码`console.log('try')`，

- 然后执行`finally`抛出错误先被`window.onerror`捕获执行`console.log('生成了错误')`,

- 最后输出`Uncaught Error: 抛出错误`

抛出错误后，后面的代码将不会执行

第三段代码：

```javascript
window.onerror = function () {
    console.log('生成了错误')
}
 try{
      console.log('try')
      throw new Error('try里抛出错误')
  } catch (e) {
      console.log('e', e)
  } finally {
      throw new Error('抛出错误')
      console.log('finally')
  }
  console.log(1)
  // try
  // e Error: try里抛出错误
  // 生成了错误
  // 错误处理问题.html?_ijt=evigh55v5vvrmi1gq000pg8ilj:20 Uncaught Error: 抛出错误
```

- 首先执行`try`里的代码`console.log('try')`

- `try`抛出错误后被`catch`捕获，执行`console.log('e', e)`

- 最后执行`finally`中的代码抛出错误，这个错误先被`window.onerror`捕获执行` console.log('生成了错误')`

- 最后打印`抛出错误`

第四段代码：

```javascript
window.onerror = function () {
    console.log('生成了错误')
}
  try{
      console.log('try')
      throw new Error('try里抛出错误')
  } catch (e) {
	  throw new Error('catch里抛出错误')
      console.log('e', e)
  } finally {
  	  console.log('进入finally')
      throw new Error('抛出错误')
      console.log('finally')
  }
  console.log(1)
  // try
  // 进入finally
  // 生成了错误
  // Uncaught Error: 抛出错误
```

- 首先执行`try`里的代码`console.log('try')`,抛出错误`throw new Error('try里抛出错误')`

- `try`抛出的错误后被`catch`捕获，然后又抛出错误`throw new Error('catch里抛出错误')`

- 然后直接执行`finally`,输出`console.log('进入finally')`,抛出错误`throw new Error('抛出错误')`

- `finally`抛出的错误被`window.onerror`捕获执行`console.log('生成了错误')`，然后打印`//Uncaught Error: 抛出错误`

从上面再做代码可以得出几个信息：

- 无论是`try`和`catch`正常执行还是抛出错误,`finally`总会被执行

- 在try抛出的错误会被`catch`捕获，`window.onerror`捕获不到

这里有点困惑`catch`抛出的错误呢，我们再来一个例子：

```javascript
	window.onerror = function () {
		console.log('生成了错误')
	}
	try{
		console.log('try')
		throw new Error('try里抛出错误')
	} catch (e) {
		throw new Error('catch里抛出错误')
		console.log('e', e)
	} finally {
		console.log('进入finally')
		console.log('finally')
	}
	console.log(1)
	// try
	// 进入finally
	// finally
	// 生成了错误
	// Error: catch里抛出错误
```

此时catch中的错误将被抛出，这是咋回事呢，是时候回顾一下`try..catch()`的用法了

## try...catch()

`catch`子句包含`try`块中抛出异常时要执行的语句。也就是，你想让`try`语句中的内容成功， 如果没成功，你想控制接下来发生的事情，
- 这时你可以在`catch`语句中实现。 如果在`try`块中有任何一个语句（或者从`try`块中调用的函数）抛出异常，
控制立即转向`catch`子句。如果在`try`块中没有异常抛出，会跳过`catch`子句。

- `finally`子句在`try`块和`catch`块之后执行但是在下一个`try`声明之前执行。无论是否有异常抛出或捕获它总是执行。

- 你可以嵌套一个或者更多的`try`语句。如果内部的`try`语句没有`catch`子句，那么将会进入包裹它的`try`语句的`catch`子句。

我是这么理解第四段代码`catch`中的代码为什么没被抛出的：因为`try`和`catch`无论有没有成功，都会执行`finally`，执行`finally`后抛出的错误把
`catch`中的错误覆盖了，所以导致`catch`中的错误没被抛出

## 加入webpack的变异版本

如果其他通过webpack构建的文件发生了致命错误，例如因为做了tree sharking，没有兼容低版本浏览器，此时可以捕获到全局错误吗

答案是不可以捕获到，因为经过webpack打包后，如果自定义捕捉错误事件在打包的文件载入之后，
如果此时其他模块发生了致命错误，例如const这种代码跑在IE6中，那么就会直接致命错误，
阻断浏览器解析代码，页面挂掉。js引擎也不会去解析下面的代码～ 还没有运行到window.onerror这里就挂了,其它这跟第一段代码类似

##　window.onerror与window.addEventListener('error')捕获js运行时错误

使用`window.onerror`和`window.addEventListener('error')`都能捕获，但是`window.onerror`含有详细的`error`堆栈信息，
存在`error.stack`中，所以我们选择使用`onerror`的方式对`js`运行时错误进行捕获。
