# 常见登录验证分析

## 登录框

-  登录框账号密码服务端持久化：当你打开登录页面发现账号密码已经填好了，点击登录直接进后台
   
   修复方案：保存账号密码处理的逻辑针对本地，session及时销毁
   
-  登录框账号密码前端持久化：当你打开登录页面发现账号密码已经填好了，点击登录直接进后台
   
   修复方案一：
   
   浏览器遇到`type="text"`与`type="password"`的 `input` 标签紧邻时触发自动填充行为，则将两个`input`隔开，使用隐藏的方式“欺骗”浏览器，将密码信息填写在隐藏区域
   
   ```
   // 在原来登录密码框之间添加两个input, 注意不是直接display: none，如果直接display: none，有些浏览器则不生效，
   <input  type="text"  class="is-hidden" />
   <input  type="password"  class="is-hidden" />
   ```
   
   修复方案二：通过`readonly`属性
   
   ```
   <input type="password" readonly onfocus="this.removeAttribute('readonly');"/>
   ```
   
   修复方案三： 使用HTML5新属性`autocomplete="off"` 但禁用自动填充。这个属性好像是 firefox 发起的，并不是标准属性，
   所以这块主要是针对ie和获取浏览器生效。谷歌不承认这个属性。所以在谷歌浏览器上并没有产生任何效果
   
-  信息泄露：登录框账号密码前端持久化：当你填写好账号密码，点击登录浏览会自己弹出自己密码功能

  网上有一开将密码的 `type`设为`text`, 在`onfocus`的时候再动态改为`password`，但是实测都不用

  但是本质是因为存在 `type=passwor`的输入框才会出现这个提示，所以往这方面想～
  
- 登录框提供个示例用户名，比如示例邮箱、手机、用户名规则导致黑客掌握规律生成字典

  不显示示例用户名
  
- sql注入：用户名字段或者密码字段存在`sql注入`，比较典型的是万能密码登录

  **万能密码登录**
  
  当用户登录时，后台执行的数据库查询操作SQL语句：
  
  `Select user_id,user_type,email From users Where user_id='用户名' And password='密码'`
  
  如果后台没有对用户输入密码，帐号做过滤，则可能会有 `SQL注入`， 如果密码输入为`2'or'1, 则后台的 SQL 为：
  
  `Select user_id,user_type,email From users Where user_id='admin' And password='2'or'1'`
  
  这是由于 SQL 语句中逻辑运算符具有优先级，`=`优先于`and`，`and` 优先于`or`，且适用传递性。
  因此，此SQL语句在后台解析时，分成两句 `Select user_id,user_type,email From users Where user_id='admin' And password='2'`和`'1'`，
  两句`bool`值进行逻辑or运算，恒为`TRUE`。SQL语句的查询结果为`TRUE`，就意味着认证成功，也可以登录到系统中。
  
  使用参数绑定方式查询和预编译语句，如果使用各种框架按照框架安全开发的要求编程
  
- 账号密码暴力破解：黑客通过工具或者脚本加载账号密码字典不断尝试登录

  添加验证码（添加验证码不对可能导致绕过等，不一定能防止，下文详说）
  
- 用户枚举：输入不对的用户名提示密码不存在，输入对的用户名提示密码错误，从而枚举用户名
  
  使用模糊的错误提示，如用户名或密码不正确
  
- 账号锁定：用户爆破的时候错误次数过多锁定账号，然后黑客批量尝试用户名导致大部分用户名被锁

  修复方案：使用验证码方式防爆破，尽量不要使用登录次数太多锁定的方式，或者设置短时锁定
  
- 低频撞库爆破：利用脚本以慢频率持久爆破，针对限制频率数字比较大的防御策略
 
  使用验证码机制
   
## 图片验证码

- 易识别：验证码杂点太少或者没有杂点导致可以用程序识别出验证码的内容

  验证码前端生成：验证码是用js做的，用js生成点随机字符填充到前端dom
  
## 手机和邮箱验证码

## 一个安全的认证机制的设计

**登录功能：**

- 把用户名密码和其他需要的字段（如验证码，验证码只有一次，并足够杂点和复杂度）放前端让客户一起填写，然后放到同一个http请求提交给后端，

- 后端判断是否有验证码参数，然后判断验证码是否正确，再然后正则判断部分字段，不能正则的对参数进行过滤转码

- 然后使用参数绑定和预编译查询数据库

- 出错或者不存在的提示前端用户名或者密码错误，这样就防止了自动化攻击和SQL注入信息泄露等等

**密码重置功能**

- 把验证码、用户名、认证因子（邮箱、手机等）放到同一个http请求中，优先验证验证码的存在性、正确性、一次性

- 其次对参数进行正则格式验证、之后对不能验证参数进行过滤编码、验证用户名和认证因子的匹配性、最后再触发相关功能
 

> [](https://www.freebuf.com/articles/web/217052.html)
>
