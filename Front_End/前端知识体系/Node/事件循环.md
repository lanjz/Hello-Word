# 事件循环

事件循环就是一个程序启动期间运行的死循环

事件循环对于开发者来说是不可见的。当用户单击页面上的按钮或者进行其他操作时，就会产生相应的事件，这些事件地被加入到一个队列中，然后主循环会逐个处理它们

而JavaScript是单线程的，为了避免一个过于耗时的操作阻塞了其他操作的执行，就要通过异步加回调的的方式解决问题

以Ajax请求为例，当JavaScript执行到对应的代码时，就为这句代码注册了一个事件，在发出请求后该语句就执行完毕了，后续的操作会交给回调函数来处理

此时，浏览器背后的循环正在不断遍历事件队列，在Ajax操作完成之前，事件队列里还是空的（并不是发出请求这一动作被加入事件队列，而是请求完成这一事件才会加入队列）

如果Ajax操作完成了，这个队列中就会增加一个事件，随后被循环遍历到，如果这个事件绑定了一个回调方法，那么循环就会去调用这个方法

## Node中的事件循环

Node中的事件循环比起浏览器中的JavaScript还是有一些区别的

- JS的事件循环是依靠浏览器实现的

- 而Node作为另一种运行时，事件循环由底层的 libuv实现

Node中事件循环的具体流程：

```
   ┌───────────────────────────┐
┌─>│           timers          │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │<─────┤  connections, │
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │
   └───────────────────────────┘
```

上面的图例中，将事件特环分为了6个不同的阶段

- Timers: 用来处理`setTimeout()`和`setInterval()`的回调

- I/O callbacks: 大多数的回调方法在这个阶段执行，除了`timers`,`close`和`setImmediate`

- idel, prepare:仅仅在内部使用，不管它

- Poll: 轮询，不断检查有没有新的I/P事件，事件循环可能会在这里阻塞

- Check：处理`setImmediate()`事件的回调

- Close callbacks:处理一些 close相关的事件，例如`cocket.on('close')`

### Timer Phase

任何过期的计时器回调都会在事件循环的这个阶段中运行

定时器的回调会在触发后尽可能早地被调用，这表示实际的延时可能会比定时器规定的时间要长

如果事件循环，此时正在执行一个比较耗时的`callback`，例如处理一个比较耗时的循环，那么定时器的回调只能等待当前回调执行结束了才能被执行，即被阻塞。事实上，timer阶段的执行受到poll阶段控制

例如，假设您调度了一个在 100 毫秒后超时的定时器，然后您的脚本开始异步读取会耗费 95 毫秒的文件:

```
const fs = require('fs');

function someAsyncOperation(callback) {
  // Assume this takes 95ms to complete
  fs.readFile('/path/to/file', callback);
}

const timeoutScheduled = Date.now();

setTimeout(() => {
  const delay = Date.now() - timeoutScheduled;

  console.log(`${delay}ms have passed since I was scheduled`);
}, 100);

// do someAsyncOperation which takes 95 ms to complete
someAsyncOperation(() => {
  const startCallback = Date.now();

  // do something that will take 10ms...
  while (Date.now() - startCallback < 10) {
    // do nothing
  }
});

```

执行过程：

- 当事件循环进入 轮询 阶段时，它有一个空队列（此时 `fs.readFile()` 尚未完成），因此它将等待剩下的毫秒数，直到达到最快的一个计时器阈值为止。

- 当它等待 `95 毫秒`过后时，`fs.readFile()` 完成读取文件，它的那个需要 `10 毫秒`才能完成的回调，将被添加到 轮询 队列中并执行

- 当回调完成时，队列中不再有回调，因此事件循环机制将查看最快到达阈值的计时器，然后将回到 计时器 阶段，以执行定时器的回调

在本示例中，您将看到调度计时器到它的回调被执行之间的总延迟将为 `105 毫秒`

### IO callbacks阶段

官方文档对这个阶段的描述为除了`timesr`, `setImmediate`，以及`close`操作之外的大多数的回调方法都位于这个阶段执行，事实上从源码来看，该阶段只是用来执行`pending callback`， 例如一个 `TCP socket` 执行出现了错误，在某些 `* nix` 系统希望稍后再处理这些错误。 这将会在 pending callbacks 阶段排队执行

一些常见的回调，例如`fs.readFile`的回调是放在 `poll`阶段来执行的

### poll阶段

poll 阶段的主要任务是等待新的事件出现（该阶段使用epoll来获取新的事件上），如果有，事件循环可能会在些阻塞

**这些事件对应的回调方法可能位于 timers 阶段（如定义了定时器），也可能是 check 阶段（设置了 `setImmediate`方法）**

轮询阶段具有两个主要功能：

- 计算应该阻塞并 I/O 轮询的时间

- 处理轮询队列 (poll queue) 中的事件

当事件循环进入轮询 (poll) 阶段并且没有任何计时器调度 (timers scheduled) 时，将发生以下两种情况之一：

- 如果轮询队列 (poll queue) 不为空，则事件循环将遍历其回调队列，使其同步执行，直到队列用尽或达到与系统相关的硬限制为止 

- 如果轮询队列为空，则会发生以下两种情况之一：

  - 如果已通过 `setImmediate` 调度了脚本，则事件循环将结束轮询 poll 阶段，并继续执行 check 阶段以执行那些调度的脚本。

  - 如果脚本并没有 setImmediate 设置回调，则事件循环将等待 poll 队列中的回调，然后立即执行它们。

一旦轮询队列 (poll queue) 为空，事件循环将检查哪些计时器 timer 已经到时间。 如果一个或多个计时器 timer 准备就绪，则事件循环将返回到计时器阶段，以执行这些计时器的回调

### check 阶段

> 此阶段允许在轮询 poll 阶段完成后立即执行回调。 如果轮询 poll 阶段处于空闲，并且脚本已使用 setImmediate 进入 check 队列，则事件循环可能会进入 check 阶段，而不是在 poll 阶段等待

`setImmediate` 实际上是一个特殊的计时器，它在事件循环的单独阶段运行。 它使用 libuv API，该 API 计划在轮询阶段完成后执行回调

通常，在执行代码时，事件循环最终将到达轮询 poll 阶段，在该阶段它将等待传入的连接，请求等。但是，如果已使用 setImmediate 设置回调并且轮询阶段变为空闲，则它将将结束并进入 check 阶段，而不是等待轮询事件

### close 阶段

如果一个`socket`或者一个句柄突然被关闭，则在此阶段将发出 `close` 事件, 该事件会被加入到对应的队列中。close 阶段执行完毕后，本轮事件循环结束，循环进入到下一轮。

**Nodejs 为了防止某个 Phase 任务太多, 导致后续的 Phase 发生饥饿的现象, 所以消息循环的每一个迭代(iterate) 中, 每个 Phase 执行回调都有个最大数量. 如果超过数量的话也会强行结束当前 Phase 而进入下一个 Phase. 这一条规则适用于消息循环中的每一个 Phase**

# Q&A

- 如果你的计算机只有一单核的CPU（暂先不考虑超线程程技术，即在一个CPU上同时执行两个线程），还能做到并行吗？

  就算把代码写出花来，也不能获得真正的并行

- 是事件特环提供了并行的能力吗？

  事件特环也是运行在单线程环境中，这表示一个时刻只能处理一个事件，没法提供并行支持

- 如果存在并行，那么应该位于Node的哪个层面？

  并行存在于 libuv 的线程池中，实现的并行为线程级别的并行（需要多核CPU）