模块热更新技术可以在不刷整个网页的情况下做到起灵敏实时预览。原理在一个源码发生变化时，只需要重新编辑发生变化的的模块，再用新输出的模块替换掉浏览器中对应的模块。

模块热更新的优化如下：

- 实时预览反应更快，等待时间更短

- 不刷新浏览器时能保留当前网页的运行状态，例如如果网页使用Redux做数据状态管理，那么模块热更新能做到代码更新时Redux中的数据操持不变

## 模块热替换的原理

模块热替换的原理和自动刷新的原理类型，都需要向要开发的网页中注入一个代码客户端来连接DevServer，不同在于模块热替换的独特的模块替换机制。

DevSerer默认情况不会开启模块热替换，要开启刻模式，则只需要在启动时带上参数--hot，完整的命令是`webpack-dev-server --hot`

除了通过启动时带参数的方式，也还可以以Plugins的方式实现，相关代码发下

```
 const HotModuleReplacementPlugin = require('webpack/lib/HotModuleReplaceentPlugin')

  module.exports = {
    entry: {
      // 为每个入口注客户端代码
      main: ['webpack-dev-server/client?http://localhost:8080/', 'webpack/hot/dev-server','./src/main.js'],
    },
    plugins: [
      // 该插件的作用就是实现模块热替换，实际上若启动时带上`--hot`参数，就会注入该插件，生成`hot-update.json`文件
      new HotModuleReplacementPlugin()
    ],
    devServer: {
      // 告诉DevServer要开启模块热替换模式
      hot: true
    }
  }
```

在启动时，命令行带上`--hot，其实就是自动完成以上配置

为了让使用者在使用模块热替换功能时能灵活地控制老模块被替换时的逻辑，Webpack允许在源码上定义一些代码去做相应的处理

```
  import React from 'react'
  import { render } from 'react-dom'
  import { AppComponent } from 'react-dom'
  import './main.css'

  render(<AppComponent>, window.document.getElementById('app'))
  // 只有当开启了模块热替换时，module.hot才存在
  if(module.hot){
    // module.hot.accept函数的第一个参数指出当前文件接收哪些子模块的替换，这里表示只接受'./AppComponent'这个子模块
    // 第二个参数表示模块更新时要执行的逻辑
    module.hot.accept(['./AppComponent'], () => {
      render(<AppComponent>, window.document.getElementById('app'))
    })
  }

```

其中module.hot是当前开启模块热替换后全局注入的api，用于控制模块热替换的逻辑。

### 为什么编辑`main.js`时还是刷新整个页面

其原因当块更新，更新事件会一层一层向上传递，也就是当`./AppComponent`更新时，会传递到了`main.js`中，直到有某层接收了当前变化的模块，这里被`main.js`中定义的`accept`函数接收了 ，然后就会执行我们定义的`callback`函数，如果事件一直往上拋，到了最外层都有文件接收它，则会直接刷新页面。

那为什么我们没定义接收CSS的地方，可修改CSS文件时，并不是刷新页面，而是触发模块热更新呢？

原因在于style-loader会注入用于接收CSS的代码

## 优化模块热替换

在发生模块热替换时，我们会在浏览器的控制台中看到一些输出信息，其中有`Updated modules：[数字]`的信息输出，这个[数字]表示ID为几的模块被替换了，这对开发者不是很友好，因为开发都不知道ID和模块之间的对应关系，最好是模块名字代替这个ID输出。Webapck内置的NameModulesPlugin插件可以解决这个问题，修改Webpack配置文件接入该插件：

```
 const NameModeulesPlugin = require('webpack/lib/NameModulesPlugin')
  module.exports = {
    plugins: [
      // 显示出被替换模块的名称
      new NameModeulesPlugin()
    ]
  }
```

重新构建后，我们就能发现输出的日志发生了变化

除此之外，模块热替换还面临和自动刷新一样的性能问题，因为它们都需要监听文件的变化和注入客户端。优化模块热替换的构建性能的思路和之前优化自动更新的思路类似：监听更少的文件，忽略node_mosules目录下的文件。

但是其中提到的关闭默认的inline模式且手动注入代理客户端的优化方法，不能用于使用模块热替换的情况，原因在于模块热替换的运行依赖在每个Chunk中都包含代理客户端的代码。
