# 关于静态资源的输出路径

关于路径先分清楚在路径名前有没有带`/`的情况下他们的区别：

假设我们的HTML页面有引入一张 `bg.png` 的图片

- `/assets/bg.png`: 相对于服务(server-relative)

- `assets/bg.png`: 相对于 HTML 页面

- `./assets/`: 相对于 HTML 页面

[官方](https://www.webpackjs.com/configuration/output/#output-publicpath)对于`output.publicPath`的解释：

- 参数：`string`|`function`,在多数情况下此选项的值都会以/结束

对于按需加载(on-demand-load)或加载外部资源(external resources)（如JS文件、图片、文件等）来说，`output.publicPath` 是很重要的选项。
如果指定了一个错误的值，则在加载这些资源时会收到 `404` 错误。

从这里可以知道一个信息，这个配置影响的是按需加载和静态资源的引入路径

来一个没有配置`output.publicPath`的例子和打包结果

```
// webpack.config.js
entry: {
    index: './src/index.js',
},
output: {
    filename: '[name].js',
    chunkFilename: '[name].bundle.js',
    path: path.resolve(__dirname, 'dist'),
},

```
打包后引入的JS文件地址是：

```
<script type="text/javascript" src="index.js"></script>
```

HTML打开也是能正常加这个JS文件，接下我们加入`output.publicPath`

```
output: {
        filename: '[name].js',
        chunkFilename: '[name].bundle.js',
        path: path.resolve(__dirname, 'dist'),
		publicPath: '/out/',
    },
```

打包后会发现这个JS加载失败了，因为他们引入路径是`src="/out/index.js"`，可以看到路径前多了`output.publicPath`配置的路径

所以`output.publicPath`一般用于生产环境中，假如生产环境我们需要将静态资源放在其它目录或者放入 CDN时，就需要配置`output.publicPath`，
这样才能正确访问到真正的资源

打包静态资源的路径除了受`output.publicPath`影响，也会被 Loader 的配置影响，比如`file-loader`,`file-loader`的配置中有两个配置属性
`outputPath`和`publicPath`,

- `outputPath`: 指定输出文件放在哪个路径下，这个路径是会生成在输出目录中的

- `publicPath`: 跟`output.publicPath`类似，会在资源路径前加上`publicPath`，一般也是用于生产

```
// webpack.config.js
 {
    test: /\.(png|svg|jpg|gif)$/,
    use: [
        {
            loader: 'file-loader',
            options: {
                name: '[name].[ext]',
                outputPath: 'images/',
                publicPath: 'assets/'
            }
        }
    ]
},

// 给body添加样式

body{
    background: url("../imgs/bg.png");
}

```

打包后，图片的路径为`url(/assets/bg.png)`

并且 `file-loader`中的`publicPath`和`output.publicPath`同时存在时， `file-loader`中的`publicPath`会覆盖`output.publicPath`，
如果`file-loader`中的`publicPath`没设置，则使用`output.publicPath`

# loader执行顺序

正常情况下 loader 的执行顺序是倒序的

但可以通过enforce属性去改变执行顺序：

- `enforce:'pre'` 前置 权重最高

- `enforce:'normal'` 不变 权重第二

- `enforce:'inline'` 行内 权重第三

- `enforce:'post'` 后置 权重第四

# [Webpack中的静态资源文件指纹](https://juejin.im/entry/59cf5e3d6fb9a00a627161df?utm_medium=hao.caibaojian.com&utm_source=hao.caibaojian.com)

Webpack 提供了两种方式给输出的文件设置文件指纹

- `hash`:  就是每个构建过程生成的唯一`hash`

- `chunkhash`: 基于每个chunk的内容而生成的`hash`

```
entry: {
    index: './src/index.js',
    print: './src/print.js'
},
```

```
output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].[hash].js',
    publicPath: '/'
},
```

第一次build的结果：

![](https://user-gold-cdn.xitu.io/2017/9/30/f08ae4d18deacd8ba1130a464078915e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

第二次build的结果:


![](https://user-gold-cdn.xitu.io/2017/9/30/c7098ccbcbe10ea622707af18c291029?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

即使没有修改文件，也会输出不同的 hash 文件

所以我们加入`chunkFilename`

`output.filename`不会影响那些「按需加载 chunk」的输出文件。对于这些文件，需要使用 `output.chunkFilename`选项来控制输出

```
output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name][hash].js',
    chunkFilename: '[name][chunkhash].js',
    publicPath: '/'
}
```

![](https://github.com/zuopf769/webpack-learning/blob/master/Webpack%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E6%8C%87%E7%BA%B9/images/3.png)

每个文件的hash指纹都不相同，上线后无改动的文件不会失去缓存

## chunkhash的问题

webpack的理念是一切都是模块：把所有类型的文件都以js为汇聚点，不支持js文件以外的文件为编译入口。所以如果我们要编译style文件，唯一的办法是在js文件中引入style文件。如下

```
import './style.css';
```

webpack默认将js、image、css文件统统编译到一个js文件中，

这样的模式下有个很严重的问题，当我们希望将css单独编译输出并且打上hash指纹，按照前文所述的使用`chunkhash`配置输出文件名时，编译的结果是js和css文件的hash指纹完全相同

即使借助`extract-text-webpack-plugin`将 style 文件单独编译输出，webpack也仍将css文件视为js的一部分，
所以不论是单独修改了js代码还是css代码，编译输出的`js/css`文件都会打上全新的相同的hash指纹

好在`extract-text-webpack-plugin`提供了另外一种hash值：`contenthash`。顾名思义，`contenthash`代表的是文本文件内容的hash值，
也就是只有style文件的`hash`值。这个hash值就是解决上述问题的银弹。修改配置如下:

```
new ExtractTextPlugin('[name].[contenthash].css');
```

此时不修改样式只修改js部分的话，输出的`contenthash`是一样的，但是只修改了style文件，未修改index.js文件，编译输出的js文件的`hash`指纹还是会改变的

这是因为**webpack计算`chunkhash`时，以index.js文件为编译入口，整个chunk的内容会将style.css的内容也计算在内**

如果要解决这个问题可以使用插件`webpack-md5-hash`来解决

```
// webpack.config.js

var WebpackMd5Hash = require('webpack-md5-hash');

module.exports = {
    // ...
    output: {
        //...
        chunkFilename: "[chunkhash].[id].chunk.js"
    },
    plugins: [
        new WebpackMd5Hash()
    ]
};
```





