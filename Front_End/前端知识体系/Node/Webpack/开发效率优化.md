# 文件监听

文件监听是发现源码文件发生变化时，自动重新编译出新的输出文件

Webpack官方提供了两个大模块，一个核心的webpack，另一个是webpack-dev-server。而文件监听功能是Webpack提供的

文件监听的相关配置：

```
  module.exports = {
    // 开启监听模式，默认是false
    watch: true,
    // 前提是要watch为true，要不然没意义
    // 监听模式运行时的参数
    watchOptions: {
      // 不监听的文件或文件夹，支持正则匹配
      ignored: /node_modules/,
      // 监听到变化后等300ms再去执行，截流
      aggregateTimeout: 300,
      // 判断文件是否发生变化是通过不断询问系统指定文件有没有更新实现的
      // 默默每秒询问1000次
      poll: 1000
    }
  }
``` 

Webpack开启文件监听有两种方式

1. 配置文件中设置`watch: true`

2. 在执行启动Webpack的命令时带上`--watch`参数，完整的命令是`webapck --watch`

### 文件监听的原理

在Webpack中监听一个文件是否发生变化的原理，是定时获取这个文件最后更新时间，每次都存下最新的更新时间，
如果发现当前时间获取的和最后一次保存的编辑时间不一致，就认为该发生了变化 。配置项中的watchOptions.poll用于控制定时检查的周期，
具体含义是每秒检查多少次。

### 怎么确定要监听的文件列表呢？

在默认情况下，Webpack会从配置的Entry文件出发，递归解析Entry文件所依赖的文件，将这些文件加入到监听列表中。

由于保存文件的路径和最后的编辑时间需要占用内存，定时检查、周期检查需要占用CPU及文件I/O，所以最好减少需要监听的文件数量和降低检查频率。

## 优化文件监听的性能

根据前面对文件监听的原理介绍，我们可以做以下优化：

- 需要监听的文件列表是根据Entry配置的入口文件递归得将引用到的文件加入到监听列表中，其中将包含很多的`node_modules`中的模块，一般情况下我们不会修改`node_moduels`里的文件，所以我们可以忽略这个文件的监听，相关配置如下：

```
module.exports = {
  watchOptions: {
  // 不监听node_module中的文件
   ignored: /node_modules/，
  }
}
```

- 配置截流，`watchOptions.aggregateTimeout`的值越大越好，因为这能降低重新构建的频率

- `watchOptions.pool`的值越小越好，因为这能降低检查的频率

后面这种方式的优化，负作用是监听模式的反应和灵敏度降低了

# 自动刷新浏览器

监听到文件的变化后，下一步就是刷新浏览器，webpack模块负责监听文件，webapck-dev-server负责刷新浏览器。使用webpack-dev-server模块去启动webpack模块时，webpack模块的监听模式默认会被开启。当webpack模块监听到文件变化时，会通过webpack-dev-server模块

## 自动刷新的原理

控制浏览器刷新有如下三种方式

- 借助浏览器扩展去通过浏览器提供的接口刷新，Webstorm IDE的LiveEdit功能就是这样实现的

- 向要开发的网页中注入代理客户端代码，通过代理客户端去刷新整个页面

- 将要开发的网页装进一个iframe中，通过刷新iframe去看到最新效果

DevServer支持第2和第3种方法，第2种是DevServer默认采用的刷新方法。

通过DevServer启动构建

用浏览器调试工具，可以发现由代理客户端向DevServer发起的WebSocket连接。

### 优化自动刷新的性能

在使用devServer.inline配置项时，它用来控制 是否向Chunk中注入代理客户端，默认会注入。
事实上，在开启Inline时，DevServer会向每个输出的Chunk中都注入代理客户端的代码，当我们需要输出多个Chunk时，就会导致构建缓慢。
其实要完成自动刷新 ，一个页面只需要一个代理客户端，DevServer之所有这么粗暴得给每个输出的Chunk注入代理客户端代码，是因为它不知道页面依赖哪几个Chunk，
所以索性全部都注入一个代理客户端。网页只要依赖了其中任何一个Chunk，代理客户端就被注入网页中。

这里的优化思路是关闭不够优雅的Inline模式，只注入一个代理客户端。为了关闭inline模式，
在启动DevServer时可以通过执行命令`webpack-dev-server --inline false`(也可以在配置文件中设置)

关闭inline模式后和前面的不同在于：

- 入口网址变成了`http://localhost:8080/webpack-dev-server`

- bundle.js中不再包含代理客户端的代码。

- 查看页面的源代码我们发现，我们要开发的网页被放进了一个iframe中，编辑源码后，iframe会被自动刷新。

如果不想用iframe的方式去自动刷新网页，但同时想让网页保持自动刷新的功能，则需要手动在网页中注入代理客户端代码，向index.html中插入以下标签：

```
<!--注入DevServer提供的代理客户端脚本，这个服务是DevServer内置的-->
<script src="http://localhost:8080/webpack-dev-server.js"></script>
```

# 模块热替换

模块热更新技术可以在不刷整个网页的情况下做到起灵敏实时预览。原理在一个源码发生变化时，只需要重新编辑发生变化的的模块，再用新输出的模块替换掉浏览器中对应的模块。

模块热更新的优点如下：

- 实时预览反应更快，等待时间更短

- 不刷新浏览器时能保留当前网页的运行状态，例如如果网页使用Redux做数据状态管理，那么模块热更新能做到代码更新时Redux中的数据操持不变

```
  module.exports = {
    entry: {
      // 为每个入口注客户端代码
      main: ['webpack-dev-server/client?http://localhost:8080/', 'webpack/hot/dev-server','./src/main.js'],
    },
    devServer: {
      // 告诉DevServer要开启模块热替换模式
      hot: true， // 会自动引入 HotModuleReplacement
    }
  }
```

在启动时，命令行带上`--hot`，其实就是自动完成以上配置

为了让使用者在使用模块热替换功能时能灵活地控制老模块被替换时的逻辑，Webpack允许在源码上定义一些代码去做相应的处理

```
  import React from 'react'
  import { render } from 'react-dom'
  import { AppComponent } from 'react-dom'
  import './main.css'

  render(<AppComponent>, window.document.getElementById('app'))
  // 只有当开启了模块热替换时，module.hot才存在
  if(module.hot){
    // module.hot.accept函数的第一个参数指出当前文件接收哪些子模块的替换，这里表示只接受'./AppComponent'这个子模块
    // 第二个参数表示模块更新时要执行的逻辑
    module.hot.accept(['./AppComponent'], () => {
      render(<AppComponent>, window.document.getElementById('app'))
    })
  }

```

其中module.hot是当前开启模块热替换后全局注入的api，用于控制模块热替换的逻辑。

### 为什么编辑`main.js`时还是刷新整个页面

其原因当块更新，更新事件会一层一层向上传递，也就是当`./AppComponent`更新时，会传递到了`main.js`中，直到有某层接收了当前变化的模块，这里被`main.js`中定义的`accept`函数接收了 ，然后就会执行我们定义的`callback`函数，如果事件一直往上拋，到了最外层都有文件接收它，则会直接刷新页面。

那为什么我们没定义接收CSS的地方，可修改CSS文件时，并不是刷新页面，而是触发模块热更新呢？

原因在于style-loader会注入用于接收CSS的代码

## 优化模块热替换

在发生模块热替换时，我们会在浏览器的控制台中看到一些输出信息，其中有`Updated modules：[数字]`的信息输出，这个[数字]表示ID为几的模块被替换了，这对开发者不是很友好，因为开发都不知道ID和模块之间的对应关系，最好是模块名字代替这个ID输出。Webpack内置的NameModulesPlugin插件可以解决这个问题，修改Webpack配置文件接入该插件：

```
 const NameModeulesPlugin = require('webpack/lib/NameModulesPlugin')
  module.exports = {
    plugins: [
      // 显示出被替换模块的名称
      new NameModeulesPlugin()
    ]
  }
```

重新构建后，我们就能发现输出的日志发生了变化

除此之外，模块热替换还面临和自动刷新一样的性能问题，因为它们都需要监听文件的变化和注入客户端。优化模块热替换的构建性能的思路和之前优化自动更新的思路类似：监听更少的文件，忽略`node_mosules`目录下的文件。

但是其中提到的关闭默认的inline模式且手动注入代理客户端的优化方法，不能用于使用模块热替换的情况，原因在于模块热替换的运行依赖在每个Chunk中都包含代理客户端的代码。