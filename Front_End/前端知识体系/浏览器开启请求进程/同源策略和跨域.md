# 一个源的定义

如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源。
举个例子：

```
  下表给出了相对http://a.lanjz.com/dir/page.html同源检测的示例: 
  URL                                         结果          原因
  http://a.lanjz.com/dir2/other.html            成功     协议，端口（如果有指定）和域名都相同
  http://a.lanjz.com/dir/inner/another.html     成功    协议，端口（如果有指定）和域名都相同 
  https://a.lanjz.com/secure.html               失败    不同协议 ( https和http )
  http://a.lanjz.com:81/dir/etc.html            失败    不同端口 ( 81和80)
  http://a.opq.com/dir/other.html             失败    不同域名 ( lanjz和opq)
```

# 同源策略

同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源

# 跨域请求

## 基于jsonp实现的跨域请求

1. 页面中的链接，重定向以及表单提交是不会受到同源策略限制的。

2. 跨域资源的引入是可以的。但是js不能读写加载的内容。如嵌入到页面中的
`script`，`img`，`link`，`iframe`等。

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>同源策略</title>
</head>
<body>

<button id="btn">提交</button>

<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js">    </script>
<script>
    //自定义的函数
    function xxx(res) {
        console.log(res)
    }
    //jquery给button绑定点击事件
    $('#btn').click(function () {
        //创建一个script标签
        var scriptEle = document.createElement('script');
        //给标签添加src属性，并添加对应的属性值    http://127.0.0.1:8000/index1？callback=xxx
        $(scriptEle).attr('src','http://127.0.0.1:8000/index1?callback=xxx');
        //将创建好的标签添加到页面中，标签添加后就会自动触发get请求
        $('body').append(scriptEle);
        //将标签移除
        $(scriptEle).remove()
    })
</script>
</body>
</html>
```

## 后端设置允许跨域

服务器设置`Access-Control-Allow-Origin：允许跨域的域名添加到`

该字段是必须的。它的值要么是请求时`Origin`字段的值，要么是一个`*`，表示接受任意域名的请求。

服务器还有其它配置

- 服务器设置`Access-Control-Allow-Credentials`

  正常跨域请求是不允许携带cookie的，如果需要带cookie还需要进行以下配置
  
  该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下值为`false`，Cookie不包括在CORS请求之中
  设为`true`后，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。
  
  服务器设置之后，前端请求还需要配置`withCredentials`属性

- 服务器设置`Access-Control-Allow-Credentials`

  CORS请求时，`XMLHttpRequest`对象的`getResponseHeader()`方法只能拿到6个基本字段：`Cache-Control`、`Content-Language`、
  `Content-Type`、`Expires`、`Last-Modified`、`Pragma`。如果想拿到其他字段，就必须在`Access-Control-Expose-Headers`里面指定。
  上面的例子指定，`getResponseHeader('FooBar')`可以返回`FooBar`字段的值
  
## 修改document.domain

这个解决方案只适用于主域，协议，端口相同，子域不同的跨域应用场景。其他情况不能使用

比如在：aaa.com的一个网页(a.html)里面 利用iframe引入了一个bbb.com里的一个网页(b.html)。
这时在a.html里面可以看到b.html里的内容，但是却不能利用javascript来操作它。因为这两个页面属于不同的域

所以如果在a.html里引入aaa.com里的另一个网页，是不会有这个问题的，因为域相等。
有另一种情况，两个子域名：
aaa.xxx.com
bbb.xxx.com
aaa里的一个网页(a.html)引入了bbb 里的一个网页(b.html)，
这时a.html里同样是不能操作b.html里面的内容的。
因为document.domain不一样，一个是aaa.xxx.com，另一个是bbb.xxx.com。
这时我们就可以通过Javascript，将两个页面的domain改成一样的，需要在a.html里与b.html里都加入：

```
代码如下:
document.domain = "xxx.com";
```

这样这两个页面就可以互相操作了。也就是实现了同一基础域名之间的"跨域"。

[MDN-HTTP访问控制](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS) 

# HTTP响应首部字段

- Accept-Control-Allow-Origin： 用于设置允许访问该资源的外部URL

- Accept-Control-Expose-Headers：对跨域访问在跨域访问时，XMLHttpRequest对象的getResponseHeader()方法只能拿到一些最基本的响应头，`Cache-Contro`l、`Content-Language`、`Content-Type`、`Expires`、`Last-Modified、Pragma`，如果要访问其他头，则需要服务器设置本响应头。

Access-Control-Expose-Headers 头让服务器把允许浏览器访问的头放入白名单，例如：

```
Access-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header
```
- Access-Control-Max-Age：指定了preflight请求的结果能够被缓存多久

- Access-Control-Allow-Credentials：指定了当浏览器的credentials设置为true时是否允许浏览器读取response的内容。

- Access-Control-Allow-Methods：首部字段用于预检请求的响应。其指明了实际请求所允许使用的 HTTP 方法。

# HTTP请求头部字段

- origin：发起请求的源站URL，不包含路径
   
  注意：无论是否跨域请求，`origin`都会被发送

- Accept-Control-Request-Method：用于预检请求，将实际所请求的方法告诉服务器

  在项目中如果是跨域请求时，我们发现同一个请求有两次发送，第一次是`options`，第二次才是真正的请求。第一次请求就是预检请求，请求头中会带上`Accept-Control-Request-Method`，值是我们真正要请求的方法

- Accept-Control-Request-Headers：用于预检请求时，将实际请求中的首部字段发送给服务器



