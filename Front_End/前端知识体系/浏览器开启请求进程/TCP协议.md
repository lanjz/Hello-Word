> [TCP特性](https://hit-alibaba.github.io/interview/basic/network/TCP.html)

# TCP特性

- TCP是对面连接、可靠的字节流服务

- 在一次TCP连接中，仅有两方进行通信。广播和多播不能用TCP

- TCP使用校验和，确认和重传机制来保证可靠传输

- TCP给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复

- TCP使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制

需要注意的是：TPC并不能保证数据一定能百分百传输成功，TCP能做的只是，如果有可能就把数据传递给对方，否则就（通过放弃重传且中断连接的方式）通过用户。因此准备的说TCP不是百分百可靠的协议，它所能提供是数据的可靠传送或故障的通知

# 三次握手与四次挥手

TCT报文中有6种标志位：

- SYN：建立连接

- ACK：确认

- PSH：发送

- FIN：结束

- RST：重置

- URG：紧急

- Sequence number：顺序号码

- Acknowledge number：确认号码

## 三次握手

所谓三次握手，在指在TCP建立连接时，一共需要客户端和服务端发送三个包

三次握手的目的是连接服务器的指定端口，建立TCP连接，并同步双方的序列号和确认号交换TCP窗口大小信息在Socket编程中，客户端执行`connect()`时。将触发三次握手。

- 第一次握手，SYN(同步序列编号)=1，seq(序号)=x

客户端发送一个SYN标志位置1的包，同时随机生成一个初始化序号X保存到这个包的序列号（Sequence Number）字段里。即此时，发送的这个包SYN标志们为1，Seq标志位为X

SYN标志为1，是告诉服务器，这个客户端想要建立连机

发送完毕后，客户端进入`SYN_SEND`状态。

- 第二次握手（SYN=1,ACK=1,seq=y,ACKnum=x+1）

服务器收到这个包后，要确认联机信息，所以需要发回一个确认包应答。这个确认包包含以下内容：

  1. ACKnumber标志位是客户端发送的ISN加1，即为X+1。

  2. 同时SYN标志位和ACK标志均为1

  3. 服务端也要随机生成一个ISN（初始化序列号）序列号，放到Seq标志位

发送完毕后，服务器端进入`SYN_RCVD`状态

- 第三次握手（ACK=1，ACKnum=y+1）

客户端收到后检查ack number是否正常，即第一次发送的seq（x）+1，以及ack标志是否为1，若正确再次发送确认包，这个包的ack number为服务器的seq+1，即为y+1，SYN标志位为0，ACK标志为1

然后主机收到后确认seq的值与ack=1则建立成功

发送完毕后，客户端进入`ESTABLISEND`状态，当服务器端接收到这个包时，也进入`ESTABLISEND`状态，TCP握手结束。

三次握手图示：

![](https://raw.githubusercontent.com/HIT-Alibaba/interview/master/img/tcp-connection-made-three-way-handshake.png)

## 四次挥手

TCP的连接的拆除需要发送四个包，因此称为四次挥手，也叫做改进的三次扬。客户端和服务端均可以主动发起挥手动作，在socket编程中，任何一方执行`close()`操作即可产生挥手操作。

- 第一次挥手（FIN=1，seq=x）

以客户端想要关闭连接为例，客户端发送一个FIN标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。

发送完毕后，客户端`FIN_WAIT_1`状态

- 第二次挥手（ACK=1, ACKnum=x+1， seq=y）

服务器端确认客户的FIN包，发送一个确认包，ACK标志位为1，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接，ACKnum=x+1，同时也需要生成一个seq=y

发送完毕后，服务器进入`CLOSE_WAIT`状态，客户端接收到这个确认包之后，进入`FIN_WAIT2`状态，等待服务器关闭连接

- 第三次挥手（FIN=1，ACK=1 seq=z，ACKnumber=x+1,）

服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN置为1，ACK也为1

发送完毕后，服务器进入`LAST_ACK`状态，等待来自客户端的最后一个ACK

- 第四次挥手（ACK=1，seq=x+1，ACKnum=z+1）

客户端接收来自服务器端的关闭请求，发送一个确认包，并进入`TIME_WAIT`状态，等待可能出现的要求重传的ACK包

服务器端接收到这个确认包之后，关闭连接，进入`close`状态

客户端等待了某个固定时间之后，没有收到服务器端的ACK，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入`CLOSED`状态。

四次挥手的示意图如下：

![](https://upload-images.jianshu.io/upload_images/1641067-5ed8bf6c24244b4c.png)

## 为什么建立连接需要三次握手，关闭连接需要四次握手

因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建立连接请求后，它可以把ACK和SYN（ACK起应用作用，SYN起同步作用）放一个报文里来发送，但关闭连接时，在收到对方的FIN报文通知时，仅仅表示没有数据要发送给你了，但未必你所的数据都全部发送给对方了，所以你未必会马上关闭SOCKET，也就是说你可能还会发送一份数据给对方之后，再发送FIN报文对对方表示同意关闭连接，所以它这里的ACK报文和FIN报文是分开发送

# TCP KeepAlive

TCP 的连接，实际上是一种纯软件层面的概念，在物理层面并没有“连接”这种概念。TCP 通信双方建立交互的连接，但是并不是一直存在数据交互，有些连接会在数据交互完毕后，主动释放连接，而有些不会。在长时间无数据交互的时间段内，交互双方都有可能出现掉电、死机、异常重启等各种意外，当这些意外发生之后，这些 TCP 连接并未来得及正常释放，在软件层面上，连接的另一方并不知道对端的情况，它会一直维护这个连接，长时间的积累会导致非常多的半打开连接，造成端系统资源的消耗和浪费，为了解决这个问题，在传输层可以利用 TCP 的 KeepAlive 机制实现来实现。主流的操作系统基本都在内核里支持了这个特性。

TCP KeepAlive 的基本原理是，隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。

TCP-Keepalive-HOWTO 有对 TCP KeepAlive 特性的详细介绍，有兴趣的同学可以参考。这里主要说一下，TCP KeepAlive 的局限。首先 TCP KeepAlive 监测的方式是发送一个 probe 包，会给网络带来额外的流量，另外 TCP KeepAlive 只能在内核层级监测连接的存活与否，而连接的存活不一定代表服务的可用。例如当一个服务器 CPU 进程服务器占用达到 100%，已经卡死不能响应请求了，此时 TCP KeepAlive 依然会认为连接是存活的。因此 TCP KeepAlive 对于应用层程序的价值是相对较小的。需要做连接保活的应用层程序，例如 QQ，往往会在应用层实现自己的心跳功能。

# 关于`ack = x+1`

需要注意的是， 上图中出现的 ACK = x +1 的写法很容易让人误以为数据包中的 ACK 域的数据值被填成了 y+1 。 ACK = x+1 的实际含义是：

- TCP 包的 ACK 标志位（1 bit） 被置成了 1

- TCP 包的确认号（acknowledgement number ） 的值为 x+1

类似的， TCP 数据包中的 SYN 标志位， 也容易与序号（sequence number） 混淆， 这点需要读者注意

![](https://img-blog.csdn.net/2018091917061915?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbmd4aWFvMTk5Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

# 为什么需要三次握手，而非两次

三次握手即通信双方相互告知初始序号， 并确认对方已收到己方的初始序号

三次握手（A three way handshake）是必须的， 因为 sequence numbers（序列号）没有绑定到整个网络的全局时钟（全部统一使用一个时钟，
就可以确定这个包是不是延迟到的）以及 TCPs 可能有不同的机制来选择 ISN（初始序列号）。
接收方接收到第一个 SYN 时，没有办法知道这个 SYN 是是否延迟了很久了，除非他有办法记住在这条连接中，
最后接收到的那个sequence numbers（然而这不总是可行的）。
这句话的意思是：一个 seq 过来了，跟现在记住的 seq 不一样，我怎么知道他是上条延迟的，还是上上条延迟的呢？
所以，接收方一定需要跟发送方确认 SYN。

在《计算机网络》一书中其中有提到，三次握手的目的是“为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误”，
这种情况是：一端(client)A发出去的第一个连接请求报文并没有丢失，而是因为某些未知的原因在某个网络节点上发生滞留，
导致延迟到连接释放以后的某个时间才到达另一端(server)B。本来这是一个早已失效的报文段，但是B收到此失效的报文之后，
会误认为是A再次发出的一个新的连接请求，于是B端就向A又发出确认报文，表示同意建立连接。如果不采用“三次握手”，
那么只要B端发出确认报文就会认为新的连接已经建立了，但是A端并没有发出建立连接的请求，因此不会去向B端发送数据，
B端没有收到数据就会一直等待，这样B端就会白白浪费掉很多资源。如果采用“三次握手”的话就不会出现这种情况，B端收到一个过时失效的报文段之后，
向A端发出确认，此时A并没有要求建立连接，所以就不会向B端发送确认，这个时候B端也能够知道连接没有建立。

TPC的连接是交互序号的过程，A向B通信，B向A回传，这两次只能确认对A的序列号答成一致，并不能对B的序列号还没确认

- A向B说，我是A

- B回A，我知道你是A了，我是B

此时结束的话，B会想，这A到底知道不知道我是B