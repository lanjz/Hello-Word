[四个全新维度，优化你的 HTTP 性能到极致](https://yq.aliyun.com/articles/742698?spm=a2c4e.11155472.0.0.21af23e9yuziFN)

# HTTP的演变历史

1. HTTP/0.9

  HTTP/0.9 极其简单：请求由单行指令构成，以唯一可用方法GET开头，其后跟目标资源的路径（一旦连接到服务器，协议、服务器、端口号这些都不是必须的）。

2. HTTP/1.0

  - 协议版本信息现在会随着每个请求发送（HTTP/1.0被追加到了GET行）

  - 状态码会在响应开始时发送，使浏览器能了解请求执行成功或失败，并相应调整行为（如更新或使用本地缓存）。

  - 引入了HTTP头的概念，无论是对于请求还是响应，允许传输元数据，使协议变得非常灵活，更具扩展性。

3. HTTP/1.1

  - 连接可利用，节省TCP连接的连接， `keep-alive`

  - 增加流水线操作，允许在第一个应答被完全发送之前就发送第二个请求，以降低通信延迟。

  - 支持响应分块。

  - 引入额外的缓存控制机制。

  - 引入内容协商机制，包括语言，编码，类型等，并允许客户端和服务器之间约定以最合适的内容进行交换。

  - Host头，能够使不同域名配置在同一个IP地址的服务器上。

4. HTTP/2

  - 由二进制协议代替文本协议

  - 多路复用

  - 压缩Headers

  - 服务端可以在客户端某个请求后，主动推送消息给客户端

5.  后HTTP/2

  - 对Alt-Svc的支持允许了给定资源的位置和资源鉴定，允许了更智能的CDN缓冲机制。

  - Client-Hints 的引入允许浏览器或者客户端来主动交流它的需求，或者是硬件约束的信息给服务端。

  - 在Cookie头中引入安全相关的的前缀，现在帮助保证一个安全的cookie没被更改过

# HTTP

> [MDN-HTTP](https://developer.mozilla.org/zh-CN/docs/Web/HTTP)

> **超文本传输协议**（HTTP）用于传输诸如HTML这样的的网络资源的protocol(通讯协议)。它通用用于浏览器与Web服务器之间通信。HTTP遵循经典的客户端-服务端模型，客户端打开一个连接以发出请求，然后等待它收到服务器端响应。HTTP是无状态的，意味着服务器不会在两个请求之间保留任何数据。通常基于TCP/IP层，但可以在任何可靠的传输层上使用，比如UDP

## HTTP的性质 

- HTTP协议是构建于TCP/IP协议之上，是一个应用层协议，默认端口是80

- HTTP是简单

  下一代HTTP/2协议将HTTP消息封装到了帧(iframe)中，但大体上还是设计简单易懂（废话）

- HTTP是可扩展的

  通过HTTP中的Headers属性，我们可以方便进行一些扩展

- HTTP是无状态的，有会话的

  在同一个连接中，两个执行成功的请求之间没有任何关系。这就带来一个问题，用户没有办法在同一网站中进行连续的交互，如果在电商网站中，用户把某个商品加入购物车，切换一个而后再添加了商品，这两次添加的商品的请求之间没有关联，浏览器无法知道用户最终选择了哪些商品。而使用HTTP的头部扩展，HTTP Cookies就可以解决这些问题。把Cookies添加到头部，创建一个会话让每个请求都能共享相同的上下文信息，达成相同的状态

  **HTTP是无状态的，但使用Cookies可以创建有状态的会话**

## HTTP和连接

一个连接是由传输层来控制的，这从根本上不属于HTTP的范围。HTTP只关心其底层的连接是否可靠（不丢消息，或返回错误）。
在互联网中，有两个最常用的传输层协议：TCP是可靠的，而UDP不是。因此，HTTP依赖于面向连接的TCP进行消息传递，但连接并不是必须的。


# HTTP报文

## 请求报文

![](https://mdn.mozillademos.org/files/13687/HTTP_Request.png)

一个请求由下以下元素组成：

- Method：请求方法，例如`GET`、`POST`等

- Path：获取资源的路径

- HTTP协议版本号

- 为服务端表达其他信息的可选头部headers

- 对于一些像POST这样的方法，报文的body就包含了发送的资源，这与响应报文的body类似

## 响应报文

![](https://mdn.mozillademos.org/files/13691/HTTP_Response.png)

响应报头包含以下元素：

- HTTP协议版本号

- 一个状态码，来告知对应请求执行成功或失败，以及失败的原因

- HTTP headers，与语法头部类似

- 可选项，比起请求报文，响应报文中多得包含获取资源的body

## HTTP能控制什么

- 缓存：

文档如何缓存能通过HTTP来控制。服务端能告诉代理和客户端哪些文档需要被缓存，缓存多久，而客户端也能够命令中间的缓存代理来忽略存储的文档。

- 开放同源限制

为了防止网络窥听和其它隐私泄漏，浏览器强制对Web网站做了分割限制。只有来自于相同来源的网页才能够获取网站的全部信息。这样的限制有时反而成了负担，HTTP可以通过修改头部来开放这样的限制，因此Web文档可以是由不同域下的信息拼接成的（某些情况下，这样做还有安全因素考虑）。

- 认证

一些页面能够被保护起来，仅让特定的用户进行访问。基本的认证功能可以直接通过HTTP提供，使用Authenticate相似的头部即可，或用HTTP Cookies来设置指定的会话。

- 代理和隧道

通常情况下，服务器和/或客户端是处于内网的，对外网隐藏真实 IP 地址。因此 HTTP 请求就要通过代理越过这个网络屏障。但并非所有的代理都是 HTTP 代理。例如，SOCKS协议的代理就运作在更底层，一些像 FTP 这样的协议也能够被它们处理。

- 会话

使用HTTP Cookies允许你用一个服务端的状态发起请求，这就创建了会话。虽然基本的HTTP是无状态协议。这很有用，不仅是因为这能应用到像购物车这样的电商业务上，更是因为这使得任何网站都能轻松为用户定制展示内容了。




## HTTP瓶颈

- 一个连接只能发送一个请求

- 请求只能客户端发起，客户端不可以接收除了响应以外的指令

- 请求/响应未练压缩就发送，首部信息越多延迟越大

- 发送冗余的首部。每次互相发送相同的首部造成的浪费较多

- 可任意选择数据压缩方式。非强制压缩发送