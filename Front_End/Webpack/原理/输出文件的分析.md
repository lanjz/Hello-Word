## `bundle.js`文件分析

一个简单的bundle.js文件的内容如下：

以上看上去复杂的代码其实是一个立即执行函数，可以简写如下：

```
 (function (modules) {
    // 模拟require语句
    function __webpack_require__() {
      // 执行存放所有模块数组中的第0个模块
      __webpack_require__(0)
    }
  })([/*存放所有模块的数组*/])

```

`bundle.js`能直接运行在浏览器中的原因是，在输出的文件中通过`__webpak__require__`函数，定义了一个可以在浏览器中执行的加载函数，来模拟Node.js中的`require`语句

原来一个个独立的模块文件被合并到了一个单独的bundle.js的原因是，浏览器不能像Node.js那样快速地在本地加载一个个模块文件，而必须通过网络请求去加载未得到的文件。如果模块的数量很多，则加载时间会很长，因此将所有模块都存在数组中，执行一次网络回去

仔细分析`__webpak__require__`函数的实现，我们还会发现Webpack做了缓存优化，执行加载过的模块不会再执行第二次，执行结果缓存在内存中，当某个再次被用到时，直接从缓存中获取

## 加入按需要加载后的`bundle.js`文件分析

这里的`bundle.js`和之前上比非常相似，区别在于：

- 多了一个`__webpack_require__.e`，用于加载被分割出去的需要异步加载的Chunk对应的文件

- 多了一个`webpackJson`函数，用于从异步加载的文件中安装模块

使用`CommonsChunkPlugin`提取公共代码时输出的文件和使用异步加载时输出的文件是一样的，都会有`__webpack_require__.e`和`webpackJson`。原因在于提取公共代码和异步加载在本质上都代码分割
